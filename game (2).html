<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>עולם וירטואלי אונליין - מרובה משתתפים</title>
  <!-- Socket.io Client -->
  <script src="/socket.io/socket.io.js"></script>
  <style>
    :root {
      --gold1: #fff3b0;
      --gold2: #ffd700;
      --bg: #0f1220;
      --panel: rgba(255,255,255,0.06);
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: #fff;
      font-family: "Segoe UI", Tahoma, Arial, sans-serif;
      overscroll-behavior: none;
    }
    #game {
      position: fixed;
      inset: 0;
      display: block;
      width: 100vw;
      height: 100vh;
      background: #0f1220;
    }
    #ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }
    #adminBtn {
      pointer-events: auto;
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      background: #23263b;
      color: #fff;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      transition: transform .08s ease, box-shadow .2s ease, background .2s ease;
      user-select: none;
      cursor: pointer;
    }
    #adminBtn:hover { transform: translateY(-1px); }
    #adminBtn:active { transform: translateY(1px); }
    #adminBtn.active {
      background: linear-gradient(135deg, var(--gold1), var(--gold2));
      color: #2c2200;
      box-shadow: 0 8px 24px rgba(255,215,0,0.35);
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
    }
    #explorerBtn {
      pointer-events: auto;
      position: absolute;
      top: 70px;
      right: 16px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      background: #23263b;
      color: #fff;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      transition: transform .08s ease, box-shadow .2s ease, background .2s ease;
      user-select: none;
      cursor: pointer;
    }
    #explorerBtn:hover { transform: translateY(-1px); }
    #explorerBtn:active { transform: translateY(1px); }
    #explorerBtn.active {
      background: linear-gradient(135deg, #ffffff, #f0f0f0);
      color: #333;
      box-shadow: 0 8px 24px rgba(255,255,255,0.35);
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
    }
    #explorerMessageBtn {
      pointer-events: auto;
      position: absolute;
      top: 228px;
      right: 16px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      background: linear-gradient(135deg, #ffffff, #f0f8ff);
      color: #333;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(255,255,255,0.35);
      transition: transform .08s ease, box-shadow .2s ease, background .2s ease;
      user-select: none;
      cursor: pointer;
    }
    #explorerMessageBtn:hover { 
      transform: translateY(-1px); 
      box-shadow: 0 8px 20px rgba(255,255,255,0.45);
    }
    #explorerMessageBtn:active { transform: translateY(1px); }
    #coinsDisplay {
      pointer-events: auto;
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ffd700, #ffb300);
      color: #2c1810;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 18px;
      box-shadow: 0 4px 12px rgba(255,215,0,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    #onlineDisplay {
      pointer-events: auto;
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #00d2d3, #01a3a4);
      color: #ffffff;
      padding: 6px 12px;
      border-radius: 15px;
      font-weight: bold;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,210,211,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    #connectionStatus {
      pointer-events: auto;
      position: absolute;
      top: 120px;
      right: 16px;
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      color: #ffffff;
      padding: 6px 12px;
      border-radius: 15px;
      font-weight: bold;
      font-size: 12px;
      box-shadow: 0 4px 12px rgba(46,204,113,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    #connectionStatus.disconnected {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      box-shadow: 0 4px 12px rgba(231,76,60,0.3);
    }
    
    #levelDisplay {
      pointer-events: auto;
      position: absolute;
      top: 380px;
      left: 16px;
      background: linear-gradient(135deg, #6c5ce7, #a29bfe);
      color: #ffffff;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 4px 12px rgba(108,92,231,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 80px;
    }
    
    #xpDisplay {
      position: absolute;
      top: 430px;
      left: 16px;
      background: rgba(0,0,0,0.6);
      color: #ffffff;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
      min-width: 200px;
    }
    
    .xp-bar {
      width: 100%;
      height: 8px;
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
      margin-top: 4px;
      overflow: hidden;
    }
    
    .xp-progress {
      height: 100%;
      background: linear-gradient(90deg, #00d2d3, #01a3a4);
      border-radius: 4px;
      transition: width 0.3s ease;
      box-shadow: 0 0 8px rgba(0, 210, 211, 0.5);
    }
    
    #quickMissionBtn {
      pointer-events: auto;
      position: absolute;
      top: 480px;
      left: 16px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      background: linear-gradient(135deg, #ff6b35, #f7931e);
      color: #fff;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(255, 107, 53, 0.25);
      transition: transform .08s ease, box-shadow .2s ease;
      user-select: none;
      cursor: pointer;
      font-size: 14px;
      min-width: 120px;
    }
    #quickMissionBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(255, 107, 53, 0.35);
    }
    #quickMissionBtn:active {
      transform: translateY(1px);
    }
    #quickMissionBtn.active {
      background: linear-gradient(135deg, #00d2d3, #01a3a4);
      box-shadow: 0 8px 24px rgba(0, 210, 211, 0.35);
    }
    #coinsDisplay:hover {
      transform: translateX(-50%) translateY(-2px);
      box-shadow: 0 6px 16px rgba(255,215,0,0.4);
      filter: brightness(1.1);
    }
    #coinsDisplay:active {
      transform: translateX(-50%) translateY(0px);
    }
    #shopBtn {
      pointer-events: auto;
      position: absolute;
      top: 120px;
      right: 16px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: #fff;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(76,175,80,0.25);
      transition: transform .08s ease;
      cursor: pointer;
    }
    #shopBtn:hover { transform: translateY(-1px); }
    #shopBtn:active { transform: translateY(1px); }
    #audioBtn {
      pointer-events: auto;
      position: absolute;
      top: 174px;
      right: 16px;
      padding: 10px 14px;
      border-radius: 10px;
      border: 0;
      background: linear-gradient(135deg, #ff9ff3, #feca57);
      color: #fff;
      font-weight: 700;
      box-shadow: 0 6px 16px rgba(255, 159, 243, 0.25);
      transition: transform .08s ease;
      cursor: pointer;
    }
    #audioBtn:hover { transform: translateY(-1px); }
    #audioBtn:active { transform: translateY(1px); }
    #audioBtn.active {
      background: linear-gradient(135deg, #00d2d3, #54a0ff);
      box-shadow: 0 8px 24px rgba(0, 210, 211, 0.35);
    }
    
    /* Minimap Styles */
    #minimap {
      pointer-events: auto;
      position: absolute;
      top: 300px;
      right: 16px;
      width: 180px;
      height: 180px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(4px);
      z-index: 10;
      transition: all 0.3s ease;
    }
    
    #minimap.expanded {
      width: 350px;
      height: 350px;
      top: 50% !important;
      left: 50% !important;
      right: auto !important;
      transform: translate(-50%, -50%) !important;
      z-index: 1000;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      border-color: rgba(255, 255, 255, 0.5);
      position: fixed !important;
    }
    
    #minimap-title {
      text-align: center;
      font-size: 11px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 4px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    #minimap.expanded #minimap-title {
      font-size: 14px;
      margin-bottom: 8px;
    }
    
    #minimap-canvas {
      width: 100%;
      height: calc(100% - 20px);
      border-radius: 6px;
      background: rgba(15, 18, 32, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: crosshair;
    }
    
    #minimap.expanded #minimap-canvas {
      height: calc(100% - 40px);
    }
    
    #minimap:hover {
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      transform: translateY(-1px);
      transition: all 0.2s ease;
    }
    
    .minimap-controls {
      display: flex;
      gap: 4px;
    }
    
    .minimap-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 10px;
      cursor: pointer;
      padding: 3px 6px;
      border-radius: 4px;
      opacity: 0.8;
      transition: all 0.2s ease;
    }
    
    .minimap-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }
    
    #minimap.expanded .minimap-btn {
      font-size: 12px;
      padding: 4px 8px;
    }
    
    #minimap-zoom-controls {
      position: absolute;
      bottom: 8px;
      right: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    #zoom-indicator {
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      text-align: center;
      min-width: 40px;
    }
    
    .zoom-buttons {
      display: flex;
      gap: 4px;
    }
    
    #minimap.expanded #minimap-zoom-controls {
      opacity: 1;
    }
    
    /* Background overlay for expanded minimap */
    #minimap-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      z-index: 999;
    }
    
    #minimap.expanded + #minimap-overlay {
      display: block;
    }
    
    .zoom-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .zoom-btn:hover {
      background: rgba(0, 0, 0, 0.8);
      border-color: rgba(255, 255, 255, 0.5);
      transform: scale(1.1);
    }
    
    /* Minimap tooltip */
    #minimap-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.95);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: bold;
      pointer-events: none;
      white-space: nowrap;
      z-index: 1000;
      opacity: 0;
      transition: all 0.2s ease;
      transform: translate(-50%, -120%);
      margin-top: -10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      max-width: 200px;
    }
    
    #minimap-tooltip.visible {
      opacity: 1;
    }
    
    #minimap-tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid rgba(0, 0, 0, 0.8);
    }
    
    /* Legend Modal */
    #legendModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #legendModal.open { display: flex; }
    #legendContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 500px;
      width: 90vw;
      max-height: 70vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #legendHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #legendTitle {
      font-size: 24px;
      font-weight: bold;
      color: #4ecdc4;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #closeLegend {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    .legend-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      padding: 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.2s ease;
    }
    
    .legend-item:hover {
      background: rgba(255,255,255,0.08);
      transform: translateY(-1px);
    }
    
    .legend-icon {
      width: 16px;
      height: 16px;
      margin-left: 12px;
      border-radius: 50%;
      display: inline-block;
      flex-shrink: 0;
    }
    
    .legend-npc {
      background: #ff6b6b;
      border: 1px solid #fff;
    }
    
    .legend-shop {
      background: #9370db;
      border: 1px solid #fff;
    }
    
    .legend-gift {
      background: linear-gradient(45deg, #ff6b6b, #ff4757);
      width: 14px;
      height: 14px;
      border-radius: 3px;
      position: relative;
      border: 1px solid #fff;
    }
    
    .legend-gift::after {
      content: '+';
      position: absolute;
      top: -1px;
      left: 4px;
      color: #ffd700;
      font-size: 12px;
      font-weight: bold;
      text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
    }
    
    .legend-coin {
      background: #ffd700;
      border: 1px solid #b8860b;
    }
    
    .legend-player {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      border: 2px solid #fff;
      position: relative;
    }
    
    .legend-player::after {
      content: '→';
      position: absolute;
      top: 1px;
      left: 4px;
      color: #fff;
      font-size: 12px;
      font-weight: bold;
      text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
    }
    
    .legend-house {
      background: #8b4513;
      border: 1px solid #654321;
      border-radius: 2px;
    }
    
    .legend-home {
      background: linear-gradient(45deg, #ffaa00, #ff8800);
      border: 2px solid #fff;
      border-radius: 2px;
      box-shadow: 0 0 6px rgba(255, 170, 0, 0.6);
    }
    
    .legend-road {
      background: linear-gradient(90deg, #707070, #909090);
      border-radius: 2px;
      height: 6px;
      width: 16px;
      border: none;
    }
    
    .legend-trees {
      background: radial-gradient(circle, #228b22, #006400);
      border: 1px solid #2e7d32;
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    
    .legend-view {
      background: transparent;
      border: 2px dashed rgba(255, 255, 255, 0.8);
      border-radius: 2px;
    }
    #shopModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #shopModal.open { display: flex; }
    #shopContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 500px;
      width: 90vw;
      max-height: 70vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #shopHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #shopTitle {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
    }
    #closeShop {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    .shop-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      margin: 8px 0;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .item-info {
      flex: 1;
    }
    .item-name {
      font-weight: bold;
      color: #fff;
      margin-bottom: 4px;
    }
    .item-description {
      font-size: 14px;
      color: #bbb;
    }
    .item-price {
      color: #ffd700;
      font-weight: bold;
      margin-left: 12px;
    }
    .buy-btn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    .buy-btn:hover { background: #45a049; }
    .buy-btn:disabled {
      background: #666;
      cursor: not-allowed;
    }

    /* Inventory (Bag) - Now in chat bar */
    #inventoryBtn {
      padding: 10px 12px;
      border-radius: 8px;
      border: 0;
      background: linear-gradient(135deg, #6c5ce7, #a29bfe);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(108,92,231,0.35);
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #inventoryBtn:hover { filter: brightness(1.05); transform: translateY(-1px); }
    #inventoryBtn:active { filter: brightness(0.95); transform: translateY(1px); }

    #invModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #invModal.open { display: flex; }
    #invContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 640px;
      width: 92vw;
      max-height: 72vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #invHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 10px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #invTitle { font-size: 22px; font-weight: bold; color: #ff7eb3; }
    #closeInv {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    .inv-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
    }
    .inv-item {
      display: flex;
      gap: 10px;
      align-items: center;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 10px;
    }
    .inv-icon { font-size: 28px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.35)); }
    .inv-info { flex: 1; }
    .inv-name { font-weight: bold; }
    .inv-slot { font-size: 12px; color: #bbb; }
    .equip-btn {
      background: #2196F3;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    .equip-btn.unequip { background: #9E9E9E; }
    .equip-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Floating pickup text */
    .pickups { position: absolute; pointer-events: none; inset: 0; }
    .pickup-text { position: absolute; color: #fff; font-weight: bold; text-shadow: 0 2px 6px rgba(0,0,0,0.6); }
    #help {
      pointer-events: none;
      position: absolute;
      top: 16px;
      left: 16px;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      line-height: 1.4;
      max-width: min(42vw, 520px);
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
      backdrop-filter: blur(2px);
    }

    #questPanel {
      pointer-events: none;
      position: absolute;
      top: 120px;
      left: 16px;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      line-height: 1.5;
      min-width: 220px;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
      backdrop-filter: blur(2px);
    }
    #questPanel .q-title { font-weight: 700; color: #ffd700; }
    #questPanel .q-line { opacity: 0.95; }

    #chatBar {
      pointer-events: auto;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 16px;
      display: flex;
      gap: 8px;
      background: rgba(20,24,40,0.7);
      padding: 10px;
      border-radius: 12px;
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(6px);
    }
    #chatInput {
      width: min(56vw, 560px);
      max-width: 72vw;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.95);
      color: #111;
      outline: none;
      font-size: 16px;
      direction: rtl;
    }
    #sendBtn {
      padding: 10px 14px;
      border-radius: 8px;
      border: 0;
      background: linear-gradient(135deg, #89f7fe, #66a6ff);
      color: #06122b;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(102,166,255,0.35);
    }
    #sendBtn:hover { filter: brightness(1.05); }
    #sendBtn:active { filter: brightness(0.95); }
    
    #homeBtn {
      padding: 10px 12px;
      border-radius: 8px;
      border: 0;
      background: linear-gradient(135deg, #ff7675, #fd79a8);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(255,118,117,0.35);
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #homeBtn:hover { filter: brightness(1.05); transform: translateY(-1px); }
    #homeBtn:active { filter: brightness(0.95); transform: translateY(1px); }
    
    #emojiBtn {
      padding: 10px 12px;
      border-radius: 8px;
      border: 0;
      background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
      color: #2d3436;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(253,203,110,0.35);
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #emojiBtn:hover { filter: brightness(1.05); transform: translateY(-1px); }
    #emojiBtn:active { filter: brightness(0.95); transform: translateY(1px); }
    
    #emojiPanel {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 12px;
      padding: 16px;
      display: none;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      border: 2px solid rgba(255,255,255,0.1);
      max-width: 280px;
      z-index: 1001;
    }
    #emojiPanel.open { display: grid; }
    
    .emoji-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 8px;
      padding: 12px;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 48px;
    }
    .emoji-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }
    .emoji-btn:active {
      transform: scale(0.95);
    }
    
    /* Trade Modal */
    #tradeModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #tradeModal.open { display: flex; }
    #tradeContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 600px;
      width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #tradeHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #tradeTitle {
      font-size: 24px;
      font-weight: bold;
      color: #ff9ff3;
    }
    #closeTrade {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    .trade-offer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px;
      margin: 12px 0;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .trade-info {
      flex: 1;
    }
    .trade-name {
      font-weight: bold;
      color: #fff;
      margin-bottom: 8px;
      font-size: 16px;
    }
    .trade-details {
      font-size: 14px;
      color: #bbb;
      margin-bottom: 4px;
    }
    .trade-items {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 4px 0;
    }
    .trade-item {
      background: rgba(255,255,255,0.1);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      color: #ddd;
    }
    .trade-btn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    }
    .trade-btn:hover { background: #45a049; }
    .trade-btn:disabled {
      background: #666;
      cursor: not-allowed;
    }
    .trade-arrow {
      font-size: 20px;
      color: #ff9ff3;
      margin: 0 12px;
    }
    
    /* Dance Panel */
    #dancePanel {
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #ff6b9d, #c0392b);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 8px;
      display: none;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      z-index: 1000;
    }
    #dancePanel.open { display: grid; }
    .dance-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      width: 44px;
      height: 44px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .dance-btn:hover {
      background: rgba(255, 255, 255, 1);
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(255, 105, 157, 0.4);
    }
    .dance-btn:active {
      transform: scale(0.95);
    }
    .dance-btn[data-dance="stop"] {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
    }
    .dance-btn[data-dance="stop"]:hover {
      background: linear-gradient(135deg, #c0392b, #a93226);
    }
    
    /* Memory Game Modal */
    #memoryModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #memoryModal.open { display: flex; }
    #memoryContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 600px;
      width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #memoryHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #memoryTitle {
      font-size: 24px;
      font-weight: bold;
      color: #74b9ff;
    }
    #closeMemory {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    #memoryInfo {
      text-align: center;
      margin-bottom: 20px;
    }
    #memoryInstructions {
      font-size: 16px;
      color: #ddd;
      margin-bottom: 10px;
    }
    #memoryScore {
      font-size: 18px;
      font-weight: bold;
      color: #ffd700;
    }
    #memoryGrid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin: 20px 0;
      justify-items: center;
    }
    .memory-npc {
      width: 120px;
      height: 120px;
      border-radius: 12px;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }
    .memory-npc:hover {
      transform: scale(1.05);
      background: rgba(255,255,255,0.2);
    }
    .memory-npc.highlight {
      background: linear-gradient(135deg, #ffd700, #ff6b9d);
      transform: scale(1.1);
      box-shadow: 0 8px 24px rgba(255, 215, 0, 0.4);
    }
    .memory-npc.correct {
      background: linear-gradient(135deg, #00d2d3, #01a3a4);
      animation: correctPulse 0.6s ease;
    }
    .memory-npc.wrong {
      background: linear-gradient(135deg, #ff4757, #c44569);
      animation: wrongShake 0.6s ease;
    }
    @keyframes correctPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    @keyframes wrongShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }
    .memory-npc-emoji {
      font-size: 36px;
      margin-bottom: 8px;
    }
    .memory-npc-name {
      font-size: 14px;
      font-weight: bold;
      color: white;
      text-align: center;
    }
    #memoryButtons {
      text-align: center;
      margin-top: 20px;
    }
    #startMemoryGame {
      background: linear-gradient(135deg, #74b9ff, #0984e3);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    #startMemoryGame:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(116, 185, 255, 0.4);
    }
    
    #memoryBtn {
      padding: 10px 12px;
      border-radius: 8px;
      border: 0;
      background: linear-gradient(135deg, #74b9ff, #0984e3);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(116, 185, 255, 0.35);
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #memoryBtn:hover { filter: brightness(1.05); transform: translateY(-1px); }
    #memoryBtn:active { filter: brightness(0.95); transform: translateY(1px); }
    
    /* Profile Modal */
    #profileModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #profileModal.open { display: flex; }
    #profileContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 800px;
      width: 90vw;
      max-height: 85vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #profileHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #profileTitle {
      font-size: 24px;
      font-weight: bold;
      color: #4ecdc4;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #closeProfile {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    .profile-main {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 24px;
      margin-bottom: 20px;
    }
    .profile-avatar {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .avatar-display {
      width: 200px;
      height: 280px;
      margin: 0 auto 16px;
      background: linear-gradient(135deg, #f0f8ff, #e6f3ff);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border: 3px solid rgba(255,255,255,0.2);
      box-shadow: 0 8px 24px rgba(78, 205, 196, 0.3);
      overflow: hidden;
    }
    .player-preview {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .player-part {
      position: absolute;
      font-size: 24px;
      z-index: 1;
    }
    .player-head {
      top: 20px;
      font-size: 32px;
      z-index: 10;
    }
    .player-body {
      top: 60px;
      font-size: 40px;
      z-index: 5;
    }
    .player-arms {
      top: 80px;
      font-size: 28px;
      z-index: 6;
    }
    .player-legs {
      top: 140px;
      font-size: 36px;
      z-index: 4;
    }
    .player-feet {
      bottom: 20px;
      font-size: 24px;
      z-index: 7;
    }
    .player-equipment {
      position: absolute;
      font-size: 28px;
    }
    .equipment-hat {
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
      font-size: 30px;
    }
    .equipment-face {
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 12;
      font-size: 24px;
    }
    .equipment-chest {
      top: 68px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 8;
      font-size: 32px;
    }
    .equipment-back {
      top: 60px;
      right: 15px;
      z-index: 3;
      font-size: 28px;
    }
    .equipment-feet {
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9;
      font-size: 28px;
    }
    .equipment-effect {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      font-size: 40px;
      opacity: 0.7;
      animation: effectPulse 2s ease-in-out infinite;
      pointer-events: none;
    }
    @keyframes effectPulse {
      0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    }
    .avatar-display.admin {
      background: linear-gradient(135deg, #ffd700, #ff6b6b);
      box-shadow: 0 8px 24px rgba(255, 215, 0, 0.4), 0 0 20px rgba(255, 215, 0, 0.3);
      animation: adminGlow 2s ease-in-out infinite alternate;
    }
    @keyframes adminGlow {
      from { box-shadow: 0 8px 24px rgba(255, 215, 0, 0.4), 0 0 20px rgba(255, 215, 0, 0.3); }
      to { box-shadow: 0 8px 32px rgba(255, 215, 0, 0.6), 0 0 30px rgba(255, 215, 0, 0.5); }
    }
    .player-name {
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 8px;
    }
    .player-name.admin {
      color: #ffd700;
      text-shadow: 0 2px 8px rgba(255, 215, 0, 0.5);
    }
    .player-status {
      font-size: 14px;
      color: #4ecdc4;
      font-weight: 600;
    }
    .profile-stats {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }
    .stat-item {
      background: rgba(255,255,255,0.08);
      padding: 12px 16px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #fff;
      display: block;
      margin-bottom: 4px;
    }
    .stat-label {
      font-size: 12px;
      color: #bbb;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .profile-equipment {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(255,255,255,0.1);
      margin-top: 20px;
    }
    .equipment-title {
      font-size: 18px;
      font-weight: bold;
      color: #4ecdc4;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .equipment-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    .equipment-slot {
      background: rgba(255,255,255,0.08);
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 16px;
      text-align: center;
      min-height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .equipment-slot:hover {
      background: rgba(255,255,255,0.12);
      border-color: rgba(78, 205, 196, 0.5);
      transform: translateY(-2px);
    }
    .equipment-slot.equipped {
      background: rgba(78, 205, 196, 0.15);
      border: 2px solid rgba(78, 205, 196, 0.4);
    }
    .equipment-slot-icon {
      font-size: 24px;
      margin-bottom: 4px;
    }
    .equipment-slot-name {
      font-size: 12px;
      color: #ddd;
      font-weight: bold;
    }
    .equipment-slot-empty {
      font-size: 10px;
      color: #888;
    }
    
    /* Equipment Selection Modal */
    #equipmentModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1100;
    }
    #equipmentModal.open { display: flex; }
    #equipmentContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 500px;
      width: 90vw;
      max-height: 70vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #equipmentHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #equipmentTitle {
      font-size: 20px;
      font-weight: bold;
      color: #4ecdc4;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #closeEquipment {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    .equipment-options {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    .equipment-option {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .equipment-option:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(78, 205, 196, 0.5);
      transform: translateY(-2px);
    }
    .equipment-option.equipped {
      background: rgba(78, 205, 196, 0.2);
      border-color: rgba(78, 205, 196, 0.6);
    }
    .equipment-option.locked {
      opacity: 0.4;
      cursor: not-allowed;
      background: rgba(255,255,255,0.02);
    }
    .equipment-option.locked:hover {
      background: rgba(255,255,255,0.02);
      border-color: rgba(255,255,255,0.1);
      transform: none;
    }
    .equipment-option-icon {
      font-size: 32px;
      margin-bottom: 4px;
    }
    .equipment-option-name {
      font-size: 12px;
      font-weight: bold;
      color: #fff;
      text-align: center;
    }
    .equipment-option-status {
      font-size: 10px;
      color: #bbb;
      text-align: center;
    }
    .remove-equipment-btn {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      width: 100%;
      margin-top: 12px;
      transition: all 0.3s ease;
    }
    .remove-equipment-btn:hover {
      background: linear-gradient(135deg, #c0392b, #a93226);
      transform: translateY(-1px);
    }
    
    /* Global Message Modal (Explorer Feature) */
    #globalMessageModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1100;
    }
    #globalMessageModal.open { display: flex; }
    #globalMessageContent {
      background: linear-gradient(135deg, #ffffff, #f0f8ff);
      border-radius: 16px;
      padding: 24px;
      max-width: 600px;
      width: 90vw;
      max-height: 70vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.8);
      box-shadow: 0 20px 40px rgba(255,255,255,0.3), 0 0 20px rgba(255,255,255,0.2);
    }
    #globalMessageHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(0,0,0,0.1);
    }
    #globalMessageTitle {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #closeGlobalMessage {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    #globalMessageBody {
      color: #333;
    }
    #globalMessageBody p {
      margin-bottom: 16px;
      font-size: 16px;
      line-height: 1.5;
    }
    #globalMessageInput {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 2px solid rgba(255,255,255,0.6);
      border-radius: 8px;
      font-size: 16px;
      font-family: inherit;
      background: rgba(255,255,255,0.9);
      color: #333;
      resize: vertical;
      margin-bottom: 16px;
      direction: rtl;
    }
    #globalMessageInput:focus {
      outline: none;
      border-color: rgba(255,255,255,1);
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    #globalMessageButtons {
      text-align: center;
    }
    #sendGlobalMessage {
      background: linear-gradient(135deg, #ffffff, #f0f8ff);
      color: #333;
      border: 2px solid rgba(255,255,255,0.8);
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(255,255,255,0.3);
    }
    #sendGlobalMessage:hover {
      background: linear-gradient(135deg, #f0f8ff, #e6f3ff);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(255,255,255,0.4);
    }
    
    /* Global Message Display Banner */
    #globalMessageDisplay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2000;
      display: none;
    }
    #globalMessageDisplay.show { display: block; }
    #globalMessageBanner {
      background: linear-gradient(135deg, #ffffff, #f0f8ff);
      border: 3px solid rgba(255,255,255,0.8);
      border-radius: 12px;
      padding: 16px 24px;
      max-width: 80vw;
      min-width: 400px;
      box-shadow: 0 8px 32px rgba(255,255,255,0.4), 0 0 20px rgba(255,255,255,0.3);
      display: flex;
      align-items: center;
      gap: 16px;
      animation: bannerSlideIn 0.5s ease-out;
    }
    #globalMessageText {
      flex: 1;
      font-size: 18px;
      font-weight: bold;
      color: #333;
      text-align: center;
      direction: rtl;
      position: relative;
    }
    #globalMessageText::before {
      content: "";
      font-size: 16px;
      color: #666;
      display: block;
      margin-bottom: 4px;
    }
    #dismissGlobalMessage {
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
    }
    #dismissGlobalMessage:hover {
      background: linear-gradient(135deg, #45a049, #3d8b40);
      transform: translateY(-1px);
    }
    
    @keyframes bannerSlideIn {
      from {
        transform: translateX(-50%) translateY(-100px);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }
    
    @keyframes bannerSlideOut {
      from {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
      to {
        transform: translateX(-50%) translateY(-100px);
        opacity: 0;
      }
    }
    
    #globalMessageDisplay.hide {
      animation: bannerSlideOut 0.3s ease-in;
    }
    
    /* Quick Mission Modal */
    #quickMissionModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #quickMissionModal.open { display: flex; }
    #quickMissionContent {
      background: linear-gradient(135deg, #2a2e45, #1f2238);
      border-radius: 16px;
      padding: 24px;
      max-width: 600px;
      width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      border: 2px solid rgba(255,255,255,0.1);
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
    }
    #quickMissionHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 12px;
      border-bottom: 2px solid rgba(255,255,255,0.1);
    }
    #quickMissionTitle {
      font-size: 24px;
      font-weight: bold;
      color: #ff6b35;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #closeQuickMission {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: bold;
    }
    #quickMissionInfo {
      text-align: center;
      margin-bottom: 20px;
      color: #ddd;
    }
    .active-mission {
      background: rgba(0, 210, 211, 0.1);
      border: 2px solid rgba(0, 210, 211, 0.3);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }
    .active-mission h3 {
      color: #00d2d3;
      margin-bottom: 10px;
    }
    #activeMissionText {
      font-size: 16px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 8px;
    }
    #activeMissionTarget {
      font-size: 14px;
      color: #bbb;
      margin-bottom: 12px;
    }
    #cancelQuickMission {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    #cancelQuickMission:hover {
      background: linear-gradient(135deg, #c0392b, #a93226);
    }
    .mission-option {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 16px;
      margin: 12px 0;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .mission-option:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(255, 107, 53, 0.5);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(255, 107, 53, 0.2);
    }
    .mission-option.selected {
      background: rgba(255, 107, 53, 0.2);
      border-color: rgba(255, 107, 53, 0.6);
    }
    .mission-icon {
      font-size: 32px;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.1);
      border-radius: 50%;
    }
    .mission-info {
      flex: 1;
    }
    .mission-name {
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      margin-bottom: 4px;
    }
    .mission-desc {
      font-size: 14px;
      color: #bbb;
      margin-bottom: 8px;
    }
    .mission-reward {
      font-size: 14px;
      color: #ffd700;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="ui">
    <div id="levelDisplay">
      <span>⭐</span>
      <span>רמה <span id="levelCount">1</span></span>
    </div>
    
    <div id="xpDisplay">
      <div>XP: <span id="currentXP">0</span> / <span id="requiredXP">100</span></div>
      <div class="xp-bar">
        <div id="xpProgress" class="xp-progress" style="width: 0%"></div>
      </div>
    </div>
    
    <button id="quickMissionBtn" title="קבל משימה מהירה">⚡ משימה</button>
    
    <div id="coinsDisplay">
      <span>🪙</span>
      <span id="coinCount">100</span>
    </div>
    
    <div id="onlineDisplay">
      <span>🌍</span>
      <span id="onlineCount">1</span>
      <span>שחקנים</span>
    </div>
    
    <div id="connectionStatus">
      <span>🟢</span>
      <span id="statusText">מתחבר...</span>
    </div>
    
    <button id="adminBtn" aria-pressed="false" title="מצב אדמין">אדמין</button>
    <button id="explorerBtn" aria-pressed="false" title="מצב סייר">סייר</button>
    <button id="explorerMessageBtn" title="שלח הודעה גלובלית" style="display: none;">📢 הודעה</button>
    <button id="shopBtn" title="חנות">🛍 חנות</button>
    <button id="audioBtn" title="מוזיקה וצלילים">🎵</button>
    
    <!-- Minimap -->
    <div id="minimap">
      <div id="minimap-title">
        <span>🗺️ מיני מפה</span>
        <div class="minimap-controls">
          <button class="minimap-btn" id="legend-btn" title="מקרא המפה">📋</button>
          <button class="minimap-btn" id="expand-btn" title="הרחב מפה">⤢</button>
        </div>
      </div>
      <canvas id="minimap-canvas" width="164" height="140"></canvas>
      <div id="minimap-zoom-controls">
        <div id="zoom-indicator">100%</div>
        <div class="zoom-buttons">
          <button class="zoom-btn" id="zoom-in-btn" title="זום פנימה">+</button>
          <button class="zoom-btn" id="zoom-out-btn" title="זום החוצה">-</button>
          <button class="zoom-btn" id="zoom-reset-btn" title="איפוס זום">⌂</button>
        </div>
      </div>
      <div id="minimap-tooltip"></div>
    </div>
    <div id="minimap-overlay"></div>
    
    <!-- Map Legend Modal -->
    <div id="legendModal">
      <div id="legendContent">
        <div id="legendHeader">
          <div id="legendTitle">
            <span>🗺️</span>
            <span>מקרא המפה</span>
          </div>
          <button id="closeLegend">סגירה</button>
        </div>
        
        <div class="legend-grid">
          <div class="legend-item">
            <span class="legend-icon legend-player"></span>
            <span>השחקן שלך</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-npc"></span>
            <span>תושבים</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-shop"></span>
            <span>חנויות</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-gift"></span>
            <span>מתנות ופריטים</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-coin"></span>
            <span>מטבעות</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-house"></span>
            <span>בתים</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-home"></span>
            <span>הבית שלך</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-road"></span>
            <span>כבישים</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-trees"></span>
            <span>עצים</span>
          </div>
          
          <div class="legend-item">
            <span class="legend-icon legend-view"></span>
            <span>אזור הצפיה הנוכחי</span>
          </div>
        </div>
      </div>
    </div>

    <div id="help">
      <div><b>הוראות:</b></div>
      <div>לחיצה על המפה — תנועה למקום שלוחצים עליו</div>
      <div>W/A/S/D — תנועה קדימה/אחורה/ימין/שמאל</div>
      <div>חיצים שמאל/ימין — סיבוב השחקן</div>
      <div>T — פתיחת שדה הצ'אט במהירות</div>
      <div>Enter — שליחת הודעה</div>
      <div>E — לדבר עם חנות/תושב, החלפות פריטים</div>
      <div>🏠 — לחיצה על בתים לכניסה, כפתור בית לחזרה</div>
      <div>🎒 — כפתור תיק חפצים לניהול הציוד</div>
      <div>😊 — כפתור אימוג'ים לביטוי רגשות</div>
      <div>+/- — זום הגדלה/הקטנה, גלגל העכבר, 0 לאיפוס</div>
      <div>F5 — שמירת המשחק, F9 — טעינת המשחק</div>
      <div>כפתור "אדמין" — הילה זהב + בועת צ'אט זהב בעת הכתיבה</div>
    </div>

    <div id="questPanel"></div>

    <div id="chatBar">
      <input type="text" id="chatInput" maxlength="140" placeholder="כתוב הודעה... (T לפתיחה)" />
      <button id="inventoryBtn" title="תיק חפצים">🎒</button>
      <button id="emojiBtn" title="אימוג'ים">😊</button>
      <button id="danceBtn" title="ריקודים">💃</button>
      <button id="memoryBtn" title="משחק זיכרון">🧠</button>
      <button id="homeBtn" title="חזור הביתה">🏠</button>
      <button id="sendBtn">שלח</button>
      
      <!-- Emoji Panel -->
      <div id="emojiPanel">
        <button class="emoji-btn" data-emoji="😊" title="שמח">😊</button>
        <button class="emoji-btn" data-emoji="😂" title="צוחק">😂</button>
        <button class="emoji-btn" data-emoji="😍" title="מאוהב">😍</button>
        <button class="emoji-btn" data-emoji="😎" title="קול">😎</button>
        <button class="emoji-btn" data-emoji="🤩" title="כוכבים בעינים">🤩</button>
        <button class="emoji-btn" data-emoji="😡" title="כועס">😡</button>
        <button class="emoji-btn" data-emoji="😤" title="מעוצבן">😤</button>
        <button class="emoji-btn" data-emoji="😢" title="בוכה">😢</button>
        <button class="emoji-btn" data-emoji="😭" title="בוכה חזק">😭</button>
        <button class="emoji-btn" data-emoji="😱" title="פחד">😱</button>
        <button class="emoji-btn" data-emoji="😏" title="חיוך מערמה">😏</button>
        <button class="emoji-btn" data-emoji="😴" title="עייף">😴</button>
        <button class="emoji-btn" data-emoji="🤔" title="חושב">🤔</button>
        <button class="emoji-btn" data-emoji="😋" title="טעים">😋</button>
        <button class="emoji-btn" data-emoji="😉" title="קורץ">😉</button>
        <button class="emoji-btn" data-emoji="🥰" title="מאוהב לבבות">🥰</button>
        <button class="emoji-btn" data-emoji="🥳" title="חוגג">🥳</button>
        <button class="emoji-btn" data-emoji="🙏" title="מתחנן">🙏</button>
        <button class="emoji-btn" data-emoji="👍" title="אישור">👍</button>
        <button class="emoji-btn" data-emoji="👎" title="לא אישור">👎</button>
      </div>
      
      <!-- Dance Panel -->
      <div id="dancePanel">
        <button class="dance-btn" data-dance="party" title="מסיבה">🕺</button>
        <button class="dance-btn" data-dance="disco" title="דיסקו">💃</button>
        <button class="dance-btn" data-dance="breakdance" title="בריקדאנס">🤸</button>
        <button class="dance-btn" data-dance="salsa" title="סלסה">💃🏻</button>
        <button class="dance-btn" data-dance="robot" title="רובוט">🤖</button>
        <button class="dance-btn" data-dance="hip-hop" title="היפ הופ">🕺🏻</button>
        <button class="dance-btn" data-dance="ballet" title="בלט">🩰</button>
        <button class="dance-btn" data-dance="tango" title="טנגו">👥</button>
        <button class="dance-btn" data-dance="moonwalk" title="מונווק">🌙</button>
        <button class="dance-btn" data-dance="floss" title="פלוס">💫</button>
        <button class="dance-btn" data-dance="wave" title="גל">🌊</button>
        <button class="dance-btn" data-dance="electric" title="חשמלי">⚡</button>
        <button class="dance-btn" data-dance="stop" title="הפסק ריקוד">⏹️</button>
      </div>
    </div>
  </div>

  <!-- Shop Modal -->
  <div id="shopModal">
    <div id="shopContent">
      <div id="shopHeader">
        <div id="shopTitle">🛒 חנות</div>
        <button id="closeShop">סגירה</button>
      </div>
      <div id="shopItems"></div>
    </div>
  </div>

  <!-- Inventory Modal -->
  <div id="invModal">
    <div id="invContent">
      <div id="invHeader">
        <div id="invTitle">🎒 תיק חפצים</div>
        <button id="closeInv">סגירה</button>
      </div>
      <div class="inv-grid" id="invGrid"></div>
    </div>
  </div>

  <div class="pickups" id="pickupLayer"></div>
  
  <!-- Trade Modal -->
  <div id="tradeModal">
    <div id="tradeContent">
      <div id="tradeHeader">
        <div id="tradeTitle">🔄 החלפות</div>
        <button id="closeTrade">סגירה</button>
      </div>
      <div id="tradeOffers"></div>
    </div>
  </div>

  <!-- Memory Game Modal -->
  <div id="memoryModal">
    <div id="memoryContent">
      <div id="memoryHeader">
        <div id="memoryTitle">🧠 משחק זיכרון</div>
        <button id="closeMemory">סגירה</button>
      </div>
      <div id="memoryInfo">
        <div id="memoryInstructions">שמרו את סדר התושבים ולחצו עליהם באותו סדר!</div>
        <div id="memoryScore">שלב: 1</div>
      </div>
      <div id="memoryGrid"></div>
      <div id="memoryButtons">
        <button id="startMemoryGame">התחל משחק</button>
      </div>
    </div>
  </div>

  <!-- Profile Modal -->
  <div id="profileModal">
    <div id="profileContent">
      <div id="profileHeader">
        <div id="profileTitle">
          <span>👤</span>
          <span>פרופיל שחקן</span>
        </div>
        <button id="closeProfile">סגירה</button>
      </div>
      
      <div class="profile-main">
        <div class="profile-avatar">
          <div id="avatarDisplay" class="avatar-display">
            <canvas id="playerCanvas" width="200" height="280"></canvas>
          </div>
          <div id="playerNameDisplay" class="player-name">ליאור1</div>
          <div id="playerStatusDisplay" class="player-status">שחקן רגיל</div>
        </div>
        
        <div class="profile-stats">
          <div class="stats-grid">
            <div class="stat-item">
              <span id="statLevel" class="stat-value">1</span>
              <span class="stat-label">⭐ רמה</span>
            </div>
            <div class="stat-item">
              <span id="statXP" class="stat-value">0%</span>
              <span class="stat-label">🏆 XP</span>
            </div>
            <div class="stat-item">
              <span id="statCoins" class="stat-value">100</span>
              <span class="stat-label">🪙 מטבעות</span>
            </div>
            <div class="stat-item">
              <span id="statItems" class="stat-value">0</span>
              <span class="stat-label">🎒 פריטים</span>
            </div>
            <div class="stat-item">
              <span id="statVehicle" class="stat-value">אין</span>
              <span class="stat-label">🚗 רכב</span>
            </div>
            <div class="stat-item">
              <span id="statAdmin" class="stat-value">לא</span>
              <span class="stat-label">🔥 אדמין</span>
            </div>
          </div>
        </div>
      </div>
      
      <div class="profile-equipment">
        <div class="equipment-title">
          <span>🎨</span>
          <span>ציוד לבוש</span>
        </div>
        <div class="equipment-grid">
          <div id="equipHat" class="equipment-slot">
            <div class="equipment-slot-icon">👑</div>
            <div class="equipment-slot-name">כובע</div>
            <div class="equipment-slot-empty">ריק</div>
          </div>
          <div id="equipFace" class="equipment-slot">
            <div class="equipment-slot-icon">👓</div>
            <div class="equipment-slot-name">פנים</div>
            <div class="equipment-slot-empty">ריק</div>
          </div>
          <div id="equipChest" class="equipment-slot">
            <div class="equipment-slot-icon">👕</div>
            <div class="equipment-slot-name">חזה</div>
            <div class="equipment-slot-empty">ריק</div>
          </div>
          <div id="equipBack" class="equipment-slot">
            <div class="equipment-slot-icon">🦸‍♂️</div>
            <div class="equipment-slot-name">גב</div>
            <div class="equipment-slot-empty">ריק</div>
          </div>
          <div id="equipFeet" class="equipment-slot">
            <div class="equipment-slot-icon">👟</div>
            <div class="equipment-slot-name">רגליים</div>
            <div class="equipment-slot-empty">ריק</div>
          </div>
          <div id="equipEffect" class="equipment-slot">
            <div class="equipment-slot-icon">✨</div>
            <div class="equipment-slot-name">אפקט</div>
            <div class="equipment-slot-empty">ריק</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Equipment Selection Modal -->
  <div id="equipmentModal">
    <div id="equipmentContent">
      <div id="equipmentHeader">
        <div id="equipmentTitle">
          <span id="equipmentSlotIcon">👑</span>
          <span id="equipmentSlotName">כובע</span>
        </div>
        <button id="closeEquipment">סגירה</button>
      </div>
      <div id="equipmentOptions" class="equipment-options"></div>
    </div>
  </div>

  <!-- Global Message Modal (Explorer Feature) -->
  <div id="globalMessageModal">
    <div id="globalMessageContent">
      <div id="globalMessageHeader">
        <div id="globalMessageTitle">
          <span>🗺️</span>
          <span>הודעת סייר גלובלית</span>
        </div>
        <button id="closeGlobalMessage">סגירה</button>
      </div>
      <div id="globalMessageBody">
        <p>כסייר, אתה יכול לשלוח הודעה שתוצג לכל השחקנים במשחק:</p>
        <textarea id="globalMessageInput" placeholder="הקלד את ההודעה שלך..."></textarea>
        <div id="globalMessageButtons">
          <button id="sendGlobalMessage">שלח הודעה לכל השחקנים</button>
          <button id="testGlobalMessage" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 6px; margin-left: 10px; cursor: pointer;">בדיקה</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Global Message Display -->
  <div id="globalMessageDisplay">
    <div id="globalMessageBanner">
      <div id="globalMessageText"></div>
      <button id="dismissGlobalMessage">אישור</button>
    </div>
  </div>

  <!-- Quick Mission Modal -->
  <div id="quickMissionModal">
    <div id="quickMissionContent">
      <div id="quickMissionHeader">
        <div id="quickMissionTitle">
          <span>⚡</span>
          <span>משימות מהירות</span>
        </div>
        <button id="closeQuickMission">סגירה</button>
      </div>
      
      <div id="quickMissionBody">
        <div id="quickMissionInfo">
          <p>בחר משימה מהירה ולך לתושב כדי להשלים אותה!</p>
        </div>
        
        <div id="currentQuickMission" style="display: none;">
          <div class="active-mission">
            <h3>משימה פעילה:</h3>
            <div id="activeMissionText"></div>
            <div id="activeMissionTarget"></div>
            <button id="cancelQuickMission">בטל משימה</button>
          </div>
        </div>
        
        <div id="quickMissionList">
          <div class="mission-option" data-mission="visit">
            <div class="mission-icon">👥</div>
            <div class="mission-info">
              <div class="mission-name">בקר אצל תושב</div>
              <div class="mission-desc">לך לבקר אצל תושב שמחכה ליך</div>
              <div class="mission-reward">פרס: 50 מטבעות + 25 XP</div>
            </div>
          </div>
          
          <div class="mission-option" data-mission="delivery">
            <div class="mission-icon">📦</div>
            <div class="mission-info">
              <div class="mission-name">משלוח מהיר</div>
              <div class="mission-desc">העבר משלוח לתושב</div>
              <div class="mission-reward">פרס: 75 מטבעות + 35 XP</div>
            </div>
          </div>
          
          <div class="mission-option" data-mission="help">
            <div class="mission-icon">🤝</div>
            <div class="mission-info">
              <div class="mission-name">עזרה בבית</div>
              <div class="mission-desc">עזור לתושב במשים בבית</div>
              <div class="mission-reward">פרס: 100 מטבעות + 50 XP</div>
            </div>
          </div>
          
          <div class="mission-option" data-mission="chat">
            <div class="mission-icon">💬</div>
            <div class="mission-info">
              <div class="mission-name">שיחה ידידותית</div>
              <div class="mission-desc">שוחח עם תושב שמרגיש בודד</div>
              <div class="mission-reward">פרס: 40 מטבעות + 20 XP</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
      (() => {
        'use strict';
        const DPR = Math.min(window.devicePixelRatio || 1, 2);
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        // Zoom system (temporarily disabled for bug fix)
        let zoomLevel = 1.0;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_STEP = 0.1;

      function resize() {
        canvas.width = innerWidth * DPR;
        canvas.height = innerHeight * DPR;
        canvas.style.width = innerWidth + 'px';
        canvas.style.height = innerHeight + 'px';
        // Reset transform to prevent double scaling issues
        ctx.resetTransform();
        ctx.scale(DPR, DPR);
      }
      
      function updateZoom() {
        // Zoom is now handled by scaling the camera view, not the canvas transform
      }
      window.addEventListener('resize', resize);
      resize();
      
      // Auto-load game on start
      loadGame();
      
      // Audio System
      class AudioManager {
        constructor() {
          this.audioContext = null;
          this.sounds = {};
          this.backgroundMusic = null;
          this.volume = 0.5;
          this.musicVolume = 0.3;
          this.initialized = false;
        }
        
        async init() {
          try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.initialized = true;
            console.log('Audio system initialized');
          } catch (error) {
            console.log('Audio not supported:', error);
          }
        }
        
        createBeep(frequency, duration, type = 'sine') {
          if (!this.initialized) return;
          
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          oscillator.frequency.value = frequency;
          oscillator.type = type;
          gainNode.gain.setValueAtTime(this.volume * 0.1, this.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
          
          oscillator.start(this.audioContext.currentTime);
          oscillator.stop(this.audioContext.currentTime + duration);
        }
        
        playCoinSound() {
          this.createBeep(800, 0.1, 'square');
          setTimeout(() => this.createBeep(1200, 0.1, 'square'), 50);
        }
        
        playPickupSound() {
          this.createBeep(600, 0.15, 'triangle');
          setTimeout(() => this.createBeep(900, 0.15, 'triangle'), 75);
          setTimeout(() => this.createBeep(1200, 0.2, 'triangle'), 150);
        }
        
        playWalkSound(surface = 'grass') {
          let freq, duration;
          switch(surface) {
            case 'grass':
              freq = 200 + Math.random() * 100;
              duration = 0.05;
              break;
            case 'road':
              freq = 300 + Math.random() * 150;
              duration = 0.08;
              break;
            case 'sand':
              freq = 150 + Math.random() * 75;
              duration = 0.06;
              break;
            default:
              freq = 250 + Math.random() * 100;
              duration = 0.06;
          }
          this.createBeep(freq, duration, 'sawtooth');
        }
        
        startBackgroundMusic() {
          if (!this.initialized) return;
          
          // Create ambient background music using oscillators
          this.createAmbientMusic();
        }
        
        createAmbientMusic() {
          // Create a simple ambient background using multiple oscillators
          const playAmbientNote = (frequency, delay = 0) => {
            setTimeout(() => {
              if (!this.initialized) return;
              
              const oscillator = this.audioContext.createOscillator();
              const gainNode = this.audioContext.createGain();
              
              oscillator.connect(gainNode);
              gainNode.connect(this.audioContext.destination);
              
              oscillator.frequency.value = frequency;
              oscillator.type = 'sine';
              gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
              gainNode.gain.linearRampToValueAtTime(this.musicVolume * 0.1, this.audioContext.currentTime + 0.5);
              gainNode.gain.setValueAtTime(this.musicVolume * 0.1, this.audioContext.currentTime + 3);
              gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 4);
              
              oscillator.start(this.audioContext.currentTime);
              oscillator.stop(this.audioContext.currentTime + 4);
            }, delay);
          };
          
          // Play ambient chord progression
          const playChord = () => {
            if (!this.initialized) return;
            
            const chords = [
              [261.63, 329.63, 392.00], // C major
              [293.66, 369.99, 440.00], // D minor
              [329.63, 415.30, 493.88], // E minor
              [261.63, 329.63, 392.00], // C major
            ];
            
            const chord = chords[Math.floor(Math.random() * chords.length)];
            chord.forEach((freq, i) => {
              playAmbientNote(freq, i * 100);
            });
            
            setTimeout(playChord, 6000 + Math.random() * 4000);
          };
          
          playChord();
        }
      }
      
      const audioManager = new AudioManager();
      
      // Quick Mission System - Global variables
      let currentQuickMission = null;
      let quickMissionNPC = null;
      
      // Vehicle travel distance tracking
      let lastVehiclePosition = { x: 0, y: 0 };
      let totalVehicleDistance = 0;
      
      // Simple Weather System
      let currentWeather = 'sunny'; // sunny, rainy, snowy, cloudy
      let weatherTimer = 0;
      const WEATHER_CHANGE_TIME = 30; // change weather every 30 seconds
      
      const weatherTypes = ['sunny', 'cloudy', 'rainy', 'snowy'];
      
      function updateWeather(dt) {
        weatherTimer += dt;
        
        if (weatherTimer >= WEATHER_CHANGE_TIME) {
          // Change to random weather
          const newWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
          if (newWeather !== currentWeather) {
            currentWeather = newWeather;
            showWeatherChange();
          }
          weatherTimer = 0;
        }
      }
      
      function showWeatherChange() {
        const weatherNames = {
          sunny: '☀️ שמש',
          cloudy: '☁️ מעונן',
          rainy: '🌧️ גשום',
          snowy: '❄️ שלג'
        };
        showPickupText(`מזג אוויר: ${weatherNames[currentWeather]}`, innerWidth/2, 120);
      }
      
      function drawSimpleWeather(camX, camY) {
        if (currentWeather === 'rainy') {
          // Simple rain effect
          ctx.strokeStyle = 'rgba(173, 216, 230, 0.6)';
          ctx.lineWidth = 1;
          const time = performance.now() * 0.01;
          
          for (let i = 0; i < 50; i++) {
            const x = (i * 80 + time * 3) % (innerWidth + 100) - 50;
            const y = (i * 13 + time * 5) % (innerHeight + 100) - 50;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - 2, y + 15);
            ctx.stroke();
          }
        } else if (currentWeather === 'snowy') {
          // Simple snow effect
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          const time = performance.now() * 0.002;
          
          for (let i = 0; i < 40; i++) {
            const x = (i * 100 + time * 20) % (innerWidth + 50);
            const y = (i * 17 + time * 30) % (innerHeight + 50);
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (currentWeather === 'cloudy') {
          // Simple clouds
          ctx.globalAlpha = 0.3;
          ctx.fillStyle = '#cccccc';
          const time = performance.now() * 0.0005;
          
          for (let i = 0; i < 3; i++) {
            const x = (i * 200 + time * 10) % (innerWidth + 100);
            const y = 50 + i * 30;
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, Math.PI * 2);
            ctx.arc(x - 15, y + 5, 20, 0, Math.PI * 2);
            ctx.arc(x + 15, y + 5, 20, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
      }
      
      // Gender identification system for NPCs
      class WeatherManager {
        constructor() {
          this.currentSeason = 'summer'; // summer, winter, spring, autumn
          this.currentWeather = 'sunny'; // sunny, cloudy, rainy, snowy, stormy
          this.weatherTimer = 0;
          this.seasonTimer = 0;
          this.weatherDuration = 60; // seconds per weather cycle
          this.seasonDuration = 240; // seconds per season cycle
          
          this.raindrops = [];
          this.snowflakes = [];
          this.clouds = [];
          this.sunRays = [];
          
          this.initWeatherEffects();
        }
        
        initWeatherEffects() {
          // Initialize weather particles
          for (let i = 0; i < 200; i++) {
            this.raindrops.push(this.createRaindrop());
            this.snowflakes.push(this.createSnowflake());
          }
          
          for (let i = 0; i < 5; i++) {
            this.clouds.push(this.createCloud());
          }
          
          for (let i = 0; i < 12; i++) {
            this.sunRays.push(this.createSunRay(i));
          }
        }
        
        createRaindrop() {
          return {
            x: Math.random() * world.width,
            y: -Math.random() * 100,
            speed: 300 + Math.random() * 200,
            length: 10 + Math.random() * 15
          };
        }
        
        createSnowflake() {
          return {
            x: Math.random() * world.width,
            y: -Math.random() * 100,
            speed: 50 + Math.random() * 50,
            size: 2 + Math.random() * 4,
            drift: (Math.random() - 0.5) * 2
          };
        }
        
        createCloud() {
          return {
            x: Math.random() * world.width,
            y: 100 + Math.random() * 200,
            size: 80 + Math.random() * 120,
            speed: 10 + Math.random() * 20,
            opacity: 0.3 + Math.random() * 0.4
          };
        }
        
        createSunRay(index) {
          return {
            angle: (index / 12) * Math.PI * 2,
            length: 100 + Math.random() * 50,
            opacity: 0.3 + Math.random() * 0.3
          };
        }
        
        update(dt) {
          this.weatherTimer += dt;
          this.seasonTimer += dt;
          
          // Change weather every weatherDuration seconds
          if (this.weatherTimer >= this.weatherDuration) {
            this.changeWeather();
            this.weatherTimer = 0;
          }
          
          // Change season every seasonDuration seconds
          if (this.seasonTimer >= this.seasonDuration) {
            this.changeSeason();
            this.seasonTimer = 0;
          }
          
          this.updateWeatherEffects(dt);
        }
        
        changeWeather() {
          const seasonWeathers = {
            summer: ['sunny', 'cloudy', 'stormy'],
            winter: ['snowy', 'cloudy', 'sunny'],
            spring: ['rainy', 'sunny', 'cloudy'],
            autumn: ['rainy', 'cloudy', 'sunny']
          };
          
          const possibleWeathers = seasonWeathers[this.currentSeason];
          const newWeather = possibleWeathers[Math.floor(Math.random() * possibleWeathers.length)];
          
          if (newWeather !== this.currentWeather) {
            this.currentWeather = newWeather;
            this.showWeatherNotification();
          }
        }
        
        changeSeason() {
          const seasons = ['spring', 'summer', 'autumn', 'winter'];
          const currentIndex = seasons.indexOf(this.currentSeason);
          this.currentSeason = seasons[(currentIndex + 1) % seasons.length];
          this.showSeasonNotification();
          this.changeWeather(); // Change weather with season
        }
        
        showWeatherNotification() {
          const weatherNames = {
            sunny: '☀️ שמש',
            cloudy: '☁️ מעונן',
            rainy: '🌧️ גשום',
            snowy: '🌨️ שלג',
            stormy: '⛈️ סערה'
          };
          showPickupText(`מזג אוויר: ${weatherNames[this.currentWeather]}`, innerWidth/2, 150);
        }
        
        showSeasonNotification() {
          const seasonNames = {
            spring: '🌸 אביב',
            summer: '🌞 קיץ', 
            autumn: '🍂 סתיו',
            winter: '❄️ חורף'
          };
          showPickupText(`עונה חדשה: ${seasonNames[this.currentSeason]}`, innerWidth/2, 100);
        }
        
        updateWeatherEffects(dt) {
          // Update raindrops
          if (this.currentWeather === 'rainy' || this.currentWeather === 'stormy') {
            for (const drop of this.raindrops) {
              drop.y += drop.speed * dt;
              if (drop.y > world.height + 50) {
                drop.y = -50;
                drop.x = Math.random() * world.width;
              }
            }
          }
          
          // Update snowflakes
          if (this.currentWeather === 'snowy') {
            for (const flake of this.snowflakes) {
              flake.y += flake.speed * dt;
              flake.x += flake.drift * dt * 10;
              
              if (flake.y > world.height + 50) {
                flake.y = -50;
                flake.x = Math.random() * world.width;
              }
              
              if (flake.x < -50) flake.x = world.width + 50;
              if (flake.x > world.width + 50) flake.x = -50;
            }
          }
          
          // Update clouds
          for (const cloud of this.clouds) {
            cloud.x += cloud.speed * dt;
            if (cloud.x > world.width + cloud.size) {
              cloud.x = -cloud.size;
            }
          }
        }
        
        draw(ctx, camX, camY) {
          ctx.save();
          
          // Draw weather particles only (no background effects)
          if (this.currentWeather === 'rainy' || this.currentWeather === 'stormy') {
            this.drawRain(ctx, camX, camY);
          }
          
          if (this.currentWeather === 'snowy') {
            this.drawSnow(ctx, camX, camY);
          }
          
          if (this.currentWeather === 'sunny') {
            this.drawSun(ctx, camX, camY);
          }
          
          if (this.currentWeather === 'cloudy' || this.currentWeather === 'stormy') {
            this.drawClouds(ctx, camX, camY);
          }
          
          ctx.restore();
        }
        
        
        drawRain(ctx, camX, camY) {
          ctx.strokeStyle = 'rgba(173, 216, 230, 0.8)';
          ctx.lineWidth = 2;
          
          for (const drop of this.raindrops) {
            const screenX = drop.x - camX;
            const screenY = drop.y - camY;
            
            if (screenX > -50 && screenX < innerWidth + 50 && screenY > -50 && screenY < innerHeight + 50) {
              ctx.beginPath();
              ctx.moveTo(screenX, screenY);
              ctx.lineTo(screenX - 2, screenY + drop.length);
              ctx.stroke();
            }
          }
        }
        
        drawSnow(ctx, camX, camY) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          
          for (const flake of this.snowflakes) {
            const screenX = flake.x - camX;
            const screenY = flake.y - camY;
            
            if (screenX > -50 && screenX < innerWidth + 50 && screenY > -50 && screenY < innerHeight + 50) {
              ctx.beginPath();
              ctx.arc(screenX, screenY, flake.size, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
        
        drawSun(ctx, camX, camY) {
          const sunX = 150 - camX;
          const sunY = 150 - camY;
          
          if (sunX > -100 && sunX < innerWidth + 100 && sunY > -100 && sunY < innerHeight + 100) {
            // Sun rays
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.lineWidth = 3;
            
            for (const ray of this.sunRays) {
              const rayEndX = sunX + Math.cos(ray.angle) * ray.length;
              const rayEndY = sunY + Math.sin(ray.angle) * ray.length;
              
              ctx.globalAlpha = ray.opacity;
              ctx.beginPath();
              ctx.moveTo(sunX, sunY);
              ctx.lineTo(rayEndX, rayEndY);
              ctx.stroke();
            }
            
            // Sun body
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(sunX, sunY, 30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1.0;
          }
        }
        
        drawClouds(ctx, camX, camY) {
          for (const cloud of this.clouds) {
            const screenX = cloud.x - camX;
            const screenY = cloud.y - camY;
            
            if (screenX > -cloud.size && screenX < innerWidth + cloud.size) {
              ctx.globalAlpha = cloud.opacity;
              ctx.fillStyle = this.currentWeather === 'stormy' ? '#555555' : '#FFFFFF';
              
              // Draw cloud as multiple circles
              ctx.beginPath();
              ctx.arc(screenX, screenY, cloud.size * 0.6, 0, Math.PI * 2);
              ctx.arc(screenX - cloud.size * 0.3, screenY + cloud.size * 0.1, cloud.size * 0.4, 0, Math.PI * 2);
              ctx.arc(screenX + cloud.size * 0.3, screenY + cloud.size * 0.1, cloud.size * 0.4, 0, Math.PI * 2);
              ctx.arc(screenX - cloud.size * 0.1, screenY - cloud.size * 0.2, cloud.size * 0.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          ctx.globalAlpha = 1.0;
        }
        
        getCurrentWeatherIcon() {
          const icons = {
            sunny: '☀️',
            cloudy: '☁️', 
            rainy: '🌧️',
            snowy: '🌨️',
            stormy: '⛈️'
          };
          return icons[this.currentWeather] || '🌤️';
        }
        
        getCurrentSeasonIcon() {
          const icons = {
            spring: '🌸',
            summer: '🌞',
            autumn: '🍂',
            winter: '❄️'
          };
          return icons[this.currentSeason] || '🌤️';
        }
      }
      
      
      // Gender identification system for NPCs
      function getNPCGender(npcId) {
        // Central definition of characters' genders
        const femaleCharacters = ['shop_mary', 'resident_noa', 'resident_sandra'];
        const maleCharacters = ['resident_dani', 'resident_alex', 'resident_ben'];
        
        if (femaleCharacters.includes(npcId)) {
          return 'female';
        } else if (maleCharacters.includes(npcId)) {
          return 'male';
        } else {
          return 'unknown';
        }
      }
      
      // Speech System for NPCs
      class SpeechManager {
        constructor() {
          this.speechSynthesis = window.speechSynthesis;
          this.voices = [];
          this.enabled = false;
          this.volume = 0.7;
          this.rate = 1.0;
          this.pitch = 1.0;
          
          // Load voices when available
          this.loadVoices();
          if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => this.loadVoices();
          }
        }
        
        loadVoices() {
          this.voices = this.speechSynthesis.getVoices();
          console.log('Loaded voices:', this.voices.length);
        }
        
        enable() {
          if (!this.supported) {
            showPickupText('⚠️ דיבור לא נתמך בדפדפן זה', innerWidth/2, innerHeight/2);
            console.error('Speech synthesis not supported');
            return;
          }
          
          this.enabled = true;
          this.logAvailableVoices(); // Show available voices for debugging
          showPickupText('🗣️ דיבור התושבים פעיל!', innerWidth/2, innerWidth/2);
        }
        
        logAvailableVoices() {
          console.log('=== Available Voices ===');
          this.voices.forEach((voice, index) => {
            console.log(`${index}: ${voice.name} (${voice.lang}) - ${voice.gender || 'unknown gender'}`);
          });
          console.log('========================');
        }
        
        disable() {
          this.enabled = false;
          this.speechSynthesis.cancel(); // Stop any ongoing speech
          showPickupText('🔇 דיבור התושבים כבוי', innerWidth/2, innerHeight/2);
        }
        
        toggle() {
          if (this.enabled) {
            this.disable();
          } else {
            this.enable();
          }
        }
        
        speak(text, npcId = null) {
          if (!this.enabled || !text) {
            console.log('Speech disabled or no text:', { enabled: this.enabled, text });
            return;
          }
          
          console.log(`Speaking: "${text}" for NPC: ${npcId}`);
          
          // Stop any current speech
          this.speechSynthesis.cancel();
          
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.volume = 0.8; // Fixed volume
          utterance.rate = 1.0;   // Fixed rate
          utterance.pitch = 1.0;  // Default pitch
          
          // Choose voice based on NPC
          if (this.voices.length > 0) {
            const voiceIndex = this.getVoiceForNPC(npcId);
            if (this.voices[voiceIndex]) {
              utterance.voice = this.voices[voiceIndex];
              console.log(`Using voice: ${this.voices[voiceIndex].name}`);
            }
          } else {
            console.log('No voices available, using default');
          }
          
          // Set different characteristics per NPC with clear gender differences
          const gender = getNPCGender(npcId);
          
          if (gender === 'female') {
            // Female voices - high pitch, softer
            utterance.pitch = 1.8; // Higher pitch for clearer female voice
            utterance.rate = 0.85;  // Slightly slower for clarity
            console.log(`🚺 Setting FEMALE voice for ${npcId}: pitch 1.8, rate 0.85`);
          } else if (gender === 'male') {
            // Male voices - low pitch, stronger
            utterance.pitch = 0.5; // Lower pitch for clearer male voice
            utterance.rate = 1.1;  // Slightly faster for masculinity
            console.log(`🚹 Setting MALE voice for ${npcId}: pitch 0.5, rate 1.1`);
          } else {
            // Default/unknown character
            utterance.pitch = 1.0;
            utterance.rate = 1.0;
            console.log(`⚪ Setting DEFAULT voice for ${npcId}: pitch 1.0, rate 1.0`);
          }
          
          // Add error handling
          utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event.error);
          };
          
          utterance.onstart = () => {
            console.log('Speech started');
          };
          
          utterance.onend = () => {
            console.log('Speech ended');
          };
          
          // Ensure speech synthesis is ready
          if (this.speechSynthesis.speaking) {
            this.speechSynthesis.cancel();
            setTimeout(() => {
              this.speechSynthesis.speak(utterance);
            }, 100);
          } else {
            this.speechSynthesis.speak(utterance);
          }
          
          console.log('Speech synthesis called with:', {
            text: utterance.text,
            voice: utterance.voice ? utterance.voice.name : 'default',
            pitch: utterance.pitch,
            rate: utterance.rate,
            volume: utterance.volume
          });
        }
        
        getVoiceForNPC(npcId) {
          if (this.voices.length === 0) return 0;
          
          // Use the central gender identification system
          const gender = getNPCGender(npcId);
          const isFemale = gender === 'female';
          const isMale = gender === 'male';
          
          console.log(`🎤 Voice selection for NPC: ${npcId}, Gender: ${gender}`);
          
          // Try to find appropriate gendered voices
          const femaleVoices = this.voices.filter(voice => {
            const name = voice.name.toLowerCase();
            return name.includes('female') || 
                   name.includes('woman') || 
                   name.includes('zira') || 
                   name.includes('hazel') || 
                   name.includes('aria') ||
                   name.includes('helena') ||
                   name.includes('julie') ||
                   name.includes('catherine');
          });
          
          const maleVoices = this.voices.filter(voice => {
            const name = voice.name.toLowerCase();
            return name.includes('male') || 
                   name.includes('man') || 
                   name.includes('david') || 
                   name.includes('mark') || 
                   name.includes('richard') ||
                   name.includes('george') ||
                   name.includes('james') ||
                   name.includes('paul');
          });
          
          console.log('Available female voices:', femaleVoices.map(v => v.name));
          console.log('Available male voices:', maleVoices.map(v => v.name));
          
          // Get character lists for voice assignment
          const femaleCharacters = ['shop_mary', 'resident_noa', 'resident_sandra'];
          const maleCharacters = ['resident_dani', 'resident_alex', 'resident_ben'];
          
          // Assign voices based on gender
          if (isFemale && femaleVoices.length > 0) {
            const voiceIndex = femaleCharacters.indexOf(npcId) % femaleVoices.length;
            console.log(`🚺 Selected female voice #${voiceIndex}: ${femaleVoices[voiceIndex].name}`);
            return this.voices.indexOf(femaleVoices[voiceIndex]);
          }
          
          if (isMale && maleVoices.length > 0) {
            const voiceIndex = maleCharacters.indexOf(npcId) % maleVoices.length;
            console.log(`🚹 Selected male voice #${voiceIndex}: ${maleVoices[voiceIndex].name}`);
            return this.voices.indexOf(maleVoices[voiceIndex]);
          }
          
          // Fallback: use pitch to simulate gender differences
          if (isFemale) {
            return 0; // Will use higher pitch
          } else if (isMale) {
            return Math.min(1, this.voices.length - 1); // Will use lower pitch
          }
          
          return 0;
        }
      }
      
      const speechManager = new SpeechManager();

      // World
      const world = { width: 4000, height: 4000 };
      // Buildings and structures
      const buildings = [
        { id: 'playerHouse', x: 500, y: 400, w: 120, h: 80, type: 'house', color: '#8b4513', isPlayerHouse: true },
        { id: 'house2', x: 700, y: 350, w: 100, h: 90, type: 'house', color: '#cd853f', enterable: true },
        { id: 'house3', x: 900, y: 420, w: 110, h: 85, type: 'house', color: '#daa520', enterable: true },
        { id: 'shop1', x: 1200, y: 300, w: 150, h: 100, type: 'shop', color: '#9370db' },
        { id: 'house4', x: 3000, y: 1000, w: 140, h: 95, type: 'house', color: '#20b2aa', enterable: true },
        { id: 'house5', x: 3200, y: 950, w: 120, h: 80, type: 'house', color: '#ff6347', enterable: true },
        { id: 'barn1', x: 2800, y: 2500, w: 160, h: 120, type: 'barn', color: '#8b0000' },
        { id: 'house6', x: 800, y: 3000, w: 130, h: 90, type: 'house', color: '#4682b4', enterable: true },
        { id: 'house7', x: 1500, y: 3200, w: 110, h: 85, type: 'house', color: '#32cd32', enterable: true }
      ];
      
      // House interior state
      let currentHouse = null;
      let isInsideHouse = false;
      
      // House interiors definition - Much larger and more spacious
      const houseInteriors = {
        playerHouse: {
          name: 'הבית שלי',
          width: 800,
          height: 600,
          furniture: [
            // Living room area
            { type: 'sofa', x: 300, y: 200, w: 150, h: 60 },
            { type: 'table', x: 320, y: 280, w: 100, h: 80 },
            { type: 'chair', x: 280, y: 300, w: 30, h: 30 },
            { type: 'chair', x: 450, y: 300, w: 30, h: 30 },
            { type: 'carpet', x: 250, y: 180, w: 200, h: 200 },
            
            // Bedroom area (top left)
            { type: 'bed', x: 80, y: 80, w: 120, h: 80 },
            { type: 'wardrobe', x: 50, y: 200, w: 60, h: 100 },
            
            // Kitchen area (top right)
            { type: 'table', x: 600, y: 80, w: 80, h: 40 }, // Kitchen counter
            { type: 'chair', x: 580, y: 130, w: 30, h: 30 },
            
            // Study corner
            { type: 'bookshelf', x: 720, y: 200, w: 40, h: 120 },
            { type: 'chair', x: 670, y: 250, w: 30, h: 30 },
            
            // Decorative plants
            { type: 'plant', x: 100, y: 450, w: 25, h: 40 },
            { type: 'plant', x: 650, y: 450, w: 25, h: 40 }
          ]
        },
        house2: {
          name: 'בית השכן',
          width: 700,
          height: 500,
          furniture: [
            { type: 'bed', x: 80, y: 80, w: 100, h: 70 },
            { type: 'table', x: 350, y: 200, w: 80, h: 80 },
            { type: 'chair', x: 320, y: 170, w: 30, h: 30 },
            { type: 'chair', x: 460, y: 170, w: 30, h: 30 },
            { type: 'sofa', x: 500, y: 300, w: 120, h: 50 },
            { type: 'bookshelf', x: 600, y: 80, w: 35, h: 100 },
            { type: 'plant', x: 150, y: 350, w: 25, h: 40 },
            { type: 'carpet', x: 300, y: 150, w: 150, h: 150 }
          ]
        },
        house3: {
          name: 'בית המשפחה',
          width: 900,
          height: 650,
          furniture: [
            // Master bedroom
            { type: 'bed', x: 100, y: 100, w: 140, h: 90 },
            { type: 'wardrobe', x: 60, y: 250, w: 80, h: 120 },
            
            // Kids bedroom
            { type: 'bed', x: 600, y: 80, w: 100, h: 70 },
            { type: 'bed', x: 750, y: 80, w: 80, h: 60 },
            
            // Living room
            { type: 'sofa', x: 300, y: 300, w: 180, h: 70 },
            { type: 'table', x: 320, y: 400, w: 120, h: 90 },
            { type: 'chair', x: 280, y: 420, w: 30, h: 30 },
            { type: 'chair', x: 470, y: 420, w: 30, h: 30 },
            
            // Study area
            { type: 'table', x: 650, y: 350, w: 100, h: 60 },
            { type: 'chair', x: 680, y: 320, w: 30, h: 30 },
            { type: 'bookshelf', x: 780, y: 300, w: 40, h: 150 },
            
            // Large carpet
            { type: 'carpet', x: 250, y: 250, w: 250, h: 200 },
            
            // Plants
            { type: 'plant', x: 150, y: 500, w: 30, h: 50 },
            { type: 'plant', x: 750, y: 500, w: 30, h: 50 }
          ]
        }
      };
      
      // Trees scattered around with glowing effects
      const trees = [];
      function generateTrees() {
        for (let i = 0; i < 80; i++) {
          const x = Math.random() * world.width;
          const y = Math.random() * world.height;
          const type = Math.random() < 0.6 ? 'oak' : Math.random() < 0.5 ? 'pine' : 'palm';
          const glowing = Math.random() < 0.3; // 30% chance for glowing tree
          const glowColor = ['#00ff88', '#88ff00', '#0088ff', '#ff8800', '#ff0088'][Math.floor(Math.random() * 5)];
          trees.push({ x, y, type, size: 0.8 + Math.random() * 0.4, glowing, glowColor });
        }
      }
      generateTrees();
      
      // Street lamps for lighting
      const streetLamps = [];
      function generateStreetLamps() {
        // Along main roads
        for (let i = 0; i < world.width; i += 150) {
          streetLamps.push({ x: i, y: world.height/2 - 50, light: true, flickering: Math.random() < 0.2 });
          streetLamps.push({ x: i, y: world.height/2 + 50, light: true, flickering: Math.random() < 0.2 });
        }
        for (let i = 0; i < world.height; i += 200) {
          streetLamps.push({ x: world.width/2 - 50, y: i, light: true, flickering: Math.random() < 0.2 });
          streetLamps.push({ x: world.width/2 + 50, y: i, light: true, flickering: Math.random() < 0.2 });
        }
        
        // Random decorative lamps
        for (let i = 0; i < 40; i++) {
          streetLamps.push({
            x: Math.random() * world.width,
            y: Math.random() * world.height,
            light: true,
            flickering: Math.random() < 0.3,
            color: ['#ffff88', '#88ffff', '#ff88ff', '#88ff88'][Math.floor(Math.random() * 4)]
          });
        }
      }
      generateStreetLamps();
      
      // Floating sparkles system
      const floatingSparkles = [];
      const MAX_SPARKLES = 200;
      function initSparkles() {
        for (let i = 0; i < MAX_SPARKLES; i++) {
          floatingSparkles.push(createSparkle());
        }
      }
      function createSparkle() {
        return {
          x: Math.random() * world.width,
          y: Math.random() * world.height,
          vx: (Math.random() - 0.5) * 20,
          vy: (Math.random() - 0.5) * 20,
          size: 1 + Math.random() * 3,
          brightness: Math.random(),
          twinkleSpeed: 1 + Math.random() * 3,
          color: ['#ffff00', '#00ffff', '#ff00ff', '#00ff00', '#ff6600'][Math.floor(Math.random() * 5)],
          life: Math.random() * 5 + 2
        };
      }
      initSparkles();
      
      // House lights system
      const houseLights = [];
      function initHouseLights() {
        for (const building of buildings) {
          if (building.type === 'house') {
            houseLights.push({
              x: building.x + building.w/2,
              y: building.y + building.h/2,
              on: Math.random() < 0.8, // 80% chance to be on
              flickerTimer: Math.random() * 5,
              color: ['#ffff88', '#ff8888', '#88ff88', '#8888ff'][Math.floor(Math.random() * 4)]
            });
          }
        }
      }
      initHouseLights();
      
      // Roads
      const roads = [
        { x1: 0, y1: world.height/2, x2: world.width, y2: world.height/2, width: 80 },
        { x1: world.width/2, y1: 0, x2: world.width/2, y2: world.height, width: 80 },
        { x1: world.width/4, y1: 0, x2: world.width/4, y2: world.height, width: 60 },
        { x1: 3*world.width/4, y1: 0, x2: 3*world.width/4, y2: world.height, width: 60 }
      ];
      
      const obstacles = [];

      // Player
      const player = {
        x: world.width / 2,
        y: world.height / 2,
        angle: 0,
        radius: 22,
        vx: 0,
        vy: 0,
        step: 0,
        name: 'ליאור1',
      };

      // Minimap System
      const minimap = {
        element: document.getElementById('minimap'),
        canvas: document.getElementById('minimap-canvas'),
        ctx: null,
        visible: true,
        expanded: false,
        scale: 0.041, // Scale factor: minimap pixel per world pixel
        zoomLevel: 1.0,
        minZoom: 0.5,
        maxZoom: 3.0,
        panX: 0,
        panY: 0,
        isDragging: false,
        lastMouseX: 0,
        lastMouseY: 0,
        
        init() {
          this.ctx = this.canvas.getContext('2d');
          
          // Button event listeners
          document.getElementById('expand-btn').addEventListener('click', () => this.toggleExpand());
          document.getElementById('zoom-in-btn').addEventListener('click', () => this.zoomIn());
          document.getElementById('zoom-out-btn').addEventListener('click', () => this.zoomOut());
          document.getElementById('zoom-reset-btn').addEventListener('click', () => this.resetZoom());
          
          // Canvas event listeners
          this.canvas.addEventListener('click', (e) => this.handleClick(e));
          this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
          this.canvas.addEventListener('mouseleave', () => this.hideTooltip());
          this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
          this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
          this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
          this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
          
          this.tooltip = document.getElementById('minimap-tooltip');
        },
        
        handleMouseMove(e) {
          if (!this.visible) return;
          
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Handle dragging in expanded mode
          if (this.isDragging && this.expanded) {
            const deltaX = mouseX - this.lastMouseX;
            const deltaY = mouseY - this.lastMouseY;
            this.panX += deltaX;
            this.panY += deltaY;
            this.lastMouseX = mouseX;
            this.lastMouseY = mouseY;
            return;
          }
          
          // Show tooltip for NPCs, collectibles, and coins
          let hoveredItem = null;
          const maxHoverDistance = this.expanded ? 12 : 8;
          
          // Check NPCs
          for (const npc of npcs) {
            let npcMapX, npcMapY;
            
            if (this.expanded) {
              npcMapX = npc.x * this.scale * this.zoomLevel + this.panX;
              npcMapY = npc.y * this.scale * this.zoomLevel + this.panY;
            } else {
              npcMapX = npc.x * this.scale;
              npcMapY = npc.y * this.scale;
            }
            
            const distance = Math.hypot(mouseX - npcMapX, mouseY - npcMapY);
            
            if (distance < maxHoverDistance) {
              hoveredItem = { type: 'npc', name: npc.name };
              break;
            }
          }
          
          // Check collectibles if no NPC hovered
          if (!hoveredItem) {
            for (const gift of collectibles) {
              if (gift.picked) continue;
              
              let giftMapX, giftMapY;
              
              if (this.expanded) {
                giftMapX = gift.x * this.scale * this.zoomLevel + this.panX;
                giftMapY = gift.y * this.scale * this.zoomLevel + this.panY;
              } else {
                giftMapX = gift.x * this.scale;
                giftMapY = gift.y * this.scale;
              }
              
              const distance = Math.hypot(mouseX - giftMapX, mouseY - giftMapY);
              
              if (distance < maxHoverDistance) {
                const item = itemCatalog.find(item => item.id === gift.itemId);
                const itemName = item ? item.name : 'מתנה';
                hoveredItem = { type: 'gift', name: `🎁 ${itemName}` };
                break;
              }
            }
          }
          
          // Check coins if no NPC or gift hovered
          if (!hoveredItem) {
            for (const coin of coinsOnMap) {
              let coinMapX, coinMapY;
              
              if (this.expanded) {
                coinMapX = coin.x * this.scale * this.zoomLevel + this.panX;
                coinMapY = coin.y * this.scale * this.zoomLevel + this.panY;
              } else {
                coinMapX = coin.x * this.scale;
                coinMapY = coin.y * this.scale;
              }
              
              const distance = Math.hypot(mouseX - coinMapX, mouseY - coinMapY);
              
              if (distance < maxHoverDistance) {
                hoveredItem = { type: 'coin', name: '💰 מטבע (50 מטבעות)' };
                break;
              }
            }
          }
          
          // Check buildings if nothing else hovered
          if (!hoveredItem) {
            for (const building of buildings) {
              let buildingMapX, buildingMapY, buildingMapW, buildingMapH;
              
              if (this.expanded) {
                buildingMapX = building.x * this.scale * this.zoomLevel + this.panX;
                buildingMapY = building.y * this.scale * this.zoomLevel + this.panY;
                buildingMapW = building.w * this.scale * this.zoomLevel;
                buildingMapH = building.h * this.scale * this.zoomLevel;
              } else {
                buildingMapX = building.x * this.scale;
                buildingMapY = building.y * this.scale;
                buildingMapW = building.w * this.scale;
                buildingMapH = building.h * this.scale;
              }
              
              // Check if mouse is inside building rectangle
              if (mouseX >= buildingMapX && mouseX <= buildingMapX + buildingMapW &&
                  mouseY >= buildingMapY && mouseY <= buildingMapY + buildingMapH) {
                
                let buildingName = '';
                if (building.isPlayerHouse) {
                  buildingName = '🏠 הבית שלך';
                } else if (building.type === 'shop') {
                  buildingName = '🛍️ חנות';
                } else if (building.type === 'house') {
                  buildingName = '🏘️ בית תושב';
                } else if (building.type === 'barn') {
                  buildingName = '🏚️ אסם';
                } else {
                  buildingName = '🏢 מבנה';
                }
                
                hoveredItem = { type: 'building', name: buildingName };
                break;
              }
            }
          }
          
          // Check if hovering over road areas
          if (!hoveredItem) {
            for (const road of roads) {
              const roadCenterX = (road.x1 + road.x2) / 2;
              const roadCenterY = (road.y1 + road.y2) / 2;
              const roadLength = Math.hypot(road.x2 - road.x1, road.y2 - road.y1);
              
              let roadMapX, roadMapY;
              
              if (this.expanded) {
                roadMapX = roadCenterX * this.scale * this.zoomLevel + this.panX;
                roadMapY = roadCenterY * this.scale * this.zoomLevel + this.panY;
              } else {
                roadMapX = roadCenterX * this.scale;
                roadMapY = roadCenterY * this.scale;
              }
              
              const distance = Math.hypot(mouseX - roadMapX, mouseY - roadMapY);
              const roadRadius = (road.width / 2) * this.scale * (this.expanded ? this.zoomLevel : 1);
              
              if (distance < roadRadius + 5) {
                hoveredItem = { type: 'road', name: '🛣️ כביש ראשי' };
                break;
              }
            }
          }
          
          // Check if hovering near trees (sample a few trees for performance)
          if (!hoveredItem && trees.length > 0) {
            for (let i = 0; i < trees.length; i += 10) { // Check every 10th tree for performance
              const tree = trees[i];
              let treeMapX, treeMapY;
              
              if (this.expanded) {
                treeMapX = tree.x * this.scale * this.zoomLevel + this.panX;
                treeMapY = tree.y * this.scale * this.zoomLevel + this.panY;
              } else {
                treeMapX = tree.x * this.scale;
                treeMapY = tree.y * this.scale;
              }
              
              const distance = Math.hypot(mouseX - treeMapX, mouseY - treeMapY);
              
              if (distance < 8) {
                const treeTypes = {
                  oak: '🌳 אלון',
                  pine: '🌲 אורן', 
                  palm: '🌴 דקל'
                };
                const treeName = treeTypes[tree.type] || '🌳 עץ';
                hoveredItem = { type: 'tree', name: treeName };
                break;
              }
            }
          }
          
          // Check if hovering over vehicle (if exists)
          if (!hoveredItem && typeof playerVehicle !== 'undefined' && playerVehicle) {
            let vehicleMapX, vehicleMapY;
            
            if (this.expanded) {
              vehicleMapX = vehicleX * this.scale * this.zoomLevel + this.panX;
              vehicleMapY = vehicleY * this.scale * this.zoomLevel + this.panY;
            } else {
              vehicleMapX = vehicleX * this.scale;
              vehicleMapY = vehicleY * this.scale;
            }
            
            const distance = Math.hypot(mouseX - vehicleMapX, mouseY - vehicleMapY);
            
            if (distance < 10) {
              const vehicleName = getVehicleName(playerVehicle) || '🚗 רכב';
              const vehicleStatus = inVehicle ? ' (בשימוש)' : ' (זמין)';
              hoveredItem = { type: 'vehicle', name: vehicleName + vehicleStatus };
            }
          }
          
          // Check if hovering over player position
          if (!hoveredItem) {
            let playerMapX, playerMapY;
            
            if (this.expanded) {
              playerMapX = player.x * this.scale * this.zoomLevel + this.panX;
              playerMapY = player.y * this.scale * this.zoomLevel + this.panY;
            } else {
              playerMapX = player.x * this.scale;
              playerMapY = player.y * this.scale;
            }
            
            const distance = Math.hypot(mouseX - playerMapX, mouseY - playerMapY);
            
            if (distance < 8) {
              const playerStatus = adminMode ? '👑 אדמין' : '🎮 שחקן';
              hoveredItem = { type: 'player', name: `${playerStatus} - ${player.name} (רמה ${playerLevel})` };
            }
          }
          
          // Show current view area info if nothing specific is hovered
          if (!hoveredItem) {
            // Check if hovering over the view rectangle outline
            const viewWidth = innerWidth / zoomLevel;
            const viewHeight = innerHeight / zoomLevel;
            let viewX, viewY, viewW, viewH;
            
            if (this.expanded) {
              viewX = ((player.x - viewWidth/2) * this.scale * this.zoomLevel + this.panX);
              viewY = ((player.y - viewHeight/2) * this.scale * this.zoomLevel + this.panY);
              viewW = viewWidth * this.scale * this.zoomLevel;
              viewH = viewHeight * this.scale * this.zoomLevel;
            } else {
              viewX = (player.x - viewWidth/2) * this.scale;
              viewY = (player.y - viewHeight/2) * this.scale;
              viewW = viewWidth * this.scale;
              viewH = viewHeight * this.scale;
            }
            
            // Check if near the view rectangle border
            const borderThickness = 5;
            if ((mouseX >= viewX - borderThickness && mouseX <= viewX + viewW + borderThickness &&
                 mouseY >= viewY - borderThickness && mouseY <= viewY + viewH + borderThickness) &&
                !(mouseX > viewX + borderThickness && mouseX < viewX + viewW - borderThickness &&
                  mouseY > viewY + borderThickness && mouseY < viewY + viewH - borderThickness)) {
              hoveredItem = { type: 'view', name: '👁️ אזור הצפיה הנוכחי שלך' };
            }
          }
          
          if (hoveredItem) {
            this.showTooltip(hoveredItem.name, mouseX, mouseY);
          } else {
            this.hideTooltip();
          }
        },
        
        showTooltip(text, x, y) {
          this.tooltip.textContent = text;
          
          // Position tooltip near cursor but avoid going off screen
          const rect = this.element.getBoundingClientRect();
          const tooltipX = rect.left + x;
          const tooltipY = rect.top + y - 40;
          
          // Adjust if tooltip would go off screen
          const maxX = window.innerWidth - 220; // Account for tooltip width
          const maxY = window.innerHeight - 60; // Account for tooltip height
          
          this.tooltip.style.left = Math.min(tooltipX, maxX) + 'px';
          this.tooltip.style.top = Math.max(20, Math.min(tooltipY, maxY)) + 'px';
          this.tooltip.classList.add('visible');
        },
        
        hideTooltip() {
          this.tooltip.classList.remove('visible');
        },
        
        handleClick(e) {
          if (!this.visible) return;
          
          const rect = this.canvas.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const clickY = e.clientY - rect.top;
          
          // Convert click position to world coordinates
          let worldX, worldY;
          
          if (this.expanded) {
            // Account for zoom and pan in expanded mode
            worldX = (clickX - this.panX) / (this.scale * this.zoomLevel);
            worldY = (clickY - this.panY) / (this.scale * this.zoomLevel);
          } else {
            worldX = clickX / this.scale;
            worldY = clickY / this.scale;
          }
          
          // Clamp to world bounds
          worldX = Math.max(50, Math.min(world.width - 50, worldX));
          worldY = Math.max(50, Math.min(world.height - 50, worldY));
          
          // Check if clicking on NPC, collectible, or coin first
          let nearestTarget = null;
          let nearestDistance = Infinity;
          const maxClickDistance = this.expanded ? 12 : 15;
          
          // Check NPCs first
          for (const npc of npcs) {
            const npcMapX = this.expanded ? 
              (npc.x * this.scale * this.zoomLevel + this.panX) : 
              (npc.x * this.scale);
            const npcMapY = this.expanded ? 
              (npc.y * this.scale * this.zoomLevel + this.panY) : 
              (npc.y * this.scale);
            const distance = Math.hypot(clickX - npcMapX, clickY - npcMapY);
            
            if (distance < maxClickDistance && distance < nearestDistance) {
              nearestTarget = { type: 'npc', target: npc };
              nearestDistance = distance;
            }
          }
          
          // Check collectibles (gifts)
          for (const gift of collectibles) {
            if (gift.picked) continue; // Skip collected gifts
            
            const giftMapX = this.expanded ? 
              (gift.x * this.scale * this.zoomLevel + this.panX) : 
              (gift.x * this.scale);
            const giftMapY = this.expanded ? 
              (gift.y * this.scale * this.zoomLevel + this.panY) : 
              (gift.y * this.scale);
            const distance = Math.hypot(clickX - giftMapX, clickY - giftMapY);
            
            if (distance < maxClickDistance && distance < nearestDistance) {
              nearestTarget = { type: 'gift', target: gift };
              nearestDistance = distance;
            }
          }
          
          // Check coins
          for (const coin of coinsOnMap) {
            const coinMapX = this.expanded ? 
              (coin.x * this.scale * this.zoomLevel + this.panX) : 
              (coin.x * this.scale);
            const coinMapY = this.expanded ? 
              (coin.y * this.scale * this.zoomLevel + this.panY) : 
              (coin.y * this.scale);
            const distance = Math.hypot(clickX - coinMapX, clickY - coinMapY);
            
            if (distance < maxClickDistance && distance < nearestDistance) {
              nearestTarget = { type: 'coin', target: coin };
              nearestDistance = distance;
            }
          }
          
          // Handle teleportation based on target type
          if (nearestTarget) {
            if (nearestTarget.type === 'npc') {
              this.teleportToNPC(nearestTarget.target);
            } else if (nearestTarget.type === 'gift') {
              this.teleportToCollectible(nearestTarget.target);
            } else if (nearestTarget.type === 'coin') {
              this.teleportToCoin(nearestTarget.target);
            }
          } else {
            // Teleport to clicked location
            this.teleportToLocation(worldX, worldY);
          }
        },
        
        teleportToLocation(x, y) {
          // Clear current target
          target = null;
          
          // Teleport player to location
          player.x = x;
          player.y = y;
          
          // Show teleport message
          showPickupText(`✨ התשגרת! ✨`, innerWidth/2, innerHeight/3);
          
          // Play teleport sound
          if (audioManager && audioManager.initialized) {
            audioManager.createBeep(600, 0.1, 'sine');
            setTimeout(() => audioManager.createBeep(900, 0.1, 'sine'), 100);
            setTimeout(() => audioManager.createBeep(1200, 0.15, 'sine'), 200);
          }
        },
        
        teleportToNPC(npc) {
          // Clear current target
          target = null;
          
          // Teleport player near the NPC (not exactly on them)
          const offsetX = (Math.random() - 0.5) * 60; // Random offset to avoid overlapping
          const offsetY = (Math.random() - 0.5) * 60;
          
          player.x = npc.x + offsetX;
          player.y = npc.y + offsetY;
          
          // Make sure player is within world bounds
          player.x = Math.max(50, Math.min(world.width - 50, player.x));
          player.y = Math.max(50, Math.min(world.height - 50, player.y));
          
          // Show teleport message
          showPickupText(`✨ התשגרת אל ${npc.name}! ✨`, innerWidth/2, innerHeight/3);
          
          // Play teleport sound
          if (audioManager && audioManager.initialized) {
            audioManager.createBeep(800, 0.1, 'sine');
            setTimeout(() => audioManager.createBeep(1200, 0.1, 'sine'), 100);
            setTimeout(() => audioManager.createBeep(1500, 0.15, 'sine'), 200);
          }
        },
        
        teleportToCollectible(gift) {
          // Clear current target
          target = null;
          
          // Teleport player near the gift (close enough to collect)
          const offsetX = (Math.random() - 0.5) * 40;
          const offsetY = (Math.random() - 0.5) * 40;
          
          player.x = gift.x + offsetX;
          player.y = gift.y + offsetY;
          
          // Make sure player is within world bounds
          player.x = Math.max(50, Math.min(world.width - 50, player.x));
          player.y = Math.max(50, Math.min(world.height - 50, player.y));
          
          // Show teleport message
          const item = itemCatalog.find(item => item.id === gift.itemId);
          const itemName = item ? item.name : 'מתנה';
          showPickupText(`🎁 התשגרת למתנה: ${itemName}! 🎁`, innerWidth/2, innerHeight/3);
          
          // Play teleport sound
          if (audioManager && audioManager.initialized) {
            audioManager.createBeep(600, 0.1, 'sine');
            setTimeout(() => audioManager.createBeep(1000, 0.1, 'sine'), 100);
            setTimeout(() => audioManager.createBeep(1400, 0.15, 'sine'), 200);
          }
        },
        
        teleportToCoin(coin) {
          // Clear current target
          target = null;
          
          // Teleport player near the coin (close enough to collect)
          const offsetX = (Math.random() - 0.5) * 30;
          const offsetY = (Math.random() - 0.5) * 30;
          
          player.x = coin.x + offsetX;
          player.y = coin.y + offsetY;
          
          // Make sure player is within world bounds
          player.x = Math.max(50, Math.min(world.width - 50, player.x));
          player.y = Math.max(50, Math.min(world.height - 50, player.y));
          
          // Show teleport message
          showPickupText(`💰 התשגרת למטבע! 💰`, innerWidth/2, innerHeight/3);
          
          // Play teleport sound
          if (audioManager && audioManager.initialized) {
            audioManager.createBeep(700, 0.1, 'sine');
            setTimeout(() => audioManager.createBeep(1100, 0.1, 'sine'), 100);
            setTimeout(() => audioManager.createBeep(1300, 0.15, 'sine'), 200);
          }
        },
        
        toggle() {
          this.visible = !this.visible;
          this.element.style.display = this.visible ? 'block' : 'none';
        },
        
        toggleExpand() {
          this.expanded = !this.expanded;
          this.element.classList.toggle('expanded', this.expanded);
          const overlay = document.getElementById('minimap-overlay');
          
          if (this.expanded) {
            // Show overlay
            overlay.style.display = 'block';
            overlay.addEventListener('click', () => this.toggleExpand());
            
            // Disable body scrolling
            document.body.style.overflow = 'hidden';
            
            // Resize canvas for expanded view
            this.canvas.width = 332;
            this.canvas.height = 282;
            document.getElementById('expand-btn').innerHTML = '⤡';
            document.getElementById('expand-btn').title = 'כווץ מפה';
            
            // Reset zoom and pan for better experience
            this.resetZoom();
          } else {
            // Hide overlay
            overlay.style.display = 'none';
            overlay.removeEventListener('click', () => this.toggleExpand());
            
            // Re-enable body scrolling
            document.body.style.overflow = 'auto';
            
            // Reset to small view
            this.canvas.width = 164;
            this.canvas.height = 140;
            document.getElementById('expand-btn').innerHTML = '⤢';
            document.getElementById('expand-btn').title = 'הרחב מפה';
            this.resetZoom();
          }
        },
        
        zoomIn() {
          this.zoomLevel = Math.min(this.maxZoom, this.zoomLevel * 1.2);
          this.updateZoomIndicator();
        },
        
        zoomOut() {
          this.zoomLevel = Math.max(this.minZoom, this.zoomLevel / 1.2);
          this.updateZoomIndicator();
        },
        
        resetZoom() {
          this.zoomLevel = 1.0;
          this.panX = 0;
          this.panY = 0;
          this.updateZoomIndicator();
        },
        
        updateZoomIndicator() {
          const indicator = document.getElementById('zoom-indicator');
          if (indicator) {
            indicator.textContent = Math.round(this.zoomLevel * 100) + '%';
          }
        },
        
        handleMouseDown(e) {
          if (!this.expanded) return;
          
          this.isDragging = true;
          const rect = this.canvas.getBoundingClientRect();
          this.lastMouseX = e.clientX - rect.left;
          this.lastMouseY = e.clientY - rect.top;
          this.canvas.style.cursor = 'grabbing';
        },
        
        handleMouseUp() {
          this.isDragging = false;
          this.canvas.style.cursor = this.expanded ? 'crosshair' : 'pointer';
        },
        
        handleWheel(e) {
          if (!this.expanded) return;
          
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          const oldZoom = this.zoomLevel;
          if (e.deltaY < 0) {
            this.zoomIn();
          } else {
            this.zoomOut();
          }
          
          // Zoom towards mouse position
          const zoomRatio = this.zoomLevel / oldZoom;
          this.panX = mouseX - (mouseX - this.panX) * zoomRatio;
          this.panY = mouseY - (mouseY - this.panY) * zoomRatio;
          
          this.updateZoomIndicator();
        },
        
        update(camX, camY) {
          if (!this.visible || !this.ctx) return;
          
          const ctx = this.ctx;
          const canvas = this.canvas;
          
          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Apply zoom and pan transformations
          ctx.save();
          if (this.expanded) {
            ctx.translate(this.panX, this.panY);
            ctx.scale(this.zoomLevel, this.zoomLevel);
          }
          
          // Draw background
          ctx.fillStyle = '#0f1220';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw world border
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(0, 0, world.width * this.scale, world.height * this.scale);
          
          // Draw roads
          ctx.strokeStyle = 'rgba(128, 128, 128, 0.8)';
          ctx.lineWidth = 2;
          for (const road of roads) {
            ctx.beginPath();
            ctx.moveTo(road.x1 * this.scale, road.y1 * this.scale);
            ctx.lineTo(road.x2 * this.scale, road.y2 * this.scale);
            ctx.stroke();
          }
          
          // Draw buildings
          for (const building of buildings) {
            if (building.type === 'house') {
              ctx.fillStyle = building.isPlayerHouse ? '#ffaa00' : building.color || '#8b4513';
            } else if (building.type === 'shop') {
              ctx.fillStyle = '#9370db';
            } else {
              ctx.fillStyle = building.color || '#654321';
            }
            
            ctx.fillRect(
              building.x * this.scale,
              building.y * this.scale,
              building.w * this.scale,
              building.h * this.scale
            );
          }
          
          // Draw trees (as small dots)
          ctx.fillStyle = 'rgba(34, 139, 34, 0.6)';
          for (let i = 0; i < trees.length; i += 4) { // Show only every 4th tree for performance
            const tree = trees[i];
            ctx.beginPath();
            ctx.arc(tree.x * this.scale, tree.y * this.scale, 1, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Draw NPCs as clickable dots
          for (const npc of npcs) {
            const npcX = npc.x * this.scale;
            const npcY = npc.y * this.scale;
            
            // Different colors for different NPC types
            if (npc.kind === 'shop') {
              ctx.fillStyle = '#9370db'; // Purple for shops
              ctx.strokeStyle = '#ffffff';
            } else {
              ctx.fillStyle = '#ff6b6b'; // Red for residents
              ctx.strokeStyle = '#ffffff';
            }
            
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(npcX, npcY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Add a pulsing effect to make them more noticeable
            const time = performance.now() * 0.003;
            const pulse = 0.5 + Math.sin(time * 2 + npc.x * 0.01) * 0.3;
            ctx.fillStyle = npc.kind === 'shop' ? `rgba(147, 112, 219, ${pulse})` : `rgba(255, 107, 107, ${pulse})`;
            ctx.beginPath();
            ctx.arc(npcX, npcY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Add name label on hover (we'll implement this with CSS tooltips)
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(npc.name.charAt(0), npcX, npcY + 2); // Show first letter of name
          }
          
          // Draw collectibles (gifts) as gift boxes
          for (const gift of collectibles) {
            if (gift.picked) continue; // Skip already collected gifts
            
            const giftX = gift.x * this.scale;
            const giftY = gift.y * this.scale;
            
            // Draw gift box with glow effect
            const giftTime = performance.now() * 0.004;
            const giftGlow = 0.4 + Math.sin(giftTime * 3 + gift.x * 0.02) * 0.3;
            
            // Glow effect
            ctx.fillStyle = `rgba(255, 215, 0, ${giftGlow})`;
            ctx.beginPath();
            ctx.arc(giftX, giftY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Gift box
            ctx.fillStyle = '#ff6b6b';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.fillRect(giftX - 2, giftY - 2, 4, 4);
            ctx.strokeRect(giftX - 2, giftY - 2, 4, 4);
            
            // Gift ribbon
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(giftX, giftY - 2);
            ctx.lineTo(giftX, giftY + 2);
            ctx.moveTo(giftX - 2, giftY);
            ctx.lineTo(giftX + 2, giftY);
            ctx.stroke();
          }
          
          // Draw coins on map
          for (const coin of coinsOnMap) {
            const coinX = coin.x * this.scale;
            const coinY = coin.y * this.scale;
            
            // Draw coin with glow effect
            const coinTime = performance.now() * 0.005;
            const coinGlow = 0.5 + Math.sin(coinTime * 4 + coin.x * 0.03) * 0.4;
            
            // Glow effect
            ctx.fillStyle = `rgba(255, 215, 0, ${coinGlow})`;
            ctx.beginPath();
            ctx.arc(coinX, coinY, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Coin
            ctx.fillStyle = '#ffd700';
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(coinX, coinY, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Coin symbol
            ctx.fillStyle = '#b8860b';
            ctx.font = 'bold 5px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('💰', coinX, coinY);
          }
          
          // Draw view area (camera bounds)
          const viewWidth = innerWidth / zoomLevel;
          const viewHeight = innerHeight / zoomLevel;
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(
            (camX - viewWidth/2) * this.scale,
            (camY - viewHeight/2) * this.scale,
            viewWidth * this.scale,
            viewHeight * this.scale
          );
          ctx.setLineDash([]);
          
          // Draw player position
          ctx.fillStyle = adminMode ? '#ffd700' : '#00ff88';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(player.x * this.scale, player.y * this.scale, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Draw player direction arrow
          ctx.strokeStyle = adminMode ? '#ffd700' : '#00ff88';
          ctx.lineWidth = 2;
          const arrowLength = 8;
          const arrowX = player.x * this.scale + Math.cos(player.angle) * arrowLength;
          const arrowY = player.y * this.scale + Math.sin(player.angle) * arrowLength;
          ctx.beginPath();
          ctx.moveTo(player.x * this.scale, player.y * this.scale);
          ctx.lineTo(arrowX, arrowY);
          ctx.stroke();
          
          // Restore transformation matrix
          ctx.restore();
        }
      };
      
      // Initialize minimap when ready
      setTimeout(() => {
        minimap.init();
      }, 100);

      // Admin + Chat UI
      let adminMode = false;
      let hasReceivedAdminCoins = false; // Track if admin coins were already given
      const adminBtn = document.getElementById('adminBtn');
      
      // Explorer mode
      let explorerMode = false;
      let hasReceivedExplorerCoins = false; // Track if explorer coins were already given
      const explorerBtn = document.getElementById('explorerBtn');
      const explorerMessageBtn = document.getElementById('explorerMessageBtn');
      
      // Global Messages (Explorer feature)
      const globalMessageModal = document.getElementById('globalMessageModal');
      const globalMessageInput = document.getElementById('globalMessageInput');
      const sendGlobalMessageBtn = document.getElementById('sendGlobalMessage');
      const closeGlobalMessageBtn = document.getElementById('closeGlobalMessage');
      const globalMessageDisplay = document.getElementById('globalMessageDisplay');
      const globalMessageText = document.getElementById('globalMessageText');
      const dismissGlobalMessageBtn = document.getElementById('dismissGlobalMessage');
      const chatInput = document.getElementById('chatInput');
      const sendBtn = document.getElementById('sendBtn');
      const homeBtn = document.getElementById('homeBtn');
      const emojiBtn = document.getElementById('emojiBtn');
      const emojiPanel = document.getElementById('emojiPanel');
      const danceBtn = document.getElementById('danceBtn');
      const dancePanel = document.getElementById('dancePanel');
      const tradeModal = document.getElementById('tradeModal');
      const closeTradeBtn = document.getElementById('closeTrade');
      const tradeOffersEl = document.getElementById('tradeOffers');
      const help = document.getElementById('help');
      
      let currentTradeNpc = null;
      
      // Dancing system
      let isDancing = false;
      let currentDance = null;
      let danceStartTime = 0;
      let danceFrame = 0;
      const danceAnimations = {
        party: { frames: 8, speed: 0.3, poses: ['normal', 'up', 'side', 'down', 'side', 'up', 'normal', 'twist'] },
        disco: { frames: 6, speed: 0.4, poses: ['point_up', 'point_down', 'spin', 'lean', 'point_up', 'groove'] },
        breakdance: { frames: 12, speed: 0.2, poses: ['freeze', 'windmill', 'headspin', 'freeze', 'backspin', 'freeze', 'flare', 'freeze', 'toprock', 'freeze', 'sixstep', 'freeze'] },
        salsa: { frames: 4, speed: 0.5, poses: ['basic', 'cross', 'turn', 'dip'] },
        robot: { frames: 6, speed: 0.6, poses: ['lock1', 'lock2', 'wave1', 'wave2', 'isolate', 'freeze'] },
        'hip-hop': { frames: 8, speed: 0.35, poses: ['bounce', 'lean', 'step', 'cross', 'bounce', 'lean', 'step', 'point'] },
        ballet: { frames: 5, speed: 0.7, poses: ['plie', 'arabesque', 'pirouette', 'grand_jete', 'port_de_bras'] },
        tango: { frames: 6, speed: 0.45, poses: ['promenade', 'corte', 'ocho', 'giro', 'gancho', 'close'] },
        moonwalk: { frames: 4, speed: 0.4, poses: ['slide_back', 'slide_back2', 'slide_back3', 'slide_back4'] },
        floss: { frames: 4, speed: 0.3, poses: ['swing_left', 'swing_right', 'swing_left', 'swing_right'] },
        wave: { frames: 8, speed: 0.25, poses: ['wave1', 'wave2', 'wave3', 'wave4', 'wave5', 'wave6', 'wave7', 'wave8'] },
        electric: { frames: 10, speed: 0.2, poses: ['shock1', 'shock2', 'shock3', 'shock4', 'shock5', 'shock6', 'shock7', 'shock8', 'shock9', 'shock10'] }
      };
      
      // Coin system and shop
      let coins = 100;
      const coinCountEl = document.getElementById('coinCount');
      const shopBtn = document.getElementById('shopBtn');
      const shopModal = document.getElementById('shopModal');
      const closeShopBtn = document.getElementById('closeShop');
      const shopItemsEl = document.getElementById('shopItems');
      const audioBtn = document.getElementById('audioBtn');
      
      // XP and Level system - Simplified progress bar system
      let playerLevel = 1;
      let currentLevelProgress = 0; // Progress in current level (0.0 to 1.0)
      let xpTimer = 0;
      const MAX_LEVEL = 57;
      const XP_GAIN_INTERVAL = 3; // seconds between XP gains
      const XP_GAIN_AMOUNT = 0.04; // how much progress to add each time (4%)
      
      // Initialize player level based on admin status
      function initializePlayerLevel() {
        if (adminMode) {
          playerLevel = MAX_LEVEL;
          currentLevelProgress = 1.0; // Max level has full progress
        } else {
          playerLevel = 1;
          currentLevelProgress = 0.0;
        }
        updateLevelDisplay();
      }
      
      // Update level and XP display
      function updateLevelDisplay() {
        const levelCountEl = document.getElementById('levelCount');
        const currentXPEl = document.getElementById('currentXP');
        const requiredXPEl = document.getElementById('requiredXP');
        const xpProgressEl = document.getElementById('xpProgress');
        
        if (levelCountEl) levelCountEl.textContent = playerLevel;
        
        if (playerLevel >= MAX_LEVEL) {
          // Max level reached
          if (currentXPEl) currentXPEl.textContent = 'MAX';
          if (requiredXPEl) requiredXPEl.textContent = 'MAX';
          if (xpProgressEl) xpProgressEl.style.width = '100%';
        } else {
          // Show progress as percentage
          const currentPercent = Math.floor(currentLevelProgress * 100);
          if (currentXPEl) currentXPEl.textContent = currentPercent;
          if (requiredXPEl) requiredXPEl.textContent = '100';
          if (xpProgressEl) xpProgressEl.style.width = (currentLevelProgress * 100) + '%';
        }
        
        // Update profile if it's open
        if (profileModal && profileModal.classList.contains('open')) {
          const statLevel = document.getElementById('statLevel');
          const statXP = document.getElementById('statXP');
          
          if (statLevel) statLevel.textContent = playerLevel.toString();
          if (statXP) {
            if (playerLevel >= MAX_LEVEL) {
              statXP.textContent = 'MAX';
            } else {
              const currentPercent = Math.floor(currentLevelProgress * 100);
              statXP.textContent = currentPercent + '%';
            }
          }
        }
      }
      
      // Gain XP progress and check for level up
      function gainXPProgress(progressAmount) {
        if (playerLevel >= MAX_LEVEL) return; // Max level reached
        
        currentLevelProgress += progressAmount;
        
        // Check for level up
        if (currentLevelProgress >= 1.0) {
          playerLevel++;
          currentLevelProgress = 0.0; // Reset progress for new level
          showLevelUpMessage();
          
          // If reached max level, set progress to 1.0
          if (playerLevel >= MAX_LEVEL) {
            currentLevelProgress = 1.0;
          }
        }
        
        updateLevelDisplay();
        
        // Update profile if it's open
        if (profileModal.classList.contains('open')) {
          renderProfile();
        }
      }
      
      // Show level up message
      function showLevelUpMessage() {
        const message = `🎉 מזל טוב עלית לרמה ${playerLevel}! 🎉`;
        showPickupText(message, innerWidth/2, innerHeight/3);
        
        // Play level up sound if available
        if (audioManager && audioManager.initialized) {
          audioManager.createBeep(800, 0.2, 'square');
          setTimeout(() => audioManager.createBeep(1000, 0.3, 'square'), 200);
          setTimeout(() => audioManager.createBeep(1200, 0.4, 'square'), 400);
        }
      }
      
      // Update XP timer and grant XP over time
      function updateXPSystem(dt) {
        if (playerLevel >= MAX_LEVEL) return; // Don't gain XP at max level
        
        xpTimer += dt;
        if (xpTimer >= XP_GAIN_INTERVAL) {
          xpTimer = 0;
          
          // Add progress towards next level
          gainXPProgress(XP_GAIN_AMOUNT);
          
          // Show small XP gain text
          const progressPercent = Math.floor(XP_GAIN_AMOUNT * 100);
          const xpText = `+${progressPercent}%`;
          showPickupText(xpText, 120, 460);
        }
      }

      // Inventory state
      const inventoryBtn = document.getElementById('inventoryBtn');
      const invModal = document.getElementById('invModal');
      const closeInvBtn = document.getElementById('closeInv');
      const invGrid = document.getElementById('invGrid');
      let ownedItems = new Set(['golden_boots']); // item ids player owns - start with golden boots
      let equipped = { hat: null, back: null, feet: 'golden_boots', face: null, effect: null, chest: null };
      
      // Profile modal elements
      const coinsDisplay = document.getElementById('coinsDisplay');
      const profileModal = document.getElementById('profileModal');
      const closeProfileBtn = document.getElementById('closeProfile');
      const avatarDisplay = document.getElementById('avatarDisplay');
      const playerNameDisplay = document.getElementById('playerNameDisplay');
      const playerStatusDisplay = document.getElementById('playerStatusDisplay');
      const statCoins = document.getElementById('statCoins');
      const statItems = document.getElementById('statItems');
      const statVehicle = document.getElementById('statVehicle');
      const statAdmin = document.getElementById('statAdmin');
      
      // Equipment selection modal elements
      const equipmentModal = document.getElementById('equipmentModal');
      const closeEquipmentBtn = document.getElementById('closeEquipment');
      const equipmentSlotIcon = document.getElementById('equipmentSlotIcon');
      const equipmentSlotName = document.getElementById('equipmentSlotName');
      const equipmentOptionsEl = document.getElementById('equipmentOptions');
      let currentEquipmentSlot = null;
      
      // Vehicle system
      let playerVehicle = null; // which vehicle player owns
      let inVehicle = false; // is player currently in vehicle
      let vehicleX = 0, vehicleY = 0; // vehicle position when not in use
      let vehicleAngle = 0;
      let vehicleVx = 0, vehicleVy = 0;

      // Trail positions for effect
      const trail = [];
      const TRAIL_MAX = 24;

      // Plaza config (central colorful plaza) with enhanced lighting
      const plaza = { 
        x: world.width/2, 
        y: world.height/2 - 100, 
        radius: 260,
        lightRings: [
          { radius: 100, color: '#ff6b9d', speed: 1 },
          { radius: 150, color: '#4ecdc4', speed: -0.8 },
          { radius: 200, color: '#45b7d1', speed: 1.2 },
          { radius: 250, color: '#96ceb4', speed: -1.5 }
        ]
      };

      // Enhanced confetti particles over the plaza with glowing effects
      let confetti = [];
      const CONFETTI_COUNT = 200;
      const CONFETTI_COLORS = ['#ff7675','#74b9ff','#55efc4','#ffeaa7','#a29bfe','#fd79a8','#00cec9','#e84393'];
      function initConfetti(){
        confetti = [];
        for(let i=0;i<CONFETTI_COUNT;i++){
          confetti.push(spawnConfetto());
        }
      }
      function spawnConfetto(){
        const ang = Math.random()*Math.PI*2;
        const r = Math.random()*plaza.radius*0.9;
        return {
          x: plaza.x + Math.cos(ang)*r,
          y: plaza.y + Math.sin(ang)*r - 120,
          vx: (Math.random()-0.5)*40,
          vy: 30 + Math.random()*40,
          rot: Math.random()*Math.PI*2,
          vr: (Math.random()-0.5)*3,
          col: CONFETTI_COLORS[Math.floor(Math.random()*CONFETTI_COLORS.length)],
          w: 3+Math.random()*3,
          h: 5+Math.random()*4,
          glowing: Math.random() < 0.4, // 40% chance to glow
          twinkle: Math.random() * Math.PI * 2
        };
      }
      initConfetti();

      // Shop items database with rare items
      const shopItems = [
        // Basic Items
        { id: 'speed_boost', name: '💨 מהירות קבועה', description: 'מגדיל את מהירות התנועה לצמיתות', price: 120, type: 'permanent' },
        { id: 'golden_name', name: '🏅 שם זהב', description: 'השם שלך בצ׳אט יהיה בצבע זהב תמיד', price: 200, type: 'cosmetic' },
        { id: 'coin_magnet', name: '🧢 מגנט מטבעות', description: 'משך מטבעות מרחוק יותר', price: 250, type: 'upgrade' },
        
        // Regular Cosmetics
        { id: 'spark_trail', name: '✨ שובל נצנצים', description: 'שובל נוצץ מאחוריך', price: 180, type: 'cosmetic', grantItem: 'spark_trail' },
        { id: 'blue_trail', name: '💙 שובל כחול', description: 'שובל כחול זוהר', price: 220, type: 'cosmetic', grantItem: 'blue_trail' },
        { id: 'fire_trail', name: '🔥 שובל אש', description: 'שובל אש חם', price: 300, type: 'cosmetic', grantItem: 'fire_trail' },
        { id: 'top_hat', name: '🎭 צילינדר', description: 'כובע צילינדר אלגנטי', price: 200, type: 'cosmetic', grantItem: 'top_hat' },
        { id: 'angel_wings', name: '🪽 כנפי מלאך', description: 'כנפיים לבנות מאחור', price: 400, type: 'cosmetic', grantItem: 'angel_wings' },
        { id: 'green_boots', name: '🥾 נעלי ירוק', description: 'נעליים ירוקות', price: 150, type: 'cosmetic', grantItem: 'green_boots' },
        { id: 'red_glasses', name: '👓 משקפים אדומות', description: 'לוק אדום', price: 160, type: 'cosmetic', grantItem: 'red_glasses' },
        
        // Birthday Items - Special Collection
        { id: 'birthday_hat_1', name: '🎂 כובע יום הולדת 1', description: 'כובע יום הולדת מיוחד עם נרות!', price: 250, type: 'birthday', grantItem: 'birthday_hat_1' },
        { id: 'birthday_hat_2', name: '🎉 כובע יום הולדת 2', description: 'כובע יום הולדת עם קונפטי!', price: 280, type: 'birthday', grantItem: 'birthday_hat_2' },
        { id: 'party_hat', name: '🥳 כובע מסיבה', description: 'כובע מסיבה צבעוני וחגיגי!', price: 220, type: 'birthday', grantItem: 'party_hat' },
        { id: 'birthday_balloons', name: '🎈 בלוני יום הולדת', description: 'חבורת בלונים צבעוניים מאחור!', price: 300, type: 'birthday', grantItem: 'birthday_balloons' },
        { id: 'heart_balloons', name: '💖 בלוני לב', description: 'בלונים רומנטיים בצורת לב', price: 320, type: 'birthday', grantItem: 'heart_balloons' },
        { id: 'birthday_shirt_1', name: '🎂 חולצת יום הולדת 1', description: 'חולצה עם עוגת יום הולדת מודפסת!', price: 200, type: 'birthday', grantItem: 'birthday_shirt_1' },
        { id: 'birthday_shirt_2', name: '🎁 חולצת יום הולדת 2', description: 'חולצה עם מתנות מודפסות!', price: 210, type: 'birthday', grantItem: 'birthday_shirt_2' },
        { id: 'party_shirt', name: '🥳 חולצת מסיבה', description: 'חולצה צבעונית מיוחדת למסיבות!', price: 190, type: 'birthday', grantItem: 'party_shirt' },
        { id: 'confetti_trail', name: '🎊 שובל קונפטי', description: 'שובל של חלקיקי קונפטי צבעוניים!', price: 350, type: 'birthday', grantItem: 'confetti_trail' },
        
        // RARE ITEMS - Very Expensive!
        { id: 'dragon_wings', name: '🐉 כנפי דרקון', description: 'כנפיים שחורות ואדומות - נדיר!', price: 1000, type: 'rare', grantItem: 'dragon_wings' },
        { id: 'rainbow_trail', name: '🌈 שובל קשת', description: 'שובל משתנה צבעים - נדיר!', price: 800, type: 'rare', grantItem: 'rainbow_trail' },
        { id: 'crown_royal', name: '👑 כתר מלכותי', description: 'כתר בצבע זהב עם יהלומים - נדיר!', price: 1200, type: 'rare', grantItem: 'crown_royal' },
        { id: 'shadow_cloak', name: '🧥 גלימת צללים', description: 'גלימה שחורה עם אפקטים - נדיר!', price: 900, type: 'rare', grantItem: 'shadow_cloak' },
        { id: 'golden_boots', name: '🥿 נעלי זהב', description: 'נעליים זהובות מנצנצות - נדיר!', price: 700, type: 'rare', grantItem: 'golden_boots' },
        { id: 'laser_glasses', name: '🔴 משקפי לייזר', description: 'משקפיים עם קרני לייזר - נדיר!', price: 600, type: 'rare', grantItem: 'laser_glasses' },
        
        // LEGENDARY ITEMS - Super Expensive!
        { id: 'mega_halo', name: '✨ הילה מגה', description: 'הילה גדולה ומנצנצת מעל הראש - אגדי!', price: 2000, type: 'legendary' },
        { id: 'galaxy_trail', name: '🌌 שובל גלקסיה', description: 'שובל של כוכבים וגלקסיות - אגדי!', price: 1500, type: 'legendary', grantItem: 'galaxy_trail' },
        
        // VEHICLES - New category!
        { id: 'basic_car', name: '🚗 רכב בסיסי', description: 'רכב בסיסי לנסיעה מהירה ואיסוף פריטים!', price: 500, type: 'vehicle' },
        { id: 'sports_car', name: '🏎️ רכב ספורט מהיר', description: 'רכב מהיר וצבעוני לנסיעה מרגשת!', price: 1200, type: 'vehicle' },
        { id: 'luxury_car', name: '🚘 רכב יוקרה', description: 'רכב מפואר עם אפקטים מיוחדים!', price: 2500, type: 'vehicle' }
      ];

      // Collectible cosmetics database (gifts on the map) - including birthday items
      const itemCatalog = [
        { id: 'crown_hat', name: '👑 כתר', slot: 'hat', icon: '👑', desc: 'כתר זהב מלכותי' },
        { id: 'wizard_hat', name: '🧙‍♂️ כובע קוסם', slot: 'hat', icon: '🎩', desc: 'כובע קסמים' },
        { id: 'top_hat', name: '🎩 צילינדר', slot: 'hat', icon: '🎩', desc: 'כובע צילינדר' },
        
        // Birthday hats
        { id: 'birthday_hat_1', name: '🎂 כובע יום הולדת 1', slot: 'hat', icon: '🎂', desc: 'כובע יום הולדת מיוחד עם נרות!' },
        { id: 'birthday_hat_2', name: '🎉 כובע יום הולדת 2', slot: 'hat', icon: '🎉', desc: 'כובע יום הולדת עם קונפטי!' },
        { id: 'party_hat', name: '🥳 כובע מסיבה', slot: 'hat', icon: '🥳', desc: 'כובע מסיבה צבעוני' },
        
        { id: 'red_cape', name: '🦸‍♂️ גלימה אדומה', slot: 'back', icon: '🧣', desc: 'גלימה מתנפנפת' },
        { id: 'angel_wings', name: '🪽 כנפי מלאך', slot: 'back', icon: '🪽', desc: 'כנפיים לבנות' },
        
        // Birthday balloons (back slot)
        { id: 'birthday_balloons', name: '🎈 בלוני יום הולדת', slot: 'back', icon: '🎈', desc: 'חבורת בלונים צבעוניים מאחור!' },
        { id: 'heart_balloons', name: '💖 בלוני לב', slot: 'back', icon: '💖', desc: 'בלונים בצורת לב' },
        
        { id: 'blue_boots', name: '👟 נעלי כחול', slot: 'feet', icon: '👟', desc: 'ריצה חלקה' },
        { id: 'green_boots', name: '🥾 נעלי ירוק', slot: 'feet', icon: '🥾', desc: 'צעדים ירוקים' },
        { id: 'cool_glasses', name: '🕶 משקפיים', slot: 'face', icon: '🕶️', desc: 'נראה קול' },
        { id: 'red_glasses', name: '👓 משקפיים אדומות', slot: 'face', icon: '👓', desc: 'מראה אדום' },
        
        // Birthday shirts (new chest slot)
        { id: 'birthday_shirt_1', name: '🎂 חולצת יום הולדת 1', slot: 'chest', icon: '👕', desc: 'חולצה עם עוגת יום הולדת!' },
        { id: 'birthday_shirt_2', name: '🎁 חולצת יום הולדת 2', slot: 'chest', icon: '👕', desc: 'חולצה עם מתנות!' },
        { id: 'party_shirt', name: '🥳 חולצת מסיבה', slot: 'chest', icon: '👕', desc: 'חולצה צבעונית למסיבה' },
        
        { id: 'spark_trail', name: '✨ שובל נצנצים', slot: 'effect', icon: '✨', desc: 'שובל נוצץ' },
        { id: 'blue_trail', name: '💙 שובל כחול', slot: 'effect', icon: '💙', desc: 'שובל כחול' },
        { id: 'fire_trail', name: '🔥 שובל אש', slot: 'effect', icon: '🔥', desc: 'שובל אש' },
        { id: 'confetti_trail', name: '🎊 שובל קונפטי', slot: 'effect', icon: '🎊', desc: 'שובל קונפטי לחגיגה!' },
        
        // RARE ITEMS - from shop
        { id: 'dragon_wings', name: '🐉 כנפי דרקון', slot: 'back', icon: '🐉', desc: 'כנפים שחורות ואדומות - נדיר!' },
        { id: 'rainbow_trail', name: '🌈 שובל קשת', slot: 'effect', icon: '🌈', desc: 'שובל משתנה צבעים - נדיר!' },
        { id: 'crown_royal', name: '👑 כתר מלכותי', slot: 'hat', icon: '👑', desc: 'כתר בצבע זהב עם יהלומים - נדיר!' },
        { id: 'shadow_cloak', name: '🧥 גלימת צללים', slot: 'back', icon: '🧥', desc: 'גלימה שחורה עם אפקטים - נדיר!' },
        { id: 'golden_boots', name: '🥿 נעלי זהב', slot: 'feet', icon: '🥿', desc: 'נעליים זהובות מנצנצות - נדיר!' },
        { id: 'laser_glasses', name: '🔴 משקפי לייזר', slot: 'face', icon: '🔴', desc: 'משקפים עם קרני לייזר - נדיר!' },
        
        // LEGENDARY ITEMS - from shop
        { id: 'mega_halo', name: '✨ הילה מגה', slot: 'hat', icon: '✨', desc: 'הילה גדולה ומנצנצת מעל הראש - אגדי!' },
        { id: 'galaxy_trail', name: '🌌 שובל גלקסיה', slot: 'effect', icon: '🌌', desc: 'שובל של כוכבים וגלקסיות - אגדי!' }
      ];

      // Collectibles placed in world (gift boxes with a specific item) - including birthday items
      let collectibles = [
        { id: 'gift1', itemId: 'crown_hat', x: 700,  y: 700,   picked: false },
        { id: 'gift2', itemId: 'red_cape',  x: 1500, y: 1200,  picked: false },
        { id: 'gift3', itemId: 'blue_boots',x: 2100, y: 1600,  picked: false },
        { id: 'gift4', itemId: 'cool_glasses', x: 1100, y: 1800, picked: false },
        { id: 'gift5', itemId: 'wizard_hat', x: 1900, y: 900,  picked: false },
        { id: 'gift6', itemId: 'spark_trail', x: 2400, y: 1300, picked: false },
        
        // Birthday collectibles
        { id: 'birthday_gift1', itemId: 'birthday_hat_1', x: 3500, y: 800, picked: false },
        { id: 'birthday_gift2', itemId: 'birthday_hat_2', x: 600, y: 2800, picked: false },
        { id: 'birthday_gift3', itemId: 'party_hat', x: 2800, y: 600, picked: false },
        { id: 'birthday_gift4', itemId: 'birthday_balloons', x: 1800, y: 3400, picked: false },
        { id: 'birthday_gift5', itemId: 'heart_balloons', x: 3200, y: 2200, picked: false },
        { id: 'birthday_gift6', itemId: 'birthday_shirt_1', x: 400, y: 1500, picked: false },
        { id: 'birthday_gift7', itemId: 'birthday_shirt_2', x: 3600, y: 1800, picked: false },
        { id: 'birthday_gift8', itemId: 'party_shirt', x: 1200, y: 500, picked: false },
        { id: 'birthday_gift9', itemId: 'confetti_trail', x: 2600, y: 3800, picked: false },
        
        // Additional rare collectibles
        { id: 'rare_gift1', itemId: 'crown_royal', x: 3800, y: 3800, picked: false },
        { id: 'rare_gift2', itemId: 'dragon_wings', x: 200, y: 200, picked: false },
        { id: 'rare_gift3', itemId: 'shadow_cloak', x: 3900, y: 400, picked: false },
        { id: 'rare_gift4', itemId: 'golden_boots', x: 400, y: 3600, picked: false },
        { id: 'rare_gift5', itemId: 'laser_glasses', x: 3400, y: 3200, picked: false },
        { id: 'legendary_gift1', itemId: 'mega_halo', x: 2000, y: 2000, picked: false },
        { id: 'legendary_gift2', itemId: 'galaxy_trail', x: 100, y: 3900, picked: false },
        { id: 'legendary_gift3', itemId: 'rainbow_trail', x: 3700, y: 100, picked: false }
      ];

      // Coin pickups system
      const COIN_VALUE = 50;
      const MAX_COINS = 15;
      let coinsOnMap = []; // {id, x, y}
      let coinIdSeq = 1;
      let coinSpawnTimer = 0; // seconds until next spawn

      function spawnCoin() {
        const margin = 80;
        const r = 10; // coin radius must match drawCoins
        for (let attempt = 0; attempt < 40; attempt++) {
          const x = Math.random() * (world.width - margin*2) + margin;
          const y = Math.random() * (world.height - margin*2) + margin;
          if (!isCoinOverObstacle(x, y, r)) {
            coinsOnMap.push({ id: 'coin'+(coinIdSeq++), x, y });
            return;
          }
        }
        // If no valid spot found after attempts, skip this spawn
      }
      function isCoinOverObstacle(x, y, r) {
        for (const rect of obstacles) {
          const cx = clamp(x, rect.x, rect.x + rect.w);
          const cy = clamp(y, rect.y, rect.y + rect.h);
          const dx = x - cx;
          const dy = y - cy;
          if (Math.hypot(dx, dy) < r + 2) return true; // small padding
        }
        return false;
      }

      // Pickup floating messages
      const pickupLayer = document.getElementById('pickupLayer');
      function showPickupText(text, screenX, screenY) {
        const el = document.createElement('div');
        el.className = 'pickup-text';
        el.textContent = text;
        el.style.left = `${screenX}px`;
        el.style.top = `${screenY}px`;
        pickupLayer.appendChild(el);
        let a = 1, y = screenY;
        const start = performance.now();
        function anim(t){
          const d = (t - start)/1000;
          y -= 30*d; a = Math.max(0, 1 - d);
          el.style.top = `${y}px`;
          el.style.opacity = a.toFixed(2);
          if (d < 1.2) requestAnimationFrame(anim); else el.remove();
        }
        requestAnimationFrame(anim);
      }

      adminBtn.addEventListener('click', () => {
        adminMode = !adminMode;
        adminBtn.setAttribute('aria-pressed', String(adminMode));
        adminBtn.classList.toggle('active', adminMode);
        
        if (adminMode) {
          // Give admin coins only if not received before
          if (!hasReceivedAdminCoins) {
            const bonusCoins = 10000;
            coins += bonusCoins;
            hasReceivedAdminCoins = true;
            showPickupText(`מצב אדמין פעיל! +${bonusCoins} 💰`, innerWidth/2, 120);
          } else {
            showPickupText('מצב אדמין פעיל! ✨', innerWidth/2, 120);
          }
          
          // Set admin level to 57
          playerLevel = MAX_LEVEL;
          currentLevelProgress = 1.0; // Max level progress
          showPickupText('🎉 עלית לרמה 57 - אדמין! 🎉', innerWidth/2, 180);
          
        } else {
          // Reset coins to 100 when disabling admin
          coins = 100;
          hasReceivedAdminCoins = false;
          showPickupText('מצב אדמין כבוי - חזרת ל-100 מטבעות', innerWidth/2, 120);
          
          // Reset level to 1
          playerLevel = 1;
          currentLevelProgress = 0.0; // Reset progress
          showPickupText('💵 חזרת לרמה 1', innerWidth/2, 180);
        }
        
        coinCountEl.textContent = coins.toString();
        updateLevelDisplay(); // Update level display when toggling admin
        
        // Always update profile immediately when toggling admin
        if (profileModal.classList.contains('open')) {
          renderProfile();
        }
      });
      
      // Explorer button handler
      explorerBtn.addEventListener('click', () => {
        explorerMode = !explorerMode;
        explorerBtn.setAttribute('aria-pressed', String(explorerMode));
        explorerBtn.classList.toggle('active', explorerMode);
        
        if (explorerMode) {
          // Give explorer coins only if not received before
          if (!hasReceivedExplorerCoins) {
            coins = 5100; // Set to exactly 5100 (5000 bonus + original 100)
            hasReceivedExplorerCoins = true;
            showPickupText('מצב סייר פעיל! קיבלת 5000 מטבעות! 💰', innerWidth/2, 200);
          } else {
            showPickupText('מצב סייר פעיל! 🗺️', innerWidth/2, 200);
          }
          
          // Show the message button for explorer
          explorerMessageBtn.style.display = 'block';
          showPickupText('עכשיו אתה יכול לשלוח הודעות גלובליות! 📢', innerWidth/2, 250);
          
        } else {
          // Reset coins to 100 when disabling explorer mode
          coins = 100;
          hasReceivedExplorerCoins = false;
          
          // Hide the message button
          explorerMessageBtn.style.display = 'none';
          
          showPickupText('מצב סייר כבוי - חזרת ל-100 מטבעות', innerWidth/2, 200);
        }
        
        coinCountEl.textContent = coins.toString();
        
        // Update profile immediately when toggling explorer
        if (profileModal.classList.contains('open')) {
          renderProfile();
        }
      });
      
      // Explorer Message Button handler
      explorerMessageBtn.addEventListener('click', () => {
        if (explorerMode) {
          globalMessageModal.classList.add('open');
          globalMessageInput.focus();
        } else {
          showPickupText('רק סייר יכול לשלוח הודעות גלובליות!', innerWidth/2, innerHeight/2);
        }
      });
      
      // Global Message Modal handlers
      closeGlobalMessageBtn.addEventListener('click', () => {
        globalMessageModal.classList.remove('open');
      });
      
      sendGlobalMessageBtn.addEventListener('click', () => {
        const messageText = globalMessageInput.value.trim();
        console.log('Trying to send message:', messageText, 'Explorer mode:', explorerMode);
        
        if (!messageText) {
          showPickupText('אנא הקלד הודעה!', innerWidth/2, innerHeight/2);
          return;
        }
        
        if (!explorerMode) {
          showPickupText('רק סייר יכול לשלוח הודעות גלובליות!', innerWidth/2, innerHeight/2);
          return;
        }
        
        // Send the message
        sendGlobalMessage(messageText);
        
        // Clear input and close modal
        globalMessageInput.value = '';
        globalMessageModal.classList.remove('open');
      });
      
      dismissGlobalMessageBtn.addEventListener('click', () => {
        hideGlobalMessage();
      });
      
      // Handle Enter key in global message input
      globalMessageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendGlobalMessageBtn.click();
        }
      });
      
      // Close global message modal when clicking outside
      globalMessageModal.addEventListener('click', (e) => {
        if (e.target === globalMessageModal) {
          globalMessageModal.classList.remove('open');
        }
      });
      
      // Trade modal handlers
      closeTradeBtn.addEventListener('click', () => tradeModal.classList.remove('open'));
      
      // Profile modal handlers
      coinsDisplay.addEventListener('click', () => {
        renderProfile();
        profileModal.classList.add('open');
      });
      closeProfileBtn.addEventListener('click', () => profileModal.classList.remove('open'));
      
      // Equipment selection modal handlers
      closeEquipmentBtn.addEventListener('click', () => equipmentModal.classList.remove('open'));
      
      // Close equipment modal when clicking outside
      equipmentModal.addEventListener('click', (e) => {
        if (e.target === equipmentModal) {
          equipmentModal.classList.remove('open');
        }
      });
      
      // Close modals with ESC key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (globalMessageModal.classList.contains('open')) {
            globalMessageModal.classList.remove('open');
          } else if (equipmentModal.classList.contains('open')) {
            equipmentModal.classList.remove('open');
          } else if (profileModal.classList.contains('open')) {
            profileModal.classList.remove('open');
          }
        }
      });
      
      // Global Message Functions
      function sendGlobalMessage(message) {
        console.log('sendGlobalMessage called with:', message);
        
        if (!explorerMode) {
          console.log('Explorer mode is off, cannot send message');
          showPickupText('רק סייר יכול לשלוח הודעות גלובליות!', innerWidth/2, innerHeight/2);
          return;
        }
        
        console.log('Displaying global message...');
        
        // Display the global message immediately
        displayGlobalMessage(message);
        
        // Show confirmation to sender with delay
        setTimeout(() => {
          showPickupText('ההודעה נשלחה לכל השחקנים! 📢', innerWidth/2, 150);
        }, 500);
      }
      
      function displayGlobalMessage(message) {
        console.log('displayGlobalMessage called with:', message);
        
        // Ensure elements exist
        if (!globalMessageDisplay || !globalMessageText) {
          console.error('Global message elements not found!');
          return;
        }
        
        // Create the full message with sender name
        const playerName = player.name || 'ליאור1';
        const fullMessage = `🗺️ הודעת סייר מ - ${playerName}:\n${message}`;
        
        // Set the message text
        globalMessageText.style.whiteSpace = 'pre-line'; // Allow line breaks
        globalMessageText.textContent = fullMessage;
        console.log('Message text set to:', globalMessageText.textContent);
        
        // Reset any existing classes
        globalMessageDisplay.classList.remove('hide', 'show');
        
        // Force a reflow
        globalMessageDisplay.offsetHeight;
        
        // Show the banner
        globalMessageDisplay.classList.add('show');
        console.log('Global message display shown');
        
        // Play notification sound if audio manager is available
        if (audioManager && audioManager.createBeep) {
          try {
            audioManager.createBeep(800, 0.2, 'sine');
            setTimeout(() => audioManager.createBeep(1000, 0.2, 'sine'), 200);
            setTimeout(() => audioManager.createBeep(1200, 0.3, 'sine'), 400);
          } catch (e) {
            console.log('Audio notification failed:', e);
          }
        }
      }
      
      function hideGlobalMessage() {
        globalMessageDisplay.classList.add('hide');
        globalMessageDisplay.classList.remove('show');
        
        // Remove the element after animation
        setTimeout(() => {
          globalMessageDisplay.classList.remove('hide');
        }, 300);
      }
      
      function renderProfile() {
        // Update player name
        playerNameDisplay.textContent = player.name;
        playerNameDisplay.className = 'player-name' + (adminMode ? ' admin' : '');
        
        // Update avatar display
        avatarDisplay.className = 'avatar-display' + (adminMode ? ' admin' : '');
        
        // Update status - show both admin and explorer status
        let statusText = 'שחקן רגיל';
        if (adminMode) {
          statusText = 'אדמין ממונה';
        } else if (explorerMode) {
          statusText = 'סייר';
        }
        playerStatusDisplay.textContent = statusText;
        
        // Update stats
        const statLevel = document.getElementById('statLevel');
        const statXP = document.getElementById('statXP');
        
        if (statLevel) statLevel.textContent = playerLevel.toString();
        if (statXP) {
          if (playerLevel >= MAX_LEVEL) {
            statXP.textContent = 'MAX';
          } else {
            const currentPercent = Math.floor(currentLevelProgress * 100);
            statXP.textContent = currentPercent + '%';
          }
        }
        
        statCoins.textContent = coins.toString();
        statItems.textContent = ownedItems.size.toString();
        statVehicle.textContent = playerVehicle ? getVehicleName(playerVehicle) : 'אין';
        statAdmin.textContent = adminMode ? 'כן' : 'לא';
        
        // Update equipment slots
        updateEquipmentDisplay();
        
        // Update player preview
        updatePlayerPreview();
      }
      
      function getVehicleName(vehicleId) {
        const vehicleNames = {
          'basic_car': '🚗 רכב בסיסי',
          'sports_car': '🏎️ רכב ספורט',
          'luxury_car': '🚘 רכב יוקרה'
        };
        return vehicleNames[vehicleId] || vehicleId;
      }
      
      function updateEquipmentDisplay() {
        const slots = ['hat', 'face', 'chest', 'back', 'feet', 'effect'];
        
        for (const slot of slots) {
          const slotEl = document.getElementById('equip' + slot.charAt(0).toUpperCase() + slot.slice(1));
          const equippedItemId = equipped[slot];
          
          // Remove any existing click listeners
          slotEl.replaceWith(slotEl.cloneNode(true));
          const newSlotEl = document.getElementById('equip' + slot.charAt(0).toUpperCase() + slot.slice(1));
          
          if (equippedItemId) {
            const item = itemCatalog.find(it => it.id === equippedItemId);
            if (item) {
              newSlotEl.classList.add('equipped');
              newSlotEl.querySelector('.equipment-slot-icon').textContent = item.icon;
              newSlotEl.querySelector('.equipment-slot-name').textContent = getSlotName(slot);
              // Extract just the Hebrew text from the name
              const itemDisplayName = item.name.split(' ').slice(1).join(' ') || item.name;
              newSlotEl.querySelector('.equipment-slot-empty').textContent = itemDisplayName;
            }
          } else {
            newSlotEl.classList.remove('equipped');
            newSlotEl.querySelector('.equipment-slot-name').textContent = getSlotName(slot);
            newSlotEl.querySelector('.equipment-slot-empty').textContent = 'ריק';
          }
          
          // Add click listener to open equipment selection
          newSlotEl.addEventListener('click', () => {
            openEquipmentSelection(slot);
          });
        }
      }
      
      function getSlotName(slot) {
        const slotNames = {
          'hat': 'כובע',
          'face': 'פנים',
          'chest': 'חזה',
          'back': 'גב',
          'feet': 'רגליים',
          'effect': 'אפקט'
        };
        return slotNames[slot] || slot;
      }
      
      function updatePlayerPreview() {
        const canvas = document.getElementById('playerCanvas');
        if (!canvas) return;
        
        const profileCtx = canvas.getContext('2d');
        
        // Clear canvas
        profileCtx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set up canvas for player drawing
        profileCtx.save();
        profileCtx.translate(canvas.width/2, canvas.height - 50); // Center horizontally, bottom of canvas
        profileCtx.scale(1.5, 1.5); // Make player bigger in profile
        
        // Draw the player using the same code from the main game
        drawPlayerInProfile(profileCtx, 0, -60); // Position player in canvas
        
        profileCtx.restore();
        
        // Update glow effect on canvas container based on mode
        const avatarEl = document.getElementById('avatarDisplay');
        if (adminMode) {
          avatarEl.style.background = 'linear-gradient(135deg, #ffd700, #ffb300)';
          avatarEl.style.boxShadow = '0 8px 24px rgba(255, 215, 0, 0.4), 0 0 20px rgba(255, 215, 0, 0.3)';
        } else if (explorerMode) {
          avatarEl.style.background = 'linear-gradient(135deg, #ffffff, #f0f8ff)';
          avatarEl.style.boxShadow = '0 8px 24px rgba(255, 255, 255, 0.6), 0 0 20px rgba(255, 255, 255, 0.4)';
        } else {
          avatarEl.style.background = 'linear-gradient(135deg, #f0f8ff, #e6f3ff)';
          avatarEl.style.boxShadow = '0 8px 24px rgba(78, 205, 196, 0.3)';
        }
      }
      
      // Helper function for rounded rectangles (used in clothing)
      function roundRect(ctx, x, y, w, h, r, fillStyle, strokeStyle, lineWidth) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
        
        if (fillStyle) {
          ctx.fillStyle = fillStyle;
          ctx.fill();
        }
        
        if (strokeStyle) {
          ctx.strokeStyle = strokeStyle;
          ctx.lineWidth = lineWidth || 1;
          ctx.stroke();
        }
      }
      
      // Simplified player drawing function for profile (based on the main drawPlayer function)
      function drawPlayerInProfile(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        
        // Player dimensions (same as main game)
        const torsoWidth = 18;
        const bodyLen = 32;
        const armLen = 20;
        const legLen = 26;
        
        // Draw legs first (behind body)
        ctx.strokeStyle = '#ffd5b4'; // skin color for legs
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        const hipX = 0, hipY = 12;
        
        // left leg
        ctx.beginPath();
        ctx.moveTo(hipX - 4, hipY);
        ctx.lineTo(hipX - 6, hipY + legLen);
        ctx.stroke();
        
        // left foot
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(hipX - 6, hipY + legLen + 2, 7, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // right leg
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(hipX + 4, hipY);
        ctx.lineTo(hipX + 6, hipY + legLen);
        ctx.stroke();
        
        // right foot
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(hipX + 6, hipY + legLen + 2, 7, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw torso with muscle definition
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(0, (-bodyLen/2 + hipY) / 2, torsoWidth/2 + 2, (hipY + bodyLen/2) / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Chest muscle definition
        ctx.fillStyle = 'rgba(212, 165, 116, 0.25)';
        ctx.beginPath();
        ctx.ellipse(-3, -bodyLen/2 + 8, 3, 4, -0.1, 0, Math.PI);
        ctx.ellipse(3, -bodyLen/2 + 8, 3, 4, 0.1, 0, Math.PI);
        ctx.fill();
        
        // Shoulders (detailed like main player)
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(0, -bodyLen/2 + 6, torsoWidth/2 + 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Left shoulder muscle
        ctx.beginPath();
        ctx.ellipse(-8, -bodyLen/2 + 8, 3, 5, -0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right shoulder muscle
        ctx.beginPath();
        ctx.ellipse(8, -bodyLen/2 + 8, 3, 5, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw clothing with equipped items
        drawClothingWithEquipment(ctx, hipY);
        
        // Draw equipped shoes or default pants bottom
        if (!equipped.feet) {
          // Default pants continuation (only if no special shoes)
          ctx.fillStyle = '#2d3436';
          ctx.fillRect(-10, hipY, 9, 18);
          ctx.fillRect(1, hipY, 9, 18);
        } else {
          // Custom pants/legs to match shoes
          drawCustomLeggings(ctx, hipY);
        }
        
        // Draw arms
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        const shoulderY = -bodyLen/2 + 8;
        
        // left arm
        ctx.beginPath();
        ctx.moveTo(-8, shoulderY);
        const leftArmEndX = -8 + Math.cos(1.2) * armLen;
        const leftArmEndY = shoulderY + Math.sin(1.2) * armLen;
        ctx.lineTo(leftArmEndX, leftArmEndY);
        ctx.stroke();
        
        // left hand with fingers
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.arc(leftArmEndX, leftArmEndY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Left hand fingers
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        for (let f = 0; f < 5; f++) {
          const fingerAngle = 1.2 + (f - 2) * 0.2;
          const fingerLength = 2;
          const fingerStartX = leftArmEndX + Math.cos(1.2 + Math.PI/2) * (f - 2) * 1;
          const fingerStartY = leftArmEndY + Math.sin(1.2 + Math.PI/2) * (f - 2) * 1;
          const fingerEndX = fingerStartX + Math.cos(fingerAngle) * fingerLength;
          const fingerEndY = fingerStartY + Math.sin(fingerAngle) * fingerLength;
          
          ctx.beginPath();
          ctx.moveTo(fingerStartX, fingerStartY);
          ctx.lineTo(fingerEndX, fingerEndY);
          ctx.stroke();
        }
        
        // right arm
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(8, shoulderY);
        const rightArmEndX = 8 + Math.cos(1.2) * armLen;
        const rightArmEndY = shoulderY + Math.sin(1.2) * armLen;
        ctx.lineTo(rightArmEndX, rightArmEndY);
        ctx.stroke();
        
        // right hand with fingers
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.arc(rightArmEndX, rightArmEndY, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Right hand fingers
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        for (let f = 0; f < 5; f++) {
          const fingerAngle = 1.2 + (f - 2) * 0.2;
          const fingerLength = 2;
          const fingerStartX = rightArmEndX + Math.cos(1.2 + Math.PI/2) * (f - 2) * 1;
          const fingerStartY = rightArmEndY + Math.sin(1.2 + Math.PI/2) * (f - 2) * 1;
          const fingerEndX = fingerStartX + Math.cos(fingerAngle) * fingerLength;
          const fingerEndY = fingerStartY + Math.sin(fingerAngle) * fingerLength;
          
          ctx.beginPath();
          ctx.moveTo(fingerStartX, fingerStartY);
          ctx.lineTo(fingerEndX, fingerEndY);
          ctx.stroke();
        }
        
        // neck
        const neckTop = -bodyLen/2 - 6;
        const headY = -bodyLen/2 - 16;
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(0, (neckTop + headY + 8) / 2, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // hair (behind head)
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.ellipse(0, headY - 3, 18, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // bangs/fringe
        ctx.beginPath();
        ctx.arc(-8, headY - 12, 4, 0, Math.PI);
        ctx.arc(-2, headY - 14, 5, 0, Math.PI);
        ctx.arc(4, headY - 13, 4, 0, Math.PI);
        ctx.arc(10, headY - 11, 3, 0, Math.PI);
        ctx.fill();
        
        // head (skin)
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.arc(0, headY, 16, 0, Math.PI * 2);
        ctx.fill();
        
        // eyes
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(-5, headY - 4, 2.5, 0, Math.PI * 2);
        ctx.arc(5, headY - 4, 2.5, 0, Math.PI * 2);
        ctx.fill();
        
        // eye pupils
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-5, headY - 4, 1.5, 0, Math.PI * 2);
        ctx.arc(5, headY - 4, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // eye shine
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-4.5, headY - 4.5, 0.5, 0, Math.PI * 2);
        ctx.arc(5.5, headY - 4.5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // nose
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, headY - 2);
        ctx.lineTo(-1, headY + 1);
        ctx.moveTo(0, headY - 2);
        ctx.lineTo(1, headY + 1);
        ctx.stroke();
        
        // mouth (smile)
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, headY + 2, 4, 0.2, Math.PI - 0.2);
        ctx.stroke();
        
        // Draw equipped items
        drawEquippedInProfile(ctx, headY);
        
        // admin halo
        if (adminMode) {
          ctx.save();
          ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
          ctx.shadowBlur = 18;
          const grad = ctx.createLinearGradient(-20, headY - 26, 20, headY - 26);
          grad.addColorStop(0, '#ffef9e');
          grad.addColorStop(0.5, '#ffd700');
          grad.addColorStop(1, '#ffef9e');
          ctx.strokeStyle = grad;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.ellipse(0, headY - 18, 22, 8, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        
        // explorer halo (white)
        if (explorerMode) {
          ctx.save();
          ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
          ctx.shadowBlur = 20;
          const gradWhite = ctx.createLinearGradient(-20, headY - 26, 20, headY - 26);
          gradWhite.addColorStop(0, '#f0f8ff');
          gradWhite.addColorStop(0.5, '#ffffff');
          gradWhite.addColorStop(1, '#f0f8ff');
          ctx.strokeStyle = gradWhite;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.ellipse(0, headY - 18, 22, 8, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        
        ctx.restore();
      }
      
      // Draw equipped items on the profile player - more realistic positioning
      function drawEquippedInProfile(ctx, headY) {
        // Back items (wings, cape) - draw first (behind player)
        if (equipped.back) {
          const item = itemCatalog.find(it => it.id === equipped.back);
          if (item) {
            ctx.save();
            drawBackItemRealistic(ctx, item, headY);
            ctx.restore();
          }
        }
        
        // Chest clothing - integrate with shirt drawing
        if (equipped.chest) {
          const item = itemCatalog.find(it => it.id === equipped.chest);
          if (item) {
            ctx.save();
            drawChestItemRealistic(ctx, item);
            ctx.restore();
          }
        }
        
        // Hat - position correctly on head
        if (equipped.hat) {
          const item = itemCatalog.find(it => it.id === equipped.hat);
          if (item) {
            ctx.save();
            drawHatRealistic(ctx, item, headY);
            ctx.restore();
          }
        }
        
        // Face accessories (glasses, etc.) - over face
        if (equipped.face) {
          const item = itemCatalog.find(it => it.id === equipped.face);
          if (item) {
            ctx.save();
            drawFaceItemRealistic(ctx, item, headY);
            ctx.restore();
          }
        }
        
        // Feet - replace default shoes
        if (equipped.feet) {
          const item = itemCatalog.find(it => it.id === equipped.feet);
          if (item) {
            ctx.save();
            drawFeetRealistic(ctx, item);
            ctx.restore();
          }
        }
        
        // Effect - magical aura around player
        if (equipped.effect) {
          const item = itemCatalog.find(it => it.id === equipped.effect);
          if (item) {
            ctx.save();
            drawEffectRealistic(ctx, item, headY);
            ctx.restore();
            
            // Draw quick mission indicator if this NPC is the target
            if (currentQuickMission && quickMissionNPC && quickMissionNPC.id === npc.id) {
              ctx.save();
              ctx.translate(sx, sy - 80);
              
              // Pulsing arrow animation
              const pulseTime = performance.now() * 0.005;
              const pulse = Math.sin(pulseTime) * 0.3 + 0.7;
              ctx.globalAlpha = pulse;
              
              // Arrow background circle
              ctx.fillStyle = '#ff6b35';
              ctx.beginPath();
              ctx.arc(0, 0, 20 * pulse, 0, Math.PI * 2);
              ctx.fill();
              
              // Arrow pointing down
              ctx.fillStyle = '#fff';
              ctx.beginPath();
              ctx.moveTo(0, -8);
              ctx.lineTo(-6, -2);
              ctx.lineTo(-3, -2);
              ctx.lineTo(-3, 6);
              ctx.lineTo(3, 6);
              ctx.lineTo(3, -2);
              ctx.lineTo(6, -2);
              ctx.closePath();
              ctx.fill();
              
              // Mission type icon
              ctx.fillStyle = '#fff';
              ctx.font = '14px Arial';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              const missionIcons = {
                visit: '👥',
                delivery: '📦',
                help: '🤝',
                chat: '💬'
              };
              const icon = missionIcons[currentQuickMission.type] || '⚡';
              ctx.fillText(icon, 0, -25, 16);
              
              ctx.restore();
            }
          }
        }
      }
      
      // Realistic drawing functions for each item type
      function drawHatRealistic(ctx, item, headY) {
        if (item.id.includes('crown_royal')) {
          // Royal crown with special effects
          ctx.save();
          ctx.fillStyle = '#ffd700';
          ctx.font = 'bold 32px Arial';
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
          ctx.shadowBlur = 15;
          ctx.fillText('👑', 0, headY - 25);
          
          // Royal gems sparkle effect
          const time = performance.now() * 0.005;
          ctx.fillStyle = '#ffffff';
          ctx.font = '8px Arial';
          for (let i = 0; i < 3; i++) {
            const sparkleX = Math.cos(time + i * 2) * 15;
            const sparkleY = headY - 30 + Math.sin(time * 2 + i) * 5;
            ctx.fillText('✨', sparkleX, sparkleY);
          }
          ctx.restore();
          
        } else if (item.id.includes('mega_halo')) {
          // Mega halo with pulsing effect
          const time = performance.now() * 0.003;
          const pulseSize = 28 + Math.sin(time * 4) * 4;
          
          ctx.save();
          ctx.globalAlpha = 0.8 + Math.sin(time * 3) * 0.2;
          ctx.font = `bold ${pulseSize}px Arial`;
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(255, 255, 255, 1)';
          ctx.shadowBlur = 20;
          ctx.fillStyle = '#ffffff';
          ctx.fillText('✨', 0, headY - 28);
          
          // Multiple halos for mega effect
          ctx.globalAlpha = 0.4;
          ctx.font = 'bold 20px Arial';
          ctx.fillText('✨', -20, headY - 25);
          ctx.fillText('✨', 20, headY - 25);
          ctx.restore();
          
        } else if (item.id.includes('crown') || item.id.includes('birthday_hat') || item.id.includes('party_hat')) {
          // Crown/hat sits on top of head
          ctx.fillStyle = '#ffd700';
          ctx.font = 'bold 26px Arial';
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
          ctx.shadowBlur = 8;
          ctx.fillText(item.icon, 0, headY - 22);
        } else {
          // Regular hat
          ctx.font = '24px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(item.icon, 0, headY - 20);
        }
      }
      
      function drawFaceItemRealistic(ctx, item, headY) {
        if (item.id.includes('laser_glasses')) {
          // Laser glasses with red beam effects
          ctx.save();
          ctx.font = '18px Arial';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#ff0000';
          ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
          ctx.shadowBlur = 10;
          ctx.fillText('🔴', 0, headY - 3);
          
          // Laser beams
          const time = performance.now() * 0.01;
          ctx.strokeStyle = `rgba(255, 0, 0, ${0.6 + Math.sin(time) * 0.3})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-8, headY - 3);
          ctx.lineTo(-25, headY - 3);
          ctx.moveTo(8, headY - 3);
          ctx.lineTo(25, headY - 3);
          ctx.stroke();
          ctx.restore();
          
        } else if (item.id.includes('glasses')) {
          // Regular glasses
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.globalAlpha = 0.9;
          ctx.fillText(item.icon, 0, headY - 3);
        } else {
          // Other face accessories
          ctx.font = '16px Arial';
          ctx.textAlign = 'center';
          ctx.globalAlpha = 0.9;
          ctx.fillText(item.icon, 0, headY - 2);
        }
      }
      
      function drawChestItemRealistic(ctx, item) {
        // This will be handled in the main clothing drawing section
        // since chest items replace the default shirt
      }
      
      function drawBackItemRealistic(ctx, item, headY) {
        if (item.id.includes('dragon_wings')) {
          // Dragon wings with fire effects
          ctx.save();
          ctx.font = 'bold 32px Arial';
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
          ctx.shadowBlur = 15;
          
          // Draw dragon wings with animation
          const time = performance.now() * 0.003;
          const wingFlap = Math.sin(time * 2) * 2;
          
          ctx.fillStyle = '#8b0000';
          ctx.fillText('🐉', -22 + wingFlap, headY + 5); // Left wing
          ctx.fillText('🐉', 22 - wingFlap, headY + 5);  // Right wing
          
          // Fire particles around dragon wings
          ctx.font = '12px Arial';
          ctx.fillStyle = '#ff4500';
          for (let i = 0; i < 4; i++) {
            const fireX = -25 + i * 15 + Math.sin(time * 4 + i) * 3;
            const fireY = headY + 12 + Math.cos(time * 3 + i) * 2;
            ctx.globalAlpha = 0.7 + Math.sin(time * 5 + i) * 0.3;
            ctx.fillText('🔥', fireX, fireY);
          }
          ctx.restore();
          
        } else if (item.id.includes('shadow_cloak')) {
          // Shadow cloak with dark effects
          ctx.save();
          ctx.font = 'bold 30px Arial';
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
          ctx.shadowBlur = 20;
          
          const time = performance.now() * 0.002;
          ctx.globalAlpha = 0.7 + Math.sin(time * 3) * 0.2;
          ctx.fillStyle = '#1a1a1a';
          ctx.fillText('🧥', 0, headY + 18);
          
          // Shadow particles
          ctx.font = '16px Arial';
          ctx.fillStyle = '#333';
          for (let i = 0; i < 6; i++) {
            const shadowX = Math.cos(time * 2 + i * 1.05) * 25;
            const shadowY = headY + 15 + Math.sin(time * 1.5 + i * 0.8) * 8;
            ctx.globalAlpha = 0.3 + Math.sin(time * 4 + i) * 0.2;
            ctx.fillText('•', shadowX, shadowY);
          }
          ctx.restore();
          
        } else if (item.id.includes('wings')) {
          // Angel wings spread out from back
          ctx.font = 'bold 28px Arial';
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
          ctx.shadowBlur = 10;
          
          // Draw wings slightly behind and spread out
          ctx.fillText('🦅', -18, headY + 8); // Left wing
          ctx.fillText('🦅', 18, headY + 8);  // Right wing
        } else if (item.id.includes('balloons')) {
          // Balloons float above and behind
          ctx.font = '20px Arial';
          ctx.textAlign = 'center';
          
          // Multiple balloons at different positions
          ctx.fillText('🎈', -12, headY - 25);
          ctx.fillText('🎈', 8, headY - 30);
          ctx.fillText('🎈', 0, headY - 35);
          
          // Balloon strings
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(-12, headY - 20);
          ctx.lineTo(-8, headY + 5);
          ctx.moveTo(8, headY - 25);
          ctx.lineTo(4, headY + 5);
          ctx.moveTo(0, headY - 30);
          ctx.lineTo(0, headY + 5);
          ctx.stroke();
        } else {
          // Other back items (cape, etc.)
          ctx.font = '22px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(item.icon, 0, headY + 15); // Behind shoulders
        }
      }
      
      function drawFeetRealistic(ctx, item) {
        // Draw realistic shoes that replace default feet
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 4;
        
        // Position shoes at foot level
        ctx.fillText(item.icon, -6, 42); // Left foot
        ctx.fillText(item.icon, 6, 42);  // Right foot
      }
      
      function drawEffectRealistic(ctx, item, headY) {
        const time = performance.now() * 0.003;
        
        if (item.id.includes('trail')) {
          // Magical trail effect around player
          ctx.globalAlpha = 0.6 + Math.sin(time * 2) * 0.2;
          ctx.font = '32px Arial';
          ctx.textAlign = 'center';
          
          // Create floating effect particles
          for (let i = 0; i < 5; i++) {
            const angle = (time + i * 1.26) % (Math.PI * 2);
            const radius = 25 + Math.sin(time * 3 + i) * 8;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius + headY - 10;
            
            ctx.save();
            ctx.globalAlpha = (0.3 + Math.sin(time * 4 + i) * 0.2);
            ctx.fillText(item.icon, x, y);
            ctx.restore();
          }
        } else {
          // Static magical effect
          ctx.globalAlpha = 0.7 + Math.sin(time * 3) * 0.2;
          ctx.font = '28px Arial';
          ctx.textAlign = 'center';
          ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
          ctx.shadowBlur = 12;
          ctx.fillText(item.icon, 0, headY + 5);
        }
      }
      
      // Draw clothing with equipped chest items
      function drawClothingWithEquipment(ctx, hipY) {
        // Chest/Shirt (check for equipped chest item first)
        if (equipped.chest) {
          if (equipped.chest === 'birthday_shirt_1') {
            // Birthday shirt with cake design - more detailed
            const gradient = ctx.createLinearGradient(-12, -16, 12, 10);
            gradient.addColorStop(0, '#ff6b9d');
            gradient.addColorStop(1, '#ff8fab');
            roundRect(ctx, -12, -16, 24, 26, 6, gradient, 'rgba(0,0,0,0.15)', 2);
            
            // Detailed cake design
            ctx.fillStyle = '#ffd700';
            roundRect(ctx, -6, -10, 12, 8, 2, '#ffd700');
            
            // Cake layers
            ctx.fillStyle = '#ffecb3';
            ctx.fillRect(-5, -8, 10, 2);
            ctx.fillStyle = '#fff8e1';
            ctx.fillRect(-4, -6, 8, 2);
            
            // Candles
            ctx.fillStyle = '#fff';
            ctx.fillRect(-2, -14, 1, 4);
            ctx.fillRect(1, -14, 1, 4);
            
            // Flames
            ctx.fillStyle = '#ff4757';
            ctx.beginPath();
            ctx.arc(-1.5, -14, 0.8, 0, Math.PI * 2);
            ctx.arc(1.5, -14, 0.8, 0, Math.PI * 2);
            ctx.fill();
            
          } else if (equipped.chest === 'birthday_shirt_2') {
            // Gift boxes shirt - more detailed
            const gradient = ctx.createLinearGradient(-12, -16, 12, 10);
            gradient.addColorStop(0, '#4ecdc4');
            gradient.addColorStop(1, '#26d0ce');
            roundRect(ctx, -12, -16, 24, 26, 6, gradient, 'rgba(0,0,0,0.15)', 2);
            
            // Multiple gift boxes
            drawGiftBox(ctx, -7, -12, 4, 4, '#ffd700', '#ff4757');
            drawGiftBox(ctx, 2, -10, 3, 3, '#e74c3c', '#ffd700');
            drawGiftBox(ctx, -2, -6, 3, 3, '#9b59b6', '#2ecc71');
            
          } else if (equipped.chest === 'party_shirt') {
            // Colorful party shirt with confetti pattern
            const gradient = ctx.createRadialGradient(0, -8, 5, 0, -8, 15);
            gradient.addColorStop(0, '#ff6b9d');
            gradient.addColorStop(0.3, '#ffeaa7');
            gradient.addColorStop(0.6, '#4ecdc4');
            gradient.addColorStop(1, '#a29bfe');
            roundRect(ctx, -12, -16, 24, 26, 6, gradient, 'rgba(0,0,0,0.15)', 2);
            
            // Confetti pattern
            const confettiColors = ['#fff', '#ff4757', '#74b9ff', '#00d2d3', '#feca57'];
            for (let i = 0; i < 12; i++) {
              const x = (i % 4 - 1.5) * 5;
              const y = -12 + Math.floor(i / 4) * 4;
              ctx.fillStyle = confettiColors[i % confettiColors.length];
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(Math.random() * Math.PI);
              ctx.fillRect(-1, -1, 2, 2);
              ctx.restore();
            }
          }
        } else {
          // Enhanced default shirt
          const gradient = ctx.createLinearGradient(-12, -16, 12, 10);
          gradient.addColorStop(0, '#4a90e2');
          gradient.addColorStop(1, '#357abd');
          roundRect(ctx, -12, -16, 24, 26, 6, gradient, 'rgba(0,0,0,0.15)', 2);
          
          // Shirt details (collar, buttons)
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.fillRect(-1, -15, 2, 8); // Button line
          
          // Buttons
          ctx.fillStyle = '#fff';
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(0, -13 + i * 4, 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // Helper function to draw gift boxes
      function drawGiftBox(ctx, x, y, w, h, boxColor, ribbonColor) {
        // Box
        ctx.fillStyle = boxColor;
        ctx.fillRect(x, y, w, h);
        
        // Ribbon
        ctx.strokeStyle = ribbonColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Horizontal ribbon
        ctx.moveTo(x, y + h/2);
        ctx.lineTo(x + w, y + h/2);
        // Vertical ribbon
        ctx.moveTo(x + w/2, y);
        ctx.lineTo(x + w/2, y + h);
        ctx.stroke();
        
        // Bow on top
        ctx.fillStyle = ribbonColor;
        ctx.beginPath();
        ctx.arc(x + w/2, y, 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Custom leggings to match special shoes
      function drawCustomLeggings(ctx, hipY) {
        const feetItem = itemCatalog.find(it => it.id === equipped.feet);
        
        if (feetItem && feetItem.id.includes('boots')) {
          // Tucked-in pants for boots
          ctx.fillStyle = '#2d3436';
          ctx.fillRect(-10, hipY, 9, 15);
          ctx.fillRect(1, hipY, 9, 15);
          
          // Boot tops
          ctx.fillStyle = '#8b4513';
          ctx.fillRect(-10, hipY + 15, 9, 3);
          ctx.fillRect(1, hipY + 15, 9, 3);
          
        } else if (feetItem && feetItem.id.includes('golden')) {
          // Special golden leggings
          const gradient = ctx.createLinearGradient(-10, hipY, 10, hipY + 18);
          gradient.addColorStop(0, '#2d3436');
          gradient.addColorStop(0.7, '#f39c12');
          gradient.addColorStop(1, '#ffd700');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(-10, hipY, 9, 18);
          ctx.fillRect(1, hipY, 9, 18);
          
        } else {
          // Regular pants
          ctx.fillStyle = '#2d3436';
          ctx.fillRect(-10, hipY, 9, 18);
          ctx.fillRect(1, hipY, 9, 18);
        }
      }
      
      // Equipment selection functions
      function openEquipmentSelection(slot) {
        currentEquipmentSlot = slot;
        
        // Update modal title
        const slotNames = {
          'hat': { name: 'כובע', icon: '👑' },
          'face': { name: 'פנים', icon: '👓' },
          'chest': { name: 'חזה', icon: '👕' },
          'back': { name: 'גב', icon: '🦸‍♂️' },
          'feet': { name: 'רגליים', icon: '👟' },
          'effect': { name: 'אפקט', icon: '✨' }
        };
        
        const slotInfo = slotNames[slot];
        equipmentSlotIcon.textContent = slotInfo.icon;
        equipmentSlotName.textContent = slotInfo.name;
        
        // Render equipment options
        renderEquipmentOptions(slot);
        
        // Show modal
        equipmentModal.classList.add('open');
      }
      
      function renderEquipmentOptions(slot) {
        equipmentOptionsEl.innerHTML = '';
        
        // Get all items for this slot
        const slotItems = itemCatalog.filter(item => item.slot === slot);
        
        // Add remove option if something is equipped
        if (equipped[slot]) {
          const removeBtn = document.createElement('button');
          removeBtn.className = 'remove-equipment-btn';
          removeBtn.innerHTML = '🗑️ הסר פריט';
          removeBtn.addEventListener('click', () => {
            const currentItem = itemCatalog.find(it => it.id === equipped[slot]);
            equipped[slot] = null;
            updateEquipmentDisplay();
            updatePlayerPreview();
            equipmentModal.classList.remove('open');
            
            // Show confirmation message
            if (currentItem) {
              const itemDisplayName = currentItem.name.split(' ').slice(1).join(' ') || currentItem.name;
              showPickupText(`✖️ הוסרת: ${itemDisplayName}`, innerWidth/2, innerHeight/2 - 50);
            }
            
            // Auto-save
            saveGame();
          });
          equipmentOptionsEl.appendChild(removeBtn);
        }
        
        // Add each item option
        for (const item of slotItems) {
          const option = document.createElement('div');
          option.className = 'equipment-option';
          
          const isOwned = ownedItems.has(item.id);
          const isEquipped = equipped[slot] === item.id;
          
          if (isEquipped) {
            option.classList.add('equipped');
          } else if (!isOwned) {
            option.classList.add('locked');
          }
          
          const icon = document.createElement('div');
          icon.className = 'equipment-option-icon';
          icon.textContent = item.icon;
          
          const name = document.createElement('div');
          name.className = 'equipment-option-name';
          name.textContent = item.name.split(' ').slice(1).join(' ') || item.name;
          
          const status = document.createElement('div');
          status.className = 'equipment-option-status';
          if (isEquipped) {
            status.textContent = 'לבוש';
          } else if (isOwned) {
            status.textContent = 'לחץ ללבישה';
          } else {
            status.textContent = 'לא נאסף';
          }
          
          option.appendChild(icon);
          option.appendChild(name);
          option.appendChild(status);
          
          // Add click handler
          if (isOwned && !isEquipped) {
            option.addEventListener('click', () => {
              equipped[slot] = item.id;
              updateEquipmentDisplay();
              updatePlayerPreview();
              equipmentModal.classList.remove('open');
              
              // Show confirmation message
              const itemDisplayName = item.name.split(' ').slice(1).join(' ') || item.name;
              showPickupText(`✨ לבשת: ${itemDisplayName}`, innerWidth/2, innerHeight/2 - 50);
              
              // Auto-save
              saveGame();
            });
          } else if (!isOwned) {
            option.addEventListener('click', () => {
              showPickupText('פריט לא נאסף! חפש אותו במשחק או קנה בחנות', innerWidth/2, innerHeight/2);
            });
          }
          
          equipmentOptionsEl.appendChild(option);
        }
      }

      // Shop UI handlers (basic open/close and render items)
      shopBtn.addEventListener('click', () => {
        renderShop();
        shopModal.classList.add('open');
      });
      closeShopBtn.addEventListener('click', () => shopModal.classList.remove('open'));
      
      // Audio button handler
      let audioEnabled = false;
      audioBtn.addEventListener('click', async () => {
        if (!audioEnabled) {
          await audioManager.init();
          audioManager.startBackgroundMusic();
          audioEnabled = true;
          audioBtn.classList.add('active');
          showPickupText('🎵 מוזיקה וצלילים פעילים!', innerWidth/2, innerHeight/2);
        } else {
          // Toggle audio (simple implementation)
          audioManager.volume = audioManager.volume > 0 ? 0 : 0.5;
          audioManager.musicVolume = audioManager.musicVolume > 0 ? 0 : 0.3;
          audioBtn.classList.toggle('active', audioManager.volume > 0);
          const status = audioManager.volume > 0 ? 'פעיל' : 'כבוי';
          showPickupText(`🎵 אודיו ${status}`, innerWidth/2, innerHeight/2);
        }
      });

      function renderShop() {
        coinCountEl.textContent = coins.toString();
        // Update profile if it's open
        if (profileModal.classList.contains('open')) {
          renderProfile();
        }
        shopItemsEl.innerHTML = '';
        for (const it of shopItems) {
          const row = document.createElement('div');
          row.className = 'shop-item';
          const left = document.createElement('div'); left.className = 'item-info';
          left.innerHTML = `<div class=\"item-name\">${it.name}</div><div class=\"item-description\">${it.description}</div>`;
          const right = document.createElement('div');
          const price = document.createElement('span'); price.className = 'item-price'; price.textContent = `🪙 ${it.price}`;
          const btn = document.createElement('button'); btn.className = 'buy-btn';
          const alreadyOwned = it.grantItem ? ownedItems.has(it.grantItem) : false;
          btn.textContent = alreadyOwned ? 'נרכש' : 'קנייה';
          btn.disabled = alreadyOwned || coins < it.price;
          btn.addEventListener('click', () => {
            if (coins >= it.price && !alreadyOwned) {
              coins -= it.price;
              coinCountEl.textContent = coins.toString();
              // Apply effects / grants
              if (it.id === 'speed_boost') { speedMult = Math.min(speedMult + 0.2, 2.0); }
              if (it.id === 'mega_halo') { adminMode = true; }
              if (it.grantItem) { ownedItems.add(it.grantItem); }
              
              // Vehicle purchases
              if (it.type === 'vehicle') {
                playerVehicle = it.id;
                vehicleX = player.x + 50; // spawn vehicle nearby
                vehicleY = player.y;
                showPickupText('רכב נרכש! לחץ E לעלייה 🚗', innerWidth/2, innerHeight/2 - 100);
              }
              renderShop();
              renderInventory();
              // Auto-save when buying items
              saveGame();
            }
          });
          right.appendChild(price); right.appendChild(btn);
          row.appendChild(left); row.appendChild(right);
          shopItemsEl.appendChild(row);
        }
      }

      // Inventory UI handlers
      inventoryBtn.addEventListener('click', () => {
        renderInventory();
        invModal.classList.add('open');
      });
      closeInvBtn.addEventListener('click', () => invModal.classList.remove('open'));

      function renderInventory() {
        invGrid.innerHTML = '';
        const bySlot = { hat: [], face: [], back: [], feet: [], effect: [], chest: [] };
        for (const it of itemCatalog) bySlot[it.slot].push(it);
        const order = ['hat','face','chest','back','feet','effect'];
        for (const slot of order) {
          for (const it of bySlot[slot]) {
            const card = document.createElement('div'); card.className = 'inv-item';
            const icon = document.createElement('div'); icon.className = 'inv-icon'; icon.textContent = it.icon;
            const info = document.createElement('div'); info.className = 'inv-info';
            info.innerHTML = `<div class="inv-name">${it.name}</div><div class="inv-slot">${slotLabel(slot)}</div>`;
            const btn = document.createElement('button'); btn.className = 'equip-btn';
            const owned = ownedItems.has(it.id);
            const isEquipped = equipped[slot] === it.id;
            if (!owned) {
              btn.textContent = 'לא נאסף';
              btn.disabled = true;
            } else if (isEquipped) {
              btn.textContent = 'הסר';
              btn.classList.add('unequip');
              btn.addEventListener('click', () => { 
                equipped[slot] = null; 
                renderInventory();
                // Update profile if it's open
                if (profileModal.classList.contains('open')) {
                  updatePlayerPreview();
                  updateEquipmentDisplay();
                }
              });
            } else {
              btn.textContent = 'לבש';
              btn.addEventListener('click', () => { 
                equipped[slot] = it.id; 
                renderInventory();
                // Update profile if it's open
                if (profileModal.classList.contains('open')) {
                  updatePlayerPreview();
                  updateEquipmentDisplay();
                }
              });
            }
            card.appendChild(icon); card.appendChild(info); card.appendChild(btn);
            invGrid.appendChild(card);
          }
        }
      }
      function slotLabel(slot){
        switch(slot){
          case 'hat': return 'ראש';
          case 'face': return 'פנים';
          case 'chest': return 'חזה';
          case 'back': return 'גב';
          case 'feet': return 'רגליים';
          case 'effect': return 'אפקט';
          default: return slot;
        }
      }

      let lastMessage = '';
      let messageTimer = 0;
      let messageWasAdmin = false; // Track if the message was sent in admin mode
      const MESSAGE_SHOW_TIME = 3;

      sendBtn.addEventListener('click', sendChat);
      homeBtn.addEventListener('click', goHome);
      emojiBtn.addEventListener('click', toggleEmojiPanel);
      danceBtn.addEventListener('click', toggleDancePanel);
      
      // Quick Mission System
      const quickMissionBtn = document.getElementById('quickMissionBtn');
      const quickMissionModal = document.getElementById('quickMissionModal');
      const closeQuickMissionBtn = document.getElementById('closeQuickMission');
      const currentQuickMissionDiv = document.getElementById('currentQuickMission');
      const quickMissionListDiv = document.getElementById('quickMissionList');
      const activeMissionTextDiv = document.getElementById('activeMissionText');
      const activeMissionTargetDiv = document.getElementById('activeMissionTarget');
      const cancelQuickMissionBtn = document.getElementById('cancelQuickMission');
      
      const missionTypes = {
        visit: {
          name: 'בקר אצל תושב',
          description: 'לך לבקר אצל {npc} שמחכה ליך',
          reward: { coins: 50, xp: 25 },
          messages: ['שלום! תודה שבאת לבקר!', 'איזה כיף לראות אותך!', 'היית חסר לי!']
        },
        delivery: {
          name: 'משלוח מהיר',
          description: 'העבר משלוח ל-{npc}',
          reward: { coins: 75, xp: 35 },
          messages: ['תודה על המשלוח!', 'היה חשוב לי!', 'אתה משלוח מושלם!']
        },
        help: {
          name: 'עזרה בבית',
          description: 'עזור ל-{npc} במשים בבית',
          reward: { coins: 100, xp: 50 },
          messages: ['תודה על העזרה!', 'לא הייתי מצליח בלעדיך!', 'אתה אדם טוב!']
        },
        chat: {
          name: 'שיחה ידידותית',
          description: 'שוחח עם {npc} שמרגיש בודד',
          reward: { coins: 40, xp: 20 },
          messages: ['תודה על השיחה!', 'היה חשוב לי לדבר!', 'אתה חבר טוב!']
        }
      };
      
      quickMissionBtn.addEventListener('click', () => {
        quickMissionModal.classList.add('open');
        updateQuickMissionModal();
      });
      
      closeQuickMissionBtn.addEventListener('click', () => {
        quickMissionModal.classList.remove('open');
      });
      
      cancelQuickMissionBtn.addEventListener('click', () => {
        currentQuickMission = null;
        quickMissionNPC = null;
        quickMissionBtn.classList.remove('active');
        showPickupText('משימה בוטלה', innerWidth/2, 150);
        updateQuickMissionModal();
      });
      
      // Close modal when clicking outside
      quickMissionModal.addEventListener('click', (e) => {
        if (e.target === quickMissionModal) {
          quickMissionModal.classList.remove('open');
        }
      });
      
      // Mission selection
      document.querySelectorAll('.mission-option').forEach(option => {
        option.addEventListener('click', () => {
          const missionType = option.getAttribute('data-mission');
          startQuickMission(missionType);
        });
      });
      
      function updateQuickMissionModal() {
        if (currentQuickMission) {
          currentQuickMissionDiv.style.display = 'block';
          quickMissionListDiv.style.display = 'none';
          
          const mission = missionTypes[currentQuickMission.type];
          activeMissionTextDiv.textContent = mission.description.replace('{npc}', quickMissionNPC.name);
          activeMissionTargetDiv.textContent = `יעד: לך ל-${quickMissionNPC.name} (בקואורדינטות ${Math.round(quickMissionNPC.x)}, ${Math.round(quickMissionNPC.y)})`;
        } else {
          currentQuickMissionDiv.style.display = 'none';
          quickMissionListDiv.style.display = 'block';
        }
      }
      
      function startQuickMission(missionType) {
        // Select random resident NPC
        const residents = npcs.filter(npc => npc.kind === 'resident');
        if (residents.length === 0) {
          showPickupText('אין תושבים זמינים', innerWidth/2, 150);
          return;
        }
        
        quickMissionNPC = residents[Math.floor(Math.random() * residents.length)];
        currentQuickMission = {
          type: missionType,
          startTime: Date.now()
        };
        
        quickMissionBtn.classList.add('active');
        const mission = missionTypes[missionType];
        showPickupText(`משימה חדשה: ${mission.name}!`, innerWidth/2, 150);
        quickMissionModal.classList.remove('open');
        updateQuickMissionModal();
      }
      
      function completeQuickMission(npc) {
        console.log('Trying to complete quick mission:', {
          currentQuickMission: currentQuickMission,
          quickMissionNPC: quickMissionNPC,
          targetNPC: npc.id,
          match: quickMissionNPC?.id === npc.id
        });
        
        if (!currentQuickMission || !quickMissionNPC || quickMissionNPC.id !== npc.id) {
          console.log('Quick mission completion failed - conditions not met');
          return false;
        }
        
        const mission = missionTypes[currentQuickMission.type];
        const randomMessage = mission.messages[Math.floor(Math.random() * mission.messages.length)];
        
        // Give rewards
        coins += mission.reward.coins;
        currentXP += mission.reward.xp;
        
        // Update UI
        coinCountEl.textContent = coins.toString();
        onEarnCoins(); // Check earn coins quests
        document.getElementById('currentXP').textContent = currentXP;
        
        // Check for level up
        while (currentXP >= requiredXP) {
          currentXP -= requiredXP;
          level++;
          requiredXP = Math.floor(requiredXP * 1.5);
          document.getElementById('levelCount').textContent = level;
          document.getElementById('requiredXP').textContent = requiredXP;
          showPickupText(`עלית רמה! רמה ${level} ✨`, innerWidth/2, 200);
        }
        
        // Update XP progress bar
        const xpProgress = (currentXP / requiredXP) * 100;
        document.getElementById('xpProgress').style.width = xpProgress + '%';
        document.getElementById('currentXP').textContent = currentXP;
        
        // Show completion message
        activeNpcDialog = { npcId: npc.id, text: randomMessage, timer: 3 };
        showPickupText(`משימה הושלמה! +${mission.reward.coins} מטבעות +${mission.reward.xp} XP`, innerWidth/2, innerHeight/3);
        
        // Play completion sound
        if (audioManager && audioManager.initialized) {
          audioManager.createBeep(800, 0.15, 'square');
          setTimeout(() => audioManager.createBeep(1000, 0.15, 'square'), 150);
          setTimeout(() => audioManager.createBeep(1200, 0.2, 'square'), 300);
        }
        
        // Reset mission
        currentQuickMission = null;
        quickMissionNPC = null;
        quickMissionBtn.classList.remove('active');
        
        // Auto-save
        saveGame();
        
        console.log('Quick mission completed successfully');
        return true;
      }
      
      // Emoji Button
      const emojiButtons = document.querySelectorAll('.emoji-btn');
      emojiButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const emoji = e.target.getAttribute('data-emoji');
          selectEmoji(emoji);
        });
      });
      
      // Add dance selection listeners
      const danceButtons = document.querySelectorAll('.dance-btn');
      danceButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const dance = e.target.getAttribute('data-dance');
          selectDance(dance);
        });
      });
      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendChat();
        } else if (e.key === 'Escape') {
          chatInput.blur();
        }
      });

      function sendChat() {
        const text = chatInput.value.trim();
        if (text) {
          lastMessage = text;
          messageTimer = MESSAGE_SHOW_TIME;
          messageWasAdmin = adminMode; // Remember if we were in admin mode when sending
          chatInput.value = '';
        }
        chatInput.blur();
      }
      
      function goHome() {
        const playerHouse = buildings.find(b => b.isPlayerHouse);
        if (!playerHouse) return;
        
        if (isInsideHouse) {
          // If already inside a house, exit first
          exitHouse();
          // Add a small delay before entering the player's house
          setTimeout(() => {
            enterHouse(playerHouse);
            showPickupText('חזרת הביתה! 🏠', innerWidth/2, innerHeight/2 - 50);
          }, 200);
        } else {
          // If outside, enter the player's house directly
          enterHouse(playerHouse);
          showPickupText('חזרת הביתה! 🏠', innerWidth/2, innerHeight/2 - 50);
        }
      }
      
      // Emoji system
      function toggleEmojiPanel() {
        emojiPanel.classList.toggle('open');
      }
      
      function selectEmoji(emoji) {
        // Send the emoji as a message
        lastMessage = emoji;
        messageTimer = MESSAGE_SHOW_TIME;
        messageWasAdmin = adminMode;
        
        // Close emoji panel
        emojiPanel.classList.remove('open');
        
        // Show floating text
        showPickupText(`שלחת: ${emoji}`, innerWidth/2, innerHeight/2 + 50);
      }
      
      // Dance system
      function toggleDancePanel() {
        dancePanel.classList.toggle('open');
        // Close emoji panel if open
        emojiPanel.classList.remove('open');
      }
      
      function selectDance(danceType) {
        if (danceType === 'stop') {
          stopDancing();
        } else {
          startDancing(danceType);
        }
        
        // Close dance panel
        dancePanel.classList.remove('open');
      }
      
      function startDancing(danceType) {
        if (!danceAnimations[danceType]) return;
        
        isDancing = true;
        currentDance = danceType;
        danceStartTime = performance.now();
        danceFrame = 0;
        
        // Show floating text with dance name
        const danceNames = {
          party: '🕺 מסיבה!',
          disco: '💃 דיסקו!',
          breakdance: '🤸 בריקדאנס!',
          salsa: '💃🏻 סלסה!',
          robot: '🤖 רובוט!',
          'hip-hop': '🕺🏻 היפ הופ!',
          ballet: '🩰 בלט!',
          tango: '👥 טנגו!',
          moonwalk: '🌙 מונווק!',
          floss: '💫 פלוס!',
          wave: '🌊 גל!',
          electric: '⚡ חשמלי!'
        };
        
        showPickupText(danceNames[danceType] || '💃 רוקד!', innerWidth/2, innerHeight/2 + 50);
      }
      
      function stopDancing() {
        isDancing = false;
        currentDance = null;
        danceFrame = 0;
        showPickupText('הפסקת לרקוד 🛑', innerWidth/2, innerHeight/2 + 50);
      }
      
      function updateDance() {
        if (!isDancing || !currentDance || !danceAnimations[currentDance]) return;
        
        const animation = danceAnimations[currentDance];
        const elapsed = (performance.now() - danceStartTime) / 1000;
        const frameTime = animation.speed;
        
        // Calculate current frame
        const currentFrameIndex = Math.floor(elapsed / frameTime) % animation.frames;
        if (currentFrameIndex !== danceFrame) {
          danceFrame = currentFrameIndex;
        }
      }
      
      function getDancePose() {
        if (!isDancing || !currentDance || !danceAnimations[currentDance]) {
          return 'normal';
        }
        
        const animation = danceAnimations[currentDance];
        return animation.poses[danceFrame] || 'normal';
      }
      
      // Close panels when clicking outside
      document.addEventListener('click', (e) => {
        if (!emojiPanel.contains(e.target) && e.target !== emojiBtn) {
          emojiPanel.classList.remove('open');
        }
        if (!dancePanel.contains(e.target) && e.target !== danceBtn) {
          dancePanel.classList.remove('open');
        }
      });
      
      // Trading System Functions
      function openTradeMenu(npc) {
        currentTradeNpc = npc;
        renderTrades();
        tradeModal.classList.add('open');
        const tradeText = 'מה תרצה להחליף?';
        activeNpcDialog = { npcId: npc.id, text: tradeText, timer: 3 };
        speechManager.speak(tradeText, npc.id);
      }
      
      function renderTrades() {
        if (!currentTradeNpc || !currentTradeNpc.trades) return;
        
        tradeOffersEl.innerHTML = '';
        const titleEl = document.getElementById('tradeTitle');
        titleEl.textContent = `🔄 החלפות עם ${currentTradeNpc.name}`;
        
        for (const trade of currentTradeNpc.trades) {
          const tradeDiv = document.createElement('div');
          tradeDiv.className = 'trade-offer';
          
          const canTrade = trade.wants.every(itemId => ownedItems.has(itemId));
          
          tradeDiv.innerHTML = `
            <div class="trade-info">
              <div class="trade-name">${trade.name}</div>
              <div class="trade-details">
                <div class="trade-items">
                  <span>אתה נותן:</span>
                  ${trade.wants.map(id => {
                    const item = itemCatalog.find(i => i.id === id);
                    const owned = ownedItems.has(id);
                    return `<span class="trade-item" style="${owned ? '' : 'color: #f44336;'}">${item ? item.name : id} ${owned ? '✓' : '✗'}</span>`;
                  }).join('')}
                </div>
                <div class="trade-arrow">↓</div>
                <div class="trade-items">
                  <span>אתה מקבל:</span>
                  ${trade.offers.map(id => {
                    const item = itemCatalog.find(i => i.id === id);
                    return `<span class="trade-item">${item ? item.name : id}</span>`;
                  }).join('')}
                </div>
              </div>
            </div>
            <button class="trade-btn" ${canTrade ? '' : 'disabled'} onclick="executeTrade('${currentTradeNpc.id}', ${currentTradeNpc.trades.indexOf(trade)})">
              ${canTrade ? 'חלופים!' : 'חסרים פריטים'}
            </button>
          `;
          
          tradeOffersEl.appendChild(tradeDiv);
        }
      }
      
      function executeTrade(npcId, tradeIndex) {
        const npc = npcs.find(n => n.id === npcId);
        if (!npc || !npc.trades || !npc.trades[tradeIndex]) return;
        
        const trade = npc.trades[tradeIndex];
        
        // Check if player has all required items
        const canTrade = trade.wants.every(itemId => ownedItems.has(itemId));
        if (!canTrade) {
          showPickupText('לא יש לך כל הפריטים!', innerWidth/2, innerHeight/2);
          return;
        }
        
        // Remove wanted items from player
        trade.wants.forEach(itemId => {
          ownedItems.delete(itemId);
          // Remove from equipped if it was equipped
          Object.keys(equipped).forEach(slot => {
            if (equipped[slot] === itemId) {
              equipped[slot] = null;
            }
          });
        });
        
        // Give offered items to player
        trade.offers.forEach(itemId => {
          ownedItems.add(itemId);
        });
        
        // Show success message
        showPickupText(`החלפה בוצעה! 🎉`, innerWidth/2, innerHeight/2);
        const thanksText = 'תודה על החליפים!';
        activeNpcDialog = { npcId: npc.id, text: thanksText, timer: 3 };
        speechManager.speak(thanksText, npc.id);
        
        // Update quest progress for trades
        onTradeCompleted();
        
        // Update displays
        renderTrades();
        renderInventory();
        
        // Close trade modal after a moment
        setTimeout(() => {
          tradeModal.classList.remove('open');
        }, 1500);
      }
      
      // Make executeTrade globally accessible
      window.executeTrade = executeTrade;
      
      // Vehicle functions
      function enterVehicle() {
        if (!playerVehicle) return;
        inVehicle = true;
        // Initialize vehicle position tracking
        lastVehiclePosition.x = player.x;
        lastVehiclePosition.y = player.y;
        showPickupText('נכנסת לרכב! לחץ E לירידה 🚗', innerWidth/2, innerHeight/2);
      }
      
      function exitVehicle() {
        if (!inVehicle) return;
        inVehicle = false;
        // Move player slightly away from vehicle
        player.x = vehicleX - 30;
        player.y = vehicleY;
        player.vx = 0;
        player.vy = 0;
        showPickupText('ירדת מהרכב! לחץ E לעלייה חזרה 🚶', innerWidth/2, innerHeight/2);
      }
      
      // Save System
      function saveGame() {
        const saveData = {
          coins: coins,
          ownedItems: Array.from(ownedItems),
          equipped: equipped,
          playerPosition: { x: player.x, y: player.y },
          adminMode: adminMode,
          explorerMode: explorerMode,
          hasReceivedExplorerCoins: hasReceivedExplorerCoins,
          speedMult: speedMult,
          zoomLevel: zoomLevel,
          collectibles: collectibles.map(c => ({ ...c })),
          // Vehicle data
          playerVehicle: playerVehicle,
          inVehicle: inVehicle,
          vehiclePosition: { x: vehicleX, y: vehicleY, angle: vehicleAngle },
          totalVehicleDistance: totalVehicleDistance,
          // Quest data
          questMapData: Array.from(questMap.entries()),
          timestamp: Date.now()
        };
        
        localStorage.setItem('virtualWorldSave', JSON.stringify(saveData));
        showPickupText('המשחק נשמר! 💾', innerWidth/2, 100);
      }
      
      function loadGame() {
        const saveData = localStorage.getItem('virtualWorldSave');
        if (!saveData) {
          console.log('לא נמצא שמירה');
          return false;
        }
        
        try {
          const data = JSON.parse(saveData);
          
          // Restore player data
          coins = data.coins || 100;
          ownedItems = new Set(data.ownedItems || []);
          equipped = data.equipped || { hat: null, back: null, feet: null, face: null, effect: null };
          
          // Restore player position
          if (data.playerPosition) {
            player.x = data.playerPosition.x;
            player.y = data.playerPosition.y;
          }
          
          // Restore game state
          adminMode = data.adminMode || false;
          explorerMode = data.explorerMode || false;
          hasReceivedExplorerCoins = data.hasReceivedExplorerCoins || false;
          speedMult = data.speedMult || 1.0;
          zoomLevel = data.zoomLevel || 1.0;
          
          // Restore collectibles
          if (data.collectibles) {
            collectibles = data.collectibles;
          }
          
          // Restore vehicle data
          if (data.playerVehicle) {
            playerVehicle = data.playerVehicle;
            inVehicle = data.inVehicle || false;
            if (data.vehiclePosition) {
              vehicleX = data.vehiclePosition.x;
              vehicleY = data.vehiclePosition.y;
              vehicleAngle = data.vehiclePosition.angle || 0;
            }
            // Initialize vehicle position tracking
            lastVehiclePosition.x = player.x;
            lastVehiclePosition.y = player.y;
          }
          
          // Update UI
          coinCountEl.textContent = coins.toString();
          adminBtn.setAttribute('aria-pressed', String(adminMode));
          adminBtn.classList.toggle('active', adminMode);
          explorerBtn.setAttribute('aria-pressed', String(explorerMode));
          explorerBtn.classList.toggle('active', explorerMode);
          
          // Show/hide explorer message button based on mode
          if (explorerMode) {
            explorerMessageBtn.style.display = 'block';
          } else {
            explorerMessageBtn.style.display = 'none';
          }
          
          showPickupText('משחק נטען! 🎉', innerWidth/2, 100);
          return true;
          
        } catch (error) {
          console.error('שגיאה בטעינת השמירה:', error);
          return false;
        }
      }
      
      function deleteSave() {
        localStorage.removeItem('virtualWorldSave');
        showPickupText('שמירה נמחקה! 🗑️', innerWidth/2, 100);
      }

      // Keyboard input
      const keys = {};
      const KEYMAP = {
        'KeyW': 'w', 'ArrowUp': 'w',
        'KeyS': 's', 'ArrowDown': 's',
        'KeyA': 'a',
        'KeyD': 'd',
        'ArrowLeft': 'rotL', 'ArrowRight': 'rotR',
        'ShiftLeft': 'shift', 'ShiftRight': 'shift',
        'KeyE': 'interact',
        'KeyT': 't',
        'Equal': 'zoomIn', 'NumpadAdd': 'zoomIn',
        'Minus': 'zoomOut', 'NumpadSubtract': 'zoomOut',
        'Digit0': 'zoomReset',
        'KeyP': 'adminToggle',
        'F5': 'saveGame',
        'F9': 'loadGame'
      };
      window.addEventListener('keydown', (e) => {
        // Don't handle game keys if user is typing in any input field
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
          activeElement === chatInput ||
          activeElement === globalMessageInput ||
          activeElement.tagName === 'INPUT' ||
          activeElement.tagName === 'TEXTAREA'
        );
        
        if (isTyping) {
          // Allow normal typing in input fields
          return;
        }
        
        if (KEYMAP[e.code]) {
          keys[KEYMAP[e.code]] = true;
          if (KEYMAP[e.code] === 't') {
            e.preventDefault();
            chatInput.focus();
            chatInput.select();
          }
          if (KEYMAP[e.code] === 'interact') {
            e.preventDefault();
            tryInteract();
          }
          if (KEYMAP[e.code] === 'zoomIn') {
            e.preventDefault();
            zoomIn();
          }
          if (KEYMAP[e.code] === 'zoomOut') {
            e.preventDefault();
            zoomOut();
          }
          if (KEYMAP[e.code] === 'zoomReset') {
            e.preventDefault();
            resetZoom();
          }
          if (KEYMAP[e.code] === 'adminToggle') {
            e.preventDefault();
            toggleAdminMode();
          }
          if (KEYMAP[e.code] === 'saveGame') {
            e.preventDefault();
            saveGame();
          }
          if (KEYMAP[e.code] === 'loadGame') {
            e.preventDefault();
            loadGame();
          }
          if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','PageUp','PageDown'].includes(e.code)) {
            e.preventDefault();
          }
        }
      });
      window.addEventListener('keyup', (e) => {
        // Don't handle key release if typing in any input field
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
          activeElement === chatInput ||
          activeElement === globalMessageInput ||
          activeElement.tagName === 'INPUT' ||
          activeElement.tagName === 'TEXTAREA'
        );
        
        if (isTyping) {
          return;
        }
        
        if (KEYMAP[e.code]) {
          keys[KEYMAP[e.code]] = false;
        }
      });

      // Mouse - Click to move target with cool effects
      let target = null; // {x, y} world coordinates where player should move
      
      // Click effects system
      let clickEffects = [];
      let lastClickTime = 0;
      let isDoubleClick = false;
      const DOUBLE_CLICK_TIME = 300; // milliseconds
      
      class ClickEffect {
        constructor(x, y, isDoubleClick = false) {
          this.x = x;
          this.y = y;
          this.worldX = x; // Store original world coordinates
          this.worldY = y;
          this.life = 1.0;
          this.maxLife = isDoubleClick ? 1.5 : 1.0;
          this.particles = [];
          this.rings = [];
          this.isDoubleClick = isDoubleClick;
          
          // Create ripple rings
          for (let i = 0; i < (isDoubleClick ? 4 : 2); i++) {
            this.rings.push({
              radius: 0,
              maxRadius: isDoubleClick ? 80 + i * 20 : 40 + i * 15,
              opacity: 1,
              color: isDoubleClick ? `hsl(${45 + i * 30}, 100%, 60%)` : `hsl(${120 + i * 60}, 70%, 50%)`,
              delay: i * 0.1
            });
          }
          
          // Create particles
          const particleCount = isDoubleClick ? 20 : 12;
          for (let i = 0; i < particleCount; i++) {
            const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
            const speed = isDoubleClick ? 150 + Math.random() * 100 : 80 + Math.random() * 60;
            this.particles.push({
              x: 0,
              y: 0,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1.0,
              size: isDoubleClick ? 3 + Math.random() * 3 : 2 + Math.random() * 2,
              color: isDoubleClick ? `hsl(${Math.random() * 60 + 20}, 100%, 70%)` : `hsl(${Math.random() * 120 + 100}, 80%, 60%)`
            });
          }
        }
        
        update(dt) {
          this.life -= dt / this.maxLife;
          
          // Update rings
          for (const ring of this.rings) {
            if (this.life > 1 - ring.delay) continue;
            const progress = Math.min(1, (1 - this.life - ring.delay) / (1 - ring.delay));
            ring.radius = ring.maxRadius * progress;
            ring.opacity = Math.max(0, 1 - progress);
          }
          
          // Update particles
          for (const particle of this.particles) {
            particle.x += particle.vx * dt;
            particle.y += particle.vy * dt;
            particle.life -= dt * (this.isDoubleClick ? 0.6 : 0.8);
            particle.vx *= 0.98; // friction
            particle.vy *= 0.98;
          }
          
          return this.life > 0;
        }
        
        draw(ctx, camX, camY) {
          const screenX = this.worldX - camX;
          const screenY = this.worldY - camY;
          
          ctx.save();
          
          // Draw rings
          for (const ring of this.rings) {
            if (ring.radius > 0 && ring.opacity > 0) {
              ctx.globalAlpha = ring.opacity;
              ctx.strokeStyle = ring.color;
              ctx.lineWidth = this.isDoubleClick ? 4 : 3;
              ctx.beginPath();
              ctx.arc(screenX, screenY, ring.radius, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
          
          // Draw particles
          for (const particle of this.particles) {
            if (particle.life > 0) {
              ctx.globalAlpha = Math.max(0, particle.life);
              ctx.fillStyle = particle.color;
              ctx.beginPath();
              ctx.arc(
                screenX + particle.x,
                screenY + particle.y,
                particle.size * particle.life,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
          }
          
          ctx.restore();
        }
      }
      
      function addClickEffect(worldX, worldY, isDoubleClick = false) {
        clickEffects.push(new ClickEffect(worldX, worldY, isDoubleClick));
      }
      
      function updateClickEffects(dt) {
        clickEffects = clickEffects.filter(effect => effect.update(dt));
      }
      
      function drawClickEffects(ctx, camX, camY) {
        for (const effect of clickEffects) {
          effect.draw(ctx, camX, camY);
        }
      }
      
      // Enhanced audio for clicks
      function playClickSound(isDoubleClick = false, surface = 'grass') {
        if (!audioManager.initialized) return;
        
        if (isDoubleClick) {
          // Double click - more energetic sound
          audioManager.createBeep(800, 0.1, 'square');
          setTimeout(() => audioManager.createBeep(1200, 0.1, 'square'), 50);
          setTimeout(() => audioManager.createBeep(1600, 0.15, 'sine'), 100);
        } else {
          // Single click - softer sound based on surface
          let freq, duration, type;
          switch(surface) {
            case 'grass':
              freq = 600; duration = 0.12; type = 'triangle';
              break;
            case 'road':
              freq = 800; duration = 0.1; type = 'square';
              break;
            case 'water':
              freq = 400; duration = 0.15; type = 'sine';
              break;
            default:
              freq = 700; duration = 0.1; type = 'triangle';
          }
          audioManager.createBeep(freq, duration, type);
        }
      }
      
      canvas.addEventListener('click', (e) => {
        // Don't move while typing in any input field
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
          activeElement === chatInput ||
          activeElement === globalMessageInput ||
          activeElement.tagName === 'INPUT' ||
          activeElement.tagName === 'TEXTAREA'
        );
        if (isTyping) return;
        
        // Double click detection
        const currentTime = Date.now();
        const timeSinceLastClick = currentTime - lastClickTime;
        isDoubleClick = timeSinceLastClick < DOUBLE_CLICK_TIME;
        lastClickTime = currentTime;
        
        const rect = canvas.getBoundingClientRect();
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        
        // Convert screen coordinates to world coordinates
        let camX, camY;
        
        if (isInsideHouse && currentHouse) {
          // Inside house - different coordinate system with zoom
          const interior = houseInteriors[currentHouse.id];
          const viewWidth = interior.width / zoomLevel;
          const viewHeight = interior.height / zoomLevel;
          camX = player.x - viewWidth / 2;
          camY = player.y - viewHeight / 2;
          
          const clickWorldX = (canvasX / zoomLevel) + camX;
          const clickWorldY = (canvasY / zoomLevel) + camY;
          
          // Check if clicked on exit area (door)
          if (clickWorldX > interior.width - 40 && clickWorldY > interior.height - 30) {
            exitHouse();
            return;
          }
          
          // Determine surface type for sound effect
          let surfaceType = 'grass';
          if (roads.some(road => 
            clickWorldX >= road.x && clickWorldX <= road.x + road.w &&
            clickWorldY >= road.y && clickWorldY <= road.y + road.h
          )) {
            surfaceType = 'road';
          }
          
          // Add visual and audio effects
          addClickEffect(clickWorldX, clickWorldY, isDoubleClick);
          playClickSound(isDoubleClick, surfaceType);
          
          // Set movement speed based on click type
          const speedMultiplier = isDoubleClick ? 2.5 : 1.0;
          
          target = {
            x: clickWorldX,
            y: clickWorldY,
            speedMultiplier: speedMultiplier,
            isDoubleClick: isDoubleClick
          };
          
          // Show feedback for double click
          if (isDoubleClick) {
            showPickupText('תנועה מהירה! ⚡', clickWorldX, clickWorldY - 20);
          }
        } else {
          // Outside - normal world coordinates with zoom
          const viewWidth = innerWidth / zoomLevel;
          const viewHeight = innerHeight / zoomLevel;
          camX = player.x - viewWidth / 2;
          camY = player.y - viewHeight / 2;
          
          const clickWorldX = (canvasX / zoomLevel) + camX;
          const clickWorldY = (canvasY / zoomLevel) + camY;
          
          // Check if clicked on a house
          const clickedBuilding = buildings.find(building => {
            return clickWorldX >= building.x && 
                   clickWorldX <= building.x + building.w &&
                   clickWorldY >= building.y && 
                   clickWorldY <= building.y + building.h &&
                   (building.enterable || building.isPlayerHouse);
          });
          
          if (clickedBuilding) {
            enterHouse(clickedBuilding);
            return;
          }
          
          // Add visual and audio effects inside house too
          addClickEffect(clickWorldX, clickWorldY, isDoubleClick);
          playClickSound(isDoubleClick, 'indoor');
          
          // Set movement speed based on click type
          const speedMultiplier = isDoubleClick ? 2.5 : 1.0;
          
          target = {
            x: clickWorldX,
            y: clickWorldY,
            speedMultiplier: speedMultiplier,
            isDoubleClick: isDoubleClick
          };
          
          // Show feedback for double click inside house
          if (isDoubleClick) {
            showPickupText('תנועה מהירה! ⚡', clickWorldX, clickWorldY - 20);
          }
        }
      });
      
      // Mouse wheel zoom
      canvas.addEventListener('wheel', (e) => {
        if (document.activeElement === chatInput) return;
        
        e.preventDefault();
        
        if (e.deltaY < 0) {
          zoomIn();
        } else {
          zoomOut();
        }
      });
      
      // Zoom functions
      function zoomIn() {
        const oldZoom = zoomLevel;
        zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
        if (zoomLevel !== oldZoom) {
          updateZoom();
          showPickupText(`זום: ${Math.round(zoomLevel * 100)}%`, innerWidth/2, 80);
        }
      }
      
      function zoomOut() {
        const oldZoom = zoomLevel;
        zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
        if (zoomLevel !== oldZoom) {
          updateZoom();
          showPickupText(`זום: ${Math.round(zoomLevel * 100)}%`, innerWidth/2, 80);
        }
      }
      
      function toggleAdminMode() {
        adminMode = !adminMode;
        adminBtn.setAttribute('aria-pressed', String(adminMode));
        adminBtn.classList.toggle('active', adminMode);
        
        if (adminMode) {
          // Give admin coins only if not received before
          if (!hasReceivedAdminCoins) {
            const bonusCoins = 10000;
            coins += bonusCoins;
            hasReceivedAdminCoins = true;
            showPickupText(`מצב אדמין פעיל! +${bonusCoins} 💰`, innerWidth/2, 120);
          } else {
            showPickupText('מצב אדמין פעיל! ✨', innerWidth/2, 120);
          }
        } else {
          // Reset coins to 100 when disabling admin
          coins = 100;
          hasReceivedAdminCoins = false;
          showPickupText('מצב אדמין כבוי - חזרת ל-100 מטבעות', innerWidth/2, 120);
        }
        
        coinCountEl.textContent = coins.toString();
      }
      
      function resetZoom() {
        if (zoomLevel !== 1.0) {
          zoomLevel = 1.0;
          updateZoom();
          showPickupText('זום אופס: 100%', innerWidth/2, 80);
        }
      }

      // Physics
      const ACCEL = 850;
      const FRICTION = 7.5;
      const MAX_SPEED = 260;
      const SPRINT_FACTOR = 1.4;
      let speedMult = 1.0; // increased by shop purchases

      // Loop
      let last = performance.now();
      function frame(t) {
        let dt = (t - last) / 1000;
        if (dt > 0.05) dt = 0.05;
        last = t;
        update(dt);
        draw();
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

      function onCoinCollected() {
        // increment progress for all active collect_coins quests
        let changed = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.type === 'collect_coins' && q.state === 'active') {
              if (q.progress < q.required) {
                q.progress++;
                changed = true;
                if (q.progress >= q.required) {
                  q.state = 'completed';
                }
              }
            }
          }
        }
        if (changed) updateQuestPanel();
      }
      function onVehicleDistanceTraveled(distance) {
        // increment progress for all active drive_distance quests
        let changed = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.type === 'drive_distance' && q.state === 'active') {
              if (q.progress < q.required) {
                q.progress += distance;
                changed = true;
                console.log(`Drive distance quest progress: ${Math.round(q.progress)}/${q.required} meters`);
                if (q.progress >= q.required) {
                  q.state = 'completed';
                  console.log('Drive distance quest completed!');
                }
              }
            }
          }
        }
        if (changed) updateQuestPanel();
      }
      
      function onVehicleCoinCollected() {
        // increment progress for all active collect_coins_vehicle quests
        let changed = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.type === 'collect_coins_vehicle' && q.state === 'active') {
              if (q.progress < q.required) {
                q.progress++;
                changed = true;
                console.log(`Vehicle coin quest progress: ${q.progress}/${q.required}`);
                if (q.progress >= q.required) {
                  q.state = 'completed';
                  console.log('Vehicle coin quest completed!');
                }
              }
            }
          }
        }
        if (changed) updateQuestPanel();
      }
      
      function onTradeCompleted() {
        // increment progress for all active complete_trades quests
        let changed = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.type === 'complete_trades' && q.state === 'active') {
              if (q.progress < q.required) {
                q.progress++;
                changed = true;
                console.log(`Trade quest progress: ${q.progress}/${q.required}`);
                if (q.progress >= q.required) {
                  q.state = 'completed';
                  console.log('Trade quest completed!');
                }
              }
            }
          }
        }
        if (changed) updateQuestPanel();
      }
      
      function onEarnCoins() {
        // Update progress for all active earn_coins quests based on current coins
        let changed = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.type === 'earn_coins' && q.state === 'active') {
              if (coins >= q.required && q.progress < q.required) {
                q.progress = coins;
                changed = true;
                console.log(`Earn coins quest progress: ${q.progress}/${q.required}`);
                if (q.progress >= q.required) {
                  q.state = 'completed';
                  console.log('Earn coins quest completed!');
                }
              }
            }
          }
        }
        if (changed) updateQuestPanel();
      }
      
      function onGiftCollected(itemId) {
        // increment progress for all active collect_gifts quests
        let changed = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.type === 'collect_gifts' && q.state === 'active') {
              if (q.progress < q.required) {
                q.progress++;
                changed = true;
                if (q.progress >= q.required) {
                  q.state = 'completed';
                }
              }
            }
            
            // Check for rare items quest
            if (q.type === 'collect_rare_items' && q.state === 'active' && itemId) {
              const item = itemCatalog.find(i => i.id === itemId);
              const rareItems = ['dragon_wings', 'rainbow_trail', 'crown_royal', 'shadow_cloak', 'golden_boots', 'laser_glasses'];
              if (item && rareItems.includes(itemId)) {
                if (q.progress < q.required) {
                  q.progress++;
                  changed = true;
                  if (q.progress >= q.required) {
                    q.state = 'completed';
                  }
                }
              }
            }
            
            // Check for legendary items quest
            if (q.type === 'collect_legendary_items' && q.state === 'active' && itemId) {
              const item = itemCatalog.find(i => i.id === itemId);
              const legendaryItems = ['mega_halo', 'galaxy_trail'];
              if (item && legendaryItems.includes(itemId)) {
                if (q.progress < q.required) {
                  q.progress++;
                  changed = true;
                  if (q.progress >= q.required) {
                    q.state = 'completed';
                  }
                }
              }
            }
            
            // Check for birthday gifts quest
            if (q.type === 'collect_birthday_gifts' && q.state === 'active' && itemId) {
              const birthdayItems = ['birthday_hat_1', 'birthday_hat_2', 'party_hat', 'birthday_balloons', 'heart_balloons', 'birthday_shirt_1', 'birthday_shirt_2', 'party_shirt', 'confetti_trail'];
              if (itemId && birthdayItems.includes(itemId)) {
                if (q.progress < q.required) {
                  q.progress++;
                  changed = true;
                  if (q.progress >= q.required) {
                    q.state = 'completed';
                  }
                }
              }
            }
          }
        }
        if (changed) updateQuestPanel();
      }
      
      function updateQuestCooldowns(dt) {
        let changed = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const quest of list) {
            if (quest.state === 'cooldown' && quest.cooldown > 0) {
              quest.cooldown -= dt;
              if (quest.cooldown <= 0) {
                console.log(`Quest ${quest.type} cooldown finished, now available`);
                quest.cooldown = 0;
                quest.state = 'offer';
                changed = true;
              }
            }
          }
        }
        if (changed) updateQuestPanel();
      }

      function update(dt) {
        // Update simple weather system
        updateWeather(dt);
        
        // Update click effects
        updateClickEffects(dt);
        
        // Update dance animations
        updateDance();
        
        // Update quest cooldowns
        updateQuestCooldowns(dt);
        
        // Update NPC walk animations
        for (const npc of npcs) {
          if (npc.kind === 'resident') {
            npc.walkTimer += dt;
            if (npc.walkTimer > 3) { // Change direction every 3 seconds
              npc.walkDirection = Math.random() * Math.PI * 2;
              npc.walkTimer = 0;
            }
            npc.walkStep += dt * 2; // Walking speed
          }
        }
        
        // Enhanced confetti update with twinkling
        for (const p of confetti){
          p.x += p.vx * dt; p.y += p.vy * dt; p.rot += p.vr * dt;
          p.twinkle += dt * 3;
          // wrap to top of plaza
          const dx = p.x - plaza.x; const dy = p.y - plaza.y;
          if (Math.hypot(dx,dy) > plaza.radius + 60 || p.y > plaza.y + 160){
            Object.assign(p, spawnConfetto());
          }
        }
        
        // Update floating sparkles
        for (let i = floatingSparkles.length - 1; i >= 0; i--) {
          const sparkle = floatingSparkles[i];
          sparkle.x += sparkle.vx * dt;
          sparkle.y += sparkle.vy * dt;
          sparkle.brightness = Math.sin(performance.now() * 0.001 * sparkle.twinkleSpeed) * 0.5 + 0.5;
          sparkle.life -= dt;
          
          // Wrap around world
          if (sparkle.x < 0) sparkle.x = world.width;
          if (sparkle.x > world.width) sparkle.x = 0;
          if (sparkle.y < 0) sparkle.y = world.height;
          if (sparkle.y > world.height) sparkle.y = 0;
          
          // Respawn if life expired
          if (sparkle.life <= 0) {
            Object.assign(sparkle, createSparkle());
          }
        }
        
        // Update house lights flickering
        for (const light of houseLights) {
          light.flickerTimer -= dt;
          if (light.flickerTimer <= 0) {
            light.on = Math.random() < 0.85; // 85% chance to be on
            light.flickerTimer = 0.5 + Math.random() * 2;
          }
        }
        
        // Update street lamp flickering
        for (const lamp of streetLamps) {
          if (lamp.flickering) {
            lamp.light = Math.sin(performance.now() * 0.01) > 0.3;
          }
        }

        // Update active NPC dialog timer
        if (activeNpcDialog && activeNpcDialog.timer > 0) {
          activeNpcDialog.timer -= dt;
          if (activeNpcDialog.timer < 0) activeNpcDialog.timer = 0;
        }
        // Update quest cooldowns
        let panelChanged = false;
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.state === 'cooldown') {
              q.cooldown -= dt;
              if (q.cooldown <= 0) {
                q.cooldown = 0;
                q.state = 'offer';
                panelChanged = true;
              }
            }
          }
        }
        if (panelChanged) updateQuestPanel();
        // Rotation with arrow keys - enhanced for vehicles
        const baseRotationSpeed = 3;
        const vehicleRotationMult = inVehicle ? 1.5 : 1.0; // Faster rotation in vehicle
        const rotationSpeed = baseRotationSpeed * vehicleRotationMult;
        if (keys.rotL) player.angle -= rotationSpeed * dt;
        if (keys.rotR) player.angle += rotationSpeed * dt;

        // Movement accelerations with enhanced double-click speed
        let ax = 0, ay = 0;
        if (target) {
          const dx = target.x - player.x;
          const dy = target.y - player.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist > 10) { // Stop when close enough to target
            const force = Math.min(dist / 100, 1); // Closer = slower approach
            const clickSpeedMultiplier = target.speedMultiplier || 1.0;
            const speedFactor = (keys.shift ? SPRINT_FACTOR : 1) * speedMult * clickSpeedMultiplier;
            ax += (dx / dist) * force * ACCEL * speedFactor;
            ay += (dy / dist) * force * ACCEL * speedFactor;
            
            // Play walking sounds more frequently for fast movement
            if (clickSpeedMultiplier > 1.5 && Math.random() < 0.3) {
              audioManager.playWalkSound('fast');
            }
          } else {
            // Reached target, stop moving
            target = null;
            player.vx *= 0.3; // Quick stop
            player.vy *= 0.3;
          }
        }

        // Keyboard movement - different behavior for vehicle vs walking
        if (inVehicle) {
          // Vehicle controls: W/S for forward/backward, A/D for turning
          let moveForward = 0;
          if (keys.w) moveForward = 1;  // Forward
          if (keys.s) moveForward = -1; // Backward
          
          // Vehicle turning
          const turnSpeed = 2.5; // Adjust turning sensitivity
          if (keys.a) player.angle -= turnSpeed * dt; // Turn left
          if (keys.d) player.angle += turnSpeed * dt; // Turn right
          
          if (moveForward !== 0) {
            // Move in the direction the vehicle is facing
            const dx = Math.cos(player.angle) * moveForward;
            const dy = Math.sin(player.angle) * moveForward;
            
            // Enhanced speed and acceleration for vehicles
            const vehicleAccelMult = 3.0;
            const vehicleSpeedMult = 2.5;
            const speedFactor = (keys.shift ? SPRINT_FACTOR : 1) * speedMult * vehicleSpeedMult;
            ax += dx * ACCEL * speedFactor * vehicleAccelMult;
            ay += dy * ACCEL * speedFactor * vehicleAccelMult;
          }
        } else {
          // Walking controls: WASD for absolute directions
          let dx = 0, dy = 0;
          if (keys.w) dy -= 1; // Up
          if (keys.s) dy += 1;  // Down  
          if (keys.a) dx -= 1;  // Left
          if (keys.d) dx += 1;  // Right
          
          if (dx !== 0 || dy !== 0) {
            // Normalize diagonal movement
            const len = Math.hypot(dx, dy);
            dx /= len;
            dy /= len;
            
            // Update player angle to face movement direction
            player.angle = Math.atan2(dy, dx);
            
            // Normal walking speed
            const speedFactor = (keys.shift ? SPRINT_FACTOR : 1) * speedMult;
            ax += dx * ACCEL * speedFactor;
            ay += dy * ACCEL * speedFactor;
          }
        }

        // Trail record for effects
        trail.push({x: player.x, y: player.y});
        if (trail.length > TRAIL_MAX) trail.shift();

        // Pickups: collect gifts when close
        for (const gift of collectibles) {
          if (gift.picked) continue;
          const d = Math.hypot(gift.x - player.x, gift.y - player.y);
          if (d < 36) {
            gift.picked = true;
            ownedItems.add(gift.itemId);
            // Show floating text at screen position
            const camX = player.x - innerWidth / 2;
            const camY = player.y - innerHeight / 2;
            const screenX = gift.x - camX;
            const screenY = gift.y - camY - 20;
            const item = itemCatalog.find(i => i.id === gift.itemId);
              showPickupText(`אספת: ${item ? item.name : 'חפץ'}`, screenX, screenY);
              audioManager.playPickupSound(); // Play pickup sound
              onGiftCollected(gift.itemId);
              renderInventory();
              // Auto-save when collecting items
              saveGame();
          }
        }

        // Coin spawn logic
        coinSpawnTimer -= dt;
        if (coinSpawnTimer <= 0 && coinsOnMap.length < MAX_COINS) {
          spawnCoin();
          coinSpawnTimer = 0.8 + Math.random() * 0.9; // next spawn in ~0.8-1.7s
        }

        // Coin collection
        if (coinsOnMap.length) {
          const camX = player.x - innerWidth / 2;
          const camY = player.y - innerHeight / 2;
          for (let i = coinsOnMap.length - 1; i >= 0; i--) {
            const c = coinsOnMap[i];
            const d = Math.hypot(c.x - player.x, c.y - player.y);
            if (d < 28) {
              coinsOnMap.splice(i, 1);
              coins += COIN_VALUE;
              coinCountEl.textContent = coins.toString();
              const sx = c.x - camX;
              const sy = c.y - camY - 12;
              showPickupText(`+${COIN_VALUE} 🪙`, sx, sy);
              audioManager.playCoinSound(); // Play coin sound
              onCoinCollected();
              onEarnCoins(); // Check earn coins quests
              
              // Check if collected while in vehicle for vehicle quest
              if (inVehicle) {
                onVehicleCoinCollected();
                showPickupText('מטבע נאסף ברכב! 🚗', sx, sy - 20);
              }
            }
          }
        }

        player.vx += ax * dt;
        player.vy += ay * dt;

        // Friction
        const v = Math.hypot(player.vx, player.vy);
        if (v > 0) {
          const drop = FRICTION * v * dt;
          const newV = Math.max(v - drop, 0);
          const scale = newV / v;
          player.vx *= scale; 
          player.vy *= scale;
        }
        
        // Clamp speed (higher max speed for vehicles)
        const v2 = Math.hypot(player.vx, player.vy);
        const vehicleMaxSpeedMult = inVehicle ? 3.5 : 1.0;
        const maxV = MAX_SPEED * (keys.shift ? SPRINT_FACTOR : 1) * speedMult * vehicleMaxSpeedMult;
        if (v2 > maxV) {
          const s = maxV / v2;
          player.vx *= s; 
          player.vy *= s;
        }

        // Integrate position
        player.x += player.vx * dt;
        player.y += player.vy * dt;
        
        // Update vehicle position if in vehicle
        if (inVehicle) {
          // Calculate distance traveled (only if we have valid previous position)
          const distanceTraveled = Math.hypot(player.x - lastVehiclePosition.x, player.y - lastVehiclePosition.y);
          
          // Only count reasonable distance (avoid teleportation errors)
          // Scale down the distance to make it more realistic (divide by 10)
          if (distanceTraveled < 100 && distanceTraveled > 0.1) {
            const scaledDistance = distanceTraveled / 10;
            totalVehicleDistance += scaledDistance;
            // Update drive distance quests
            onVehicleDistanceTraveled(scaledDistance);
          }
          
          // Update vehicle position
          vehicleX = player.x;
          vehicleY = player.y;
          vehicleAngle = player.angle;
          vehicleVx = player.vx;
          vehicleVy = player.vy;
        }
        
        // Always update last position for next calculation
        lastVehiclePosition.x = player.x;
        lastVehiclePosition.y = player.y;

        // Bounds
        if (isInsideHouse && currentHouse) {
          const interior = houseInteriors[currentHouse.id];
          // House interior bounds with wall collision
          player.x = Math.max(20 + player.radius, Math.min(interior.width - 20 - player.radius, player.x));
          player.y = Math.max(20 + player.radius, Math.min(interior.height - 20 - player.radius, player.y));
        } else {
          // World bounds
          player.x = Math.max(player.radius, Math.min(world.width - player.radius, player.x));
          player.y = Math.max(player.radius, Math.min(world.height - player.radius, player.y));
        }

        // Collisions: none (no blocking obstacles)

        // Walk cycle with sound
        const speed = Math.hypot(player.vx, player.vy);
        const stepSpeed = speed / MAX_SPEED;
        const oldStep = player.step;
        player.step += stepSpeed * 12 * dt;
        
        // Play walking sounds
        if (speed > 10 && Math.floor(player.step) !== Math.floor(oldStep)) {
          // Determine surface type based on player position
          let surface = 'grass';
          for (const road of roads) {
            const dx = Math.abs(player.x - (road.x1 + road.x2) / 2);
            const dy = Math.abs(player.y - (road.y1 + road.y2) / 2);
            if (dx < road.width/2 || dy < road.width/2) {
              surface = 'road';
              break;
            }
          }
          audioManager.playWalkSound(surface);
        }

        // Chat timer
        if (messageTimer > 0) {
          messageTimer -= dt;
          if (messageTimer < 0) messageTimer = 0;
        }
      }

      function resolveCircleRect(circle, rect) {
        const cx = clamp(circle.x, rect.x, rect.x + rect.w);
        const cy = clamp(circle.y, rect.y, rect.y + rect.h);
        const dx = circle.x - cx;
        const dy = circle.y - cy;
        const dist = Math.hypot(dx, dy);
        if (dist < circle.radius) {
          const overlap = circle.radius - (dist || 0.0001);
          const nx = dx / (dist || 1);
          const ny = dy / (dist || 1);
          circle.x += nx * overlap;
          circle.y += ny * overlap;
          // deflect velocity
          const dot = circle.vx * nx + circle.vy * ny;
          if (dot < 0) {
            circle.vx -= dot * nx;
            circle.vy -= dot * ny;
          }
        }
      }
      
      function clamp(v, a, b) { 
        return Math.max(a, Math.min(b, v)); 
      }
      
      // House system functions
      function enterHouse(building) {
        if (!houseInteriors[building.id]) return;
        
        currentHouse = building;
        isInsideHouse = true;
        target = null; // Clear movement target
        
        // Position player at the entrance of the house interior
        const interior = houseInteriors[building.id];
        player.x = interior.width - 50;
        player.y = interior.height - 40;
        
        // Show enter message
        showPickupText(`נכנסת ל${interior.name}`, innerWidth/2, innerHeight/2);
      }
      
      function exitHouse() {
        if (!currentHouse) return;
        
        // Position player outside the house
        player.x = currentHouse.x + currentHouse.w/2;
        player.y = currentHouse.y + currentHouse.h + 20;
        
        showPickupText(`יצאת מ${houseInteriors[currentHouse.id].name}`, innerWidth/2, innerHeight/2);
        
        currentHouse = null;
        isInsideHouse = false;
        target = null;
      }

      function drawTarget(tx, ty) {
        ctx.save();
        ctx.translate(tx, ty);
        
        // Animated pulsing circle
        const time = performance.now() * 0.003;
        const pulse = 0.8 + Math.sin(time * 4) * 0.2;
        const size = 16 * pulse;
        
        // Outer ring
        ctx.strokeStyle = 'rgba(102, 166, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner dot
        ctx.fillStyle = 'rgba(102, 166, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Cross lines
        ctx.strokeStyle = 'rgba(102, 166, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-size, 0);
        ctx.lineTo(size, 0);
        ctx.moveTo(0, -size);
        ctx.lineTo(0, size);
        ctx.stroke();
        
        ctx.restore();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Apply zoom transformation after DPR scaling
        ctx.save();
        ctx.scale(zoomLevel, zoomLevel);
        
        if (isInsideHouse && currentHouse) {
          // Draw house interior
          drawHouseInterior();
        } else {
        // Draw outside world
          ctx.fillStyle = '#0f1220';
          ctx.fillRect(0, 0, innerWidth / zoomLevel, innerHeight / zoomLevel);

          // Camera follows player with zoom
          const viewWidth = innerWidth / zoomLevel;
          const viewHeight = innerHeight / zoomLevel;
          const camX = player.x - viewWidth / 2;
          const camY = player.y - viewHeight / 2;

          // Terrain
          drawTerrain(camX, camY);
          
          // Roads
          drawRoads(camX, camY);
          
          // Buildings
          drawBuildings(camX, camY);
          
          // Trees with glowing effects
          drawTrees(camX, camY);
          
          // Street lamps and lighting
          drawStreetLamps(camX, camY);
          
          // Floating sparkles
          drawFloatingSparkles(camX, camY);
          
          // House lights
          drawHouseLights(camX, camY);

          // Plaza and confetti
          drawPlaza(camX, camY);
          drawConfetti(camX, camY);
          
          // Simple weather effects (over terrain but under characters)
          drawSimpleWeather(camX, camY);

          // NPCs and Shops
          drawNpcs(camX, camY);

          // Collectibles (gifts)
          drawCollectibles(camX, camY);

          // Coins
          drawCoins(camX, camY);

          // Player
          const px = player.x - camX;
          const py = player.y - camY;

          // Trail effect (behind player) if equipped
          if (equipped.effect) {
            for (let i = 0; i < trail.length; i++) {
              const p = trail[i];
              const sx = p.x - camX;
              const sy = p.y - camY;
              const alpha = i / trail.length;
              const col = trailColorForEffect(equipped.effect);
              ctx.fillStyle = `rgba(${col.r}, ${col.g}, ${col.b}, ${alpha * 0.45})`;
              ctx.beginPath();
              ctx.arc(sx, sy, 6 * alpha, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // Draw player (different when in vehicle)
          if (inVehicle && playerVehicle) {
            drawPlayerInVehicle(px, py, player.angle);
          } else {
            drawPlayer(px, py);
          }

          // Player name under feet
          drawName(px, py);

          // Target indicator
          if (target) {
            drawTarget(target.x - camX, target.y - camY);
          }

          // Vehicle (if not in vehicle, draw it separately)
          if (playerVehicle && !inVehicle) {
            drawVehicle(vehicleX - camX, vehicleY - camY, vehicleAngle);
          }

          // Chat bubble
          drawChat(px, py);
        }
        
        // Restore zoom transformation
        ctx.restore();
        
        // Update minimap (after main drawing is done)
        if (!isInsideHouse) {
          const viewWidth = innerWidth / zoomLevel;
          const viewHeight = innerHeight / zoomLevel;
          const camX = player.x - viewWidth / 2;
          const camY = player.y - viewHeight / 2;
          minimap.update(camX, camY);
        }
      }

      function drawTerrain(camX, camY) {
        const tile = 180; // tile size in world px
        const viewWidth = innerWidth / zoomLevel;
        const viewHeight = innerHeight / zoomLevel;
        const startIX = Math.floor(camX / tile) - 1;
        const endIX = Math.floor((camX + viewWidth) / tile) + 1;
        const startIY = Math.floor(camY / tile) - 1;
        const endIY = Math.floor((camY + viewHeight) / tile) + 1;

        for (let iy = startIY; iy <= endIY; iy++) {
          for (let ix = startIX; ix <= endIX; ix++) {
            const sx = ix * tile - camX;
            const sy = iy * tile - camY;
            const h = hash2d(ix, iy);
            // decide biome
            let biome = 'grass';
            if (h > 0.82) biome = 'water';
            else if (h > 0.62) biome = 'flowers';
            else if (h > 0.48) biome = 'sand';
            // colors
            const col = biomeColors(biome);
            // gradient fill for richness
            const grad = ctx.createLinearGradient(sx, sy, sx + tile, sy + tile);
            grad.addColorStop(0, col.base);
            grad.addColorStop(1, col.accent);
            ctx.fillStyle = grad;
            ctx.fillRect(sx, sy, tile, tile);

            // decorative details per biome (few, deterministic)
            if (biome === 'flowers') {
              for (let k = 0; k < 6; k++) {
                const rx = sx + (rand2d(ix, iy, k + 1) * (tile - 16) + 8);
                const ry = sy + (rand2d(ix, iy, k + 11) * (tile - 16) + 8);
                ctx.fillStyle = flowerColor(k);
                ctx.beginPath(); ctx.arc(rx, ry, 2.4, 0, Math.PI * 2); ctx.fill();
              }
            } else if (biome === 'sand') {
              ctx.strokeStyle = 'rgba(0,0,0,0.06)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              for (let k = 0; k < 5; k++) {
                const x1 = sx + rand2d(ix, iy, k + 21) * tile;
                const y1 = sy + rand2d(ix, iy, k + 31) * tile;
                ctx.moveTo(x1 - 6, y1); ctx.lineTo(x1 + 6, y1);
              }
              ctx.stroke();
            } else if (biome === 'grass') {
              ctx.strokeStyle = 'rgba(0,0,0,0.08)';
              ctx.lineWidth = 1;
              for (let k = 0; k < 4; k++) {
                const rx = sx + rand2d(ix, iy, k + 41) * tile;
                const ry = sy + rand2d(ix, iy, k + 51) * tile;
                ctx.beginPath();
                ctx.moveTo(rx, ry);
                ctx.lineTo(rx + 0, ry + 6);
                ctx.stroke();
              }
            } else if (biome === 'water') {
              // subtle waves
              ctx.strokeStyle = 'rgba(255,255,255,0.25)';
              ctx.lineWidth = 1.5;
              const t = performance.now() * 0.001;
              for (let k = 0; k < 3; k++) {
                const yy = sy + (k + 1) * tile / 4 + Math.sin((ix + iy + k) * 1.7 + t) * 4;
                ctx.beginPath();
                ctx.moveTo(sx + 12, yy);
                ctx.quadraticCurveTo(sx + tile / 2, yy + 3, sx + tile - 12, yy);
                ctx.stroke();
              }
            }
          }
        }
      }

      function biomeColors(b) {
        switch (b) {
          case 'water': return { base: '#4dabf7', accent: '#1e81ce' };
          case 'sand': return { base: '#f6d365', accent: '#fda085' };
          case 'flowers': return { base: '#a8e6cf', accent: '#dcedc1' };
          case 'grass': default: return { base: '#9be7a3', accent: '#58d68d' };
        }
      }
      function flowerColor(i) {
        const palette = ['#ff6b6b', '#ffd93d', '#845ef7', '#ff922b', '#22b8cf', '#f06595'];
        return palette[i % palette.length];
      }
      function fract(x) { return x - Math.floor(x); }
      function hash2d(ix, iy) {
        const s = Math.sin(ix * 127.1 + iy * 311.7) * 43758.5453;
        return fract(s);
      }
      
      function drawRoads(camX, camY) {
        ctx.save();
        for (const road of roads) {
          ctx.strokeStyle = '#555';
          ctx.lineWidth = road.width;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(road.x1 - camX, road.y1 - camY);
          ctx.lineTo(road.x2 - camX, road.y2 - camY);
          ctx.stroke();
          
          // Road markings
          ctx.strokeStyle = '#ffff00';
          ctx.lineWidth = 3;
          ctx.setLineDash([20, 20]);
          ctx.beginPath();
          ctx.moveTo(road.x1 - camX, road.y1 - camY);
          ctx.lineTo(road.x2 - camX, road.y2 - camY);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        ctx.restore();
      }
      
      function drawBuildings(camX, camY) {
        for (const building of buildings) {
          const sx = building.x - camX;
          const sy = building.y - camY;
          
          ctx.save();
          ctx.translate(sx + building.w/2, sy + building.h/2);
          
          if (building.type === 'house') {
            // House base
            ctx.fillStyle = building.color;
            ctx.fillRect(-building.w/2, -building.h/2, building.w, building.h);
            
            // Roof
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.moveTo(-building.w/2 - 10, -building.h/2);
            ctx.lineTo(0, -building.h/2 - 30);
            ctx.lineTo(building.w/2 + 10, -building.h/2);
            ctx.closePath();
            ctx.fill();
            
            // Door
            ctx.fillStyle = '#654321';
            ctx.fillRect(-12, building.h/2 - 25, 24, 25);
            
            // Windows
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(-building.w/2 + 15, -10, 20, 15);
            ctx.fillRect(building.w/2 - 35, -10, 20, 15);
            
            // Window frames
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(-building.w/2 + 15, -10, 20, 15);
            ctx.strokeRect(building.w/2 - 35, -10, 20, 15);
            
          } else if (building.type === 'shop') {
            // Shop base
            ctx.fillStyle = building.color;
            ctx.fillRect(-building.w/2, -building.h/2, building.w, building.h);
            
            // Awning
            ctx.fillStyle = '#ff4500';
            ctx.fillRect(-building.w/2 - 5, -building.h/2 - 15, building.w + 10, 20);
            
            // Sign
            ctx.fillStyle = '#fff';
            ctx.fillRect(-30, -building.h/2 + 10, 60, 20);
            ctx.fillStyle = '#000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('חנות', 0, -building.h/2 + 24);
            
          } else if (building.type === 'barn') {
            // Barn
            ctx.fillStyle = building.color;
            ctx.fillRect(-building.w/2, -building.h/2, building.w, building.h);
            
            // Barn roof
            ctx.fillStyle = '#4a4a4a';
            ctx.beginPath();
            ctx.moveTo(-building.w/2 - 5, -building.h/2);
            ctx.lineTo(0, -building.h/2 - 25);
            ctx.lineTo(building.w/2 + 5, -building.h/2);
            ctx.closePath();
            ctx.fill();
            
            // Large doors
            ctx.fillStyle = '#654321';
            ctx.fillRect(-25, building.h/2 - 40, 50, 40);
          }
          
          ctx.restore();
        }
      }
      
      function drawTrees(camX, camY) {
        for (const tree of trees) {
          const sx = tree.x - camX;
          const sy = tree.y - camY;
          
          // Skip if too far from screen
          if (sx < -100 || sx > innerWidth + 100 || sy < -100 || sy > innerHeight + 100) continue;
          
          ctx.save();
          ctx.translate(sx, sy);
          ctx.scale(tree.size, tree.size);
          
          // Add glowing effect if tree is glowing
          if (tree.glowing) {
            const time = performance.now() * 0.003;
            const glowSize = 40 + Math.sin(time + tree.x * 0.01) * 10;
            const gradient = ctx.createRadialGradient(0, -15, 0, 0, -15, glowSize);
            gradient.addColorStop(0, tree.glowColor + '40');
            gradient.addColorStop(0.7, tree.glowColor + '20');
            gradient.addColorStop(1, tree.glowColor + '00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, -15, glowSize, 0, Math.PI * 2);
            ctx.fill();
          }
          
          if (tree.type === 'oak') {
            // Oak tree
            // Trunk
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-6, 0, 12, 35);
            
            // Leaves (multiple circles for fuller look)
            ctx.fillStyle = '#228b22';
            ctx.beginPath();
            ctx.arc(0, -10, 25, 0, Math.PI * 2);
            ctx.arc(-12, -5, 20, 0, Math.PI * 2);
            ctx.arc(12, -5, 20, 0, Math.PI * 2);
            ctx.arc(0, -25, 18, 0, Math.PI * 2);
            ctx.fill();
            
          } else if (tree.type === 'pine') {
            // Pine tree
            // Trunk
            ctx.fillStyle = '#654321';
            ctx.fillRect(-4, 0, 8, 30);
            
            // Pine layers
            ctx.fillStyle = '#006400';
            ctx.beginPath();
            ctx.moveTo(0, -35);
            ctx.lineTo(-15, -10);
            ctx.lineTo(15, -10);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(-18, 0);
            ctx.lineTo(18, 0);
            ctx.closePath();
            ctx.fill();
            
          } else if (tree.type === 'palm') {
            // Palm tree
            // Trunk
            ctx.fillStyle = '#daa520';
            ctx.fillRect(-5, 0, 10, 40);
            
            // Palm fronds
            ctx.strokeStyle = '#228b22';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              ctx.beginPath();
              ctx.moveTo(0, -30);
              ctx.lineTo(Math.cos(angle) * 30, -30 + Math.sin(angle) * 15);
              ctx.stroke();
            }
          }
          
          // Add magical sparkles around glowing trees
          if (tree.glowing) {
            const time = performance.now() * 0.002;
            for (let i = 0; i < 5; i++) {
              const angle = (time + i * 1.26) % (Math.PI * 2);
              const radius = 25 + Math.sin(time * 2 + i) * 8;
              const sparkleX = Math.cos(angle) * radius;
              const sparkleY = Math.sin(angle) * radius - 20;
              
              ctx.fillStyle = tree.glowColor + Math.floor((Math.sin(time * 3 + i) * 0.5 + 0.5) * 255).toString(16).padStart(2, '0');
              ctx.beginPath();
              ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          ctx.restore();
        }
      }
      
      // Draw street lamps with glowing effects
      function drawStreetLamps(camX, camY) {
        for (const lamp of streetLamps) {
          const sx = lamp.x - camX;
          const sy = lamp.y - camY;
          
          // Skip if too far from screen
          if (sx < -50 || sx > innerWidth + 50 || sy < -50 || sy > innerHeight + 50) continue;
          
          ctx.save();
          ctx.translate(sx, sy);
          
          // Lamp post
          ctx.fillStyle = '#444';
          ctx.fillRect(-3, -30, 6, 60);
          
          // Lamp housing
          ctx.fillStyle = '#666';
          ctx.fillRect(-8, -35, 16, 10);
          
          // Light glow effect
          if (lamp.light) {
            const lightColor = lamp.color || '#ffff88';
            const time = performance.now() * 0.001;
            const intensity = lamp.flickering ? 0.5 + Math.sin(time * 8) * 0.3 : 0.8;
            const glowSize = 60 + Math.sin(time * 2) * 10;
            
            const gradient = ctx.createRadialGradient(0, -30, 0, 0, -30, glowSize);
            gradient.addColorStop(0, lightColor + Math.floor(intensity * 128).toString(16).padStart(2, '0'));
            gradient.addColorStop(0.6, lightColor + Math.floor(intensity * 64).toString(16).padStart(2, '0'));
            gradient.addColorStop(1, lightColor + '00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, -30, glowSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Lamp bulb
            ctx.fillStyle = lightColor;
            ctx.beginPath();
            ctx.arc(0, -30, 4, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.restore();
        }
      }
      
      // Draw floating sparkles
      function drawFloatingSparkles(camX, camY) {
        for (const sparkle of floatingSparkles) {
          const sx = sparkle.x - camX;
          const sy = sparkle.y - camY;
          
          // Skip if too far from screen
          if (sx < -20 || sx > innerWidth + 20 || sy < -20 || sy > innerHeight + 20) continue;
          
          ctx.save();
          ctx.translate(sx, sy);
          
          const alpha = Math.floor(sparkle.brightness * 255).toString(16).padStart(2, '0');
          ctx.fillStyle = sparkle.color + alpha;
          
          // Draw sparkle as a star
          ctx.beginPath();
          for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const x = Math.cos(angle) * sparkle.size;
            const y = Math.sin(angle) * sparkle.size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          
          // Add cross lines for sparkle effect
          ctx.strokeStyle = sparkle.color + alpha;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(-sparkle.size * 1.5, 0);
          ctx.lineTo(sparkle.size * 1.5, 0);
          ctx.moveTo(0, -sparkle.size * 1.5);
          ctx.lineTo(0, sparkle.size * 1.5);
          ctx.stroke();
          
          ctx.restore();
        }
      }
      
      // Draw house lights
      function drawHouseLights(camX, camY) {
        for (let i = 0; i < houseLights.length; i++) {
          const light = houseLights[i];
          const sx = light.x - camX;
          const sy = light.y - camY;
          
          // Skip if too far from screen
          if (sx < -100 || sx > innerWidth + 100 || sy < -100 || sy > innerHeight + 100) continue;
          
          if (light.on) {
            const time = performance.now() * 0.001;
            const glowSize = 30 + Math.sin(time * 1.5 + i) * 5;
            
            const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize);
            gradient.addColorStop(0, light.color + '60');
            gradient.addColorStop(0.7, light.color + '20');
            gradient.addColorStop(1, light.color + '00');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(sx, sy, glowSize, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      function drawHouseInterior() {
        const interior = houseInteriors[currentHouse.id];
        if (!interior) return;
        
        // Camera system for house interior (adjusted for zoom)
        const camX = player.x - (interior.width / 2) / zoomLevel;
        const camY = player.y - (interior.height / 2) / zoomLevel;
        
        // Background - wooden floor
        const floorGrad = ctx.createLinearGradient(0, 0, interior.width, interior.height);
        floorGrad.addColorStop(0, '#deb887');
        floorGrad.addColorStop(1, '#cd853f');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, 0, innerWidth, innerHeight);
        
        // Floor planks pattern
        ctx.strokeStyle = 'rgba(139,69,19,0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < interior.height; i += 25) {
          ctx.beginPath();
          ctx.moveTo(0 - camX, i - camY);
          ctx.lineTo(interior.width - camX, i - camY);
          ctx.stroke();
        }
        
        // Walls - outer boundaries
        ctx.fillStyle = '#8b7355';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 8;
        
        // Left wall
        ctx.fillRect(0 - camX, 0 - camY, 15, interior.height);
        ctx.strokeRect(0 - camX, 0 - camY, 15, interior.height);
        
        // Right wall  
        ctx.fillRect(interior.width - 15 - camX, 0 - camY, 15, interior.height);
        ctx.strokeRect(interior.width - 15 - camX, 0 - camY, 15, interior.height);
        
        // Top wall
        ctx.fillRect(0 - camX, 0 - camY, interior.width, 15);
        ctx.strokeRect(0 - camX, 0 - camY, interior.width, 15);
        
        // Bottom wall (with door opening)
        ctx.fillRect(0 - camX, interior.height - 15 - camY, interior.width - 50, 15);
        ctx.strokeRect(0 - camX, interior.height - 15 - camY, interior.width - 50, 15);
        
        // Door frame
        ctx.fillStyle = '#654321';
        ctx.fillRect(interior.width - 50 - camX, interior.height - 15 - camY, 5, 15);
        ctx.fillRect(interior.width - 5 - camX, interior.height - 15 - camY, 5, 15);
        
        // Door
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(interior.width - 45 - camX, interior.height - 12 - camY, 40, 12);
        
        // Door handle
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(interior.width - 10 - camX, interior.height - 6 - camY, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Room dividers for multi-room houses
        if (currentHouse.id === 'playerHouse') {
          // Bedroom divider
          ctx.fillStyle = '#8b7355';
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 6;
          ctx.fillRect(30 - camX, 150 - camY, 120, 8);
          ctx.strokeRect(30 - camX, 150 - camY, 120, 8);
        }
        
        // Furniture rendering
        for (const furniture of interior.furniture) {
          drawFurniture(furniture, camX, camY);
        }
        
        // Windows
        drawWindows(interior, camX, camY);
        
        // Player inside house
        const px = player.x - camX;
        const py = player.y - camY;
        
        // Trail effect inside house
        if (equipped.effect) {
          for (let i = 0; i < trail.length; i++) {
            const p = trail[i];
            const sx = p.x - camX;
            const sy = p.y - camY;
            const alpha = i / trail.length;
            const col = trailColorForEffect(equipped.effect);
            ctx.fillStyle = `rgba(${col.r}, ${col.g}, ${col.b}, ${alpha * 0.45})`;
            ctx.beginPath();
            ctx.arc(sx, sy, 6 * alpha, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        drawPlayer(px, py);
        drawName(px, py);
        
        // Target indicator
        if (target) {
          drawTarget(target.x - camX, target.y - camY);
        }
        
        drawChat(px, py);
        
        // Exit hint
        ctx.save();
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillText('לחץ על הדלת ליציאה', innerWidth/2, 30);
        ctx.restore();
        
        // House name
        ctx.save();
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#8b4513';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.strokeText(interior.name, innerWidth/2, innerHeight - 30);
        ctx.fillText(interior.name, innerWidth/2, innerHeight - 30);
        ctx.restore();
      }
      
      function drawFurniture(furniture, camX, camY) {
        const fx = furniture.x - camX;
        const fy = furniture.y - camY;
        
        ctx.save();
        ctx.translate(fx + furniture.w/2, fy + furniture.h/2);
        
        switch (furniture.type) {
          case 'bed':
            // Bed frame
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-furniture.w/2, -furniture.h/2, furniture.w, furniture.h);
            
            // Mattress
            ctx.fillStyle = '#fff8dc';
            ctx.fillRect(-furniture.w/2 + 5, -furniture.h/2 + 5, furniture.w - 10, furniture.h - 10);
            
            // Pillow
            ctx.fillStyle = '#e6e6fa';
            ctx.fillRect(-furniture.w/2 + 8, -furniture.h/2 + 8, furniture.w/3, furniture.h/4);
            
            // Blanket
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(-furniture.w/2 + 5, -furniture.h/2 + furniture.h/3, furniture.w - 10, furniture.h/2);
            break;
            
          case 'table':
            // Table top
            ctx.fillStyle = '#daa520';
            ctx.fillRect(-furniture.w/2, -furniture.h/2, furniture.w, furniture.h);
            
            // Table legs
            ctx.fillStyle = '#8b4513';
            const legSize = 6;
            ctx.fillRect(-furniture.w/2 + 5, -furniture.h/2 + 5, legSize, legSize);
            ctx.fillRect(furniture.w/2 - 5 - legSize, -furniture.h/2 + 5, legSize, legSize);
            ctx.fillRect(-furniture.w/2 + 5, furniture.h/2 - 5 - legSize, legSize, legSize);
            ctx.fillRect(furniture.w/2 - 5 - legSize, furniture.h/2 - 5 - legSize, legSize, legSize);
            break;
            
          case 'chair':
            // Chair seat
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-furniture.w/2, -furniture.h/2, furniture.w, furniture.h);
            
            // Chair back
            ctx.fillRect(-furniture.w/2, -furniture.h/2 - 15, furniture.w, 10);
            break;
            
          case 'bookshelf':
            // Shelf frame
            ctx.fillStyle = '#654321';
            ctx.fillRect(-furniture.w/2, -furniture.h/2, furniture.w, furniture.h);
            
            // Shelves
            ctx.fillStyle = '#8b4513';
            for (let i = 0; i < 4; i++) {
              const shelfY = -furniture.h/2 + (i * furniture.h/4);
              ctx.fillRect(-furniture.w/2 + 2, shelfY, furniture.w - 4, 3);
            }
            
            // Books
            const bookColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
            for (let i = 0; i < 8; i++) {
              ctx.fillStyle = bookColors[i % bookColors.length];
              const bookX = -furniture.w/2 + 4 + (i % 4) * 5;
              const bookY = -furniture.h/2 + 8 + Math.floor(i/4) * 20;
              ctx.fillRect(bookX, bookY, 4, 15);
            }
            break;
            
          case 'wardrobe':
            // Wardrobe body
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-furniture.w/2, -furniture.h/2, furniture.w, furniture.h);
            
            // Doors
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.strokeRect(-furniture.w/2 + 2, -furniture.h/2 + 2, furniture.w - 4, furniture.h - 4);
            ctx.beginPath();
            ctx.moveTo(0, -furniture.h/2 + 2);
            ctx.lineTo(0, furniture.h/2 - 2);
            ctx.stroke();
            
            // Handles
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(-8, 0, 2, 0, Math.PI * 2);
            ctx.arc(8, 0, 2, 0, Math.PI * 2);
            ctx.fill();
            break;
            
          case 'carpet':
            // Carpet with pattern
            ctx.fillStyle = '#dc143c';
            ctx.fillRect(-furniture.w/2, -furniture.h/2, furniture.w, furniture.h);
            
            // Carpet pattern
            ctx.strokeStyle = '#b22222';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
              for (let j = 0; j < 3; j++) {
                const x = -furniture.w/2 + (i + 1) * furniture.w/4;
                const y = -furniture.h/2 + (j + 1) * furniture.h/4;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.stroke();
              }
            }
            break;
            
          case 'sofa':
            // Sofa base
            ctx.fillStyle = '#8b008b';
            ctx.fillRect(-furniture.w/2, -furniture.h/2, furniture.w, furniture.h);
            
            // Sofa back
            ctx.fillRect(-furniture.w/2, -furniture.h/2 - 15, furniture.w, 15);
            
            // Cushions
            ctx.fillStyle = '#9370db';
            for (let i = 0; i < 3; i++) {
              const cushionX = -furniture.w/2 + 10 + i * (furniture.w/3);
              ctx.fillRect(cushionX, -furniture.h/2 + 5, furniture.w/3 - 5, furniture.h - 10);
            }
            break;
            
          case 'plant':
            // Pot
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-furniture.w/2, furniture.h/2 - 10, furniture.w, 10);
            
            // Plant stem
            ctx.strokeStyle = '#228b22';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, furniture.h/2 - 10);
            ctx.lineTo(0, -furniture.h/2);
            ctx.stroke();
            
            // Leaves
            ctx.fillStyle = '#32cd32';
            for (let i = 0; i < 5; i++) {
              const angle = (i / 5) * Math.PI * 2;
              const leafX = Math.cos(angle) * 8;
              const leafY = Math.sin(angle) * 8 - 10;
              ctx.beginPath();
              ctx.ellipse(leafX, leafY, 6, 10, angle, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
        }
        
        ctx.restore();
      }
      
      function drawWindows(interior, camX, camY) {
        // Left wall window
        ctx.fillStyle = '#87ceeb';
        ctx.fillRect(20 - camX, 60 - camY, 25, 30);
        
        // Window frame
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 3;
        ctx.strokeRect(20 - camX, 60 - camY, 25, 30);
        
        // Window cross
        ctx.beginPath();
        ctx.moveTo(32.5 - camX, 60 - camY);
        ctx.lineTo(32.5 - camX, 90 - camY);
        ctx.moveTo(20 - camX, 75 - camY);
        ctx.lineTo(45 - camX, 75 - camY);
        ctx.stroke();
        
        // Right wall window
        ctx.fillStyle = '#87ceeb';
        ctx.fillRect(interior.width - 45 - camX, 60 - camY, 25, 30);
        ctx.strokeRect(interior.width - 45 - camX, 60 - camY, 25, 30);
        
        // Window cross
        ctx.beginPath();
        ctx.moveTo(interior.width - 32.5 - camX, 60 - camY);
        ctx.lineTo(interior.width - 32.5 - camX, 90 - camY);
        ctx.moveTo(interior.width - 45 - camX, 75 - camY);
        ctx.lineTo(interior.width - 20 - camX, 75 - camY);
        ctx.stroke();
      }
      function rand2d(ix, iy, seed) {
        const s = Math.sin(ix * 157.31 + iy * 289.97 + seed * 41.7) * 43758.5453;
        return fract(s);
      }

      // ---------- NPCs / Shops ----------
      const npcs = [
        { id: 'shop_mary', kind: 'shop', name: 'חנות מירי', x: 1200, y: 900, dialog: ['ברוך הבא!', 'יש לנו מבצעים חמים היום!', 'קנה אצלי פריטים'], walkStep: 0 },
        
        // Enhanced residents with more quests and trades
        { 
          id: 'resident_dani', kind: 'resident', name: 'דני', x: 1700, y: 1300, 
          dialog: ['איזה יום יפה!', 'תיזהר מהגלים בים...', 'אולי תרצה להחליף?'], 
          walkStep: 0, walkDirection: 0, walkTimer: 0,
          quests: [ 
            { type: 'collect_coins', required: 5, reward: 800 },
            { type: 'collect_gifts', required: 3, reward: 600, rewardItem: 'dragon_wings' },
            { type: 'visit_houses', required: 2, reward: 400 },
            { type: 'collect_rare_items', required: 2, reward: 1500, rewardItem: 'crown_royal' }
          ],
          trades: [
            { wants: ['spark_trail'], offers: ['blue_boots', 'red_glasses'], name: 'נצנצים לנעליים' },
            { wants: ['angel_wings'], offers: ['crown_hat', 'wizard_hat'], name: 'כנפיים לכובעים' },
            { wants: ['birthday_shirt_1'], offers: ['party_hat', 'confetti_trail'], name: 'חולצת יום הולדת לחגיגה' },
            { wants: ['fire_trail', 'blue_trail'], offers: ['birthday_balloons'], name: 'שובלים לבלונים' }
          ]
        },
        { 
          id: 'resident_noa', kind: 'resident', name: 'נועה', x: 900, y: 1600, 
          dialog: ['אהלן!', 'אוסף מטבעות? זה כיף!', 'יש לי הצעות החלפה!'], 
          walkStep: 0, walkDirection: 0, walkTimer: 0,
          quests: [ 
            { type: 'collect_coins', required: 4, reward: 700 },
            { type: 'collect_gifts', required: 3, reward: 500, rewardItem: 'rainbow_trail' },
            { type: 'wear_items', required: 3, reward: 600 },
            { type: 'collect_legendary_items', required: 1, reward: 2000, rewardItem: 'mega_halo' }
          ],
          trades: [
            { wants: ['top_hat'], offers: ['green_boots', 'cool_glasses'], name: 'כובע לאקססוארים' },
            { wants: ['fire_trail'], offers: ['red_cape', 'blue_trail'], name: 'אש לגלימה' },
            { wants: ['birthday_hat_1'], offers: ['heart_balloons', 'party_shirt'], name: 'כובע לבלונים' },
            { wants: ['crown_hat', 'wizard_hat'], offers: ['birthday_hat_2'], name: 'כובעים ליום הולדת' }
          ]
        },
        { 
          id: 'resident_sandra', kind: 'resident', name: 'סנדרה', x: 1450, y: 1100, 
          dialog: ['ברוכים הבאים לכיכר!','איזו אווירה צבעונית!','יש לי החלפות מיוחדות!'],
          walkStep: 0, walkDirection: 0, walkTimer: 0,
          quests: [
            { type: 'collect_gifts', required: 4, reward: 900 },
            { type: 'trade_items', required: 2, reward: 800 },
            { type: 'collect_birthday_gifts', required: 3, reward: 1200, rewardItem: 'galaxy_trail' }
          ],
          trades: [
            { wants: ['crown_hat'], offers: ['angel_wings', 'spark_trail'], name: 'כתר לכנפיים' },
            { wants: ['blue_boots', 'green_boots'], offers: ['wizard_hat'], name: 'נעליים לקסמים' },
            { wants: ['party_hat'], offers: ['birthday_shirt_2', 'confetti_trail'], name: 'מסיבה לחגיגה' },
            { wants: ['crown_royal', 'mega_halo'], offers: ['galaxy_trail'], name: 'חליפת פריטים אגדים' },
            { wants: ['dragon_wings', 'shadow_cloak'], offers: ['rainbow_trail'], name: 'פריטים נדירים' }
          ]
        },
        
        // New residents with unique quests and trades
        {
          id: 'resident_alex', kind: 'resident', name: 'אלכס', x: 2200, y: 800,
          dialog: ['שלום חבר!', 'אני אוהב רכבים!', 'אפשר לעזור לך עם נסיעות?'],
          walkStep: 0, walkDirection: 0, walkTimer: 0,
          quests: [
            { type: 'drive_distance', required: 1000, reward: 1200 },
            { type: 'collect_coins_vehicle', required: 10, reward: 800 }
          ],
          trades: [
            { wants: ['spark_trail', 'fire_trail'], offers: ['birthday_balloons'], name: 'שובלים לבלונים' },
            { wants: ['angel_wings'], offers: ['heart_balloons'], name: 'כנפיים ללבבות' }
          ]
        },
        {
          id: 'resident_ben', kind: 'resident', name: 'בן', x: 3200, y: 1500,
          dialog: ['אהלן שם!', 'אני מנהל המסחר כאן', 'צריך עזרה עם עסקים?'],
          walkStep: 0, walkDirection: 0, walkTimer: 0,
          quests: [
            { type: 'earn_coins', required: 2000, reward: 1500 },
            { type: 'complete_trades', required: 5, reward: 1200 }
          ],
          trades: [
            { wants: ['top_hat', 'crown_hat'], offers: ['birthday_hat_1', 'birthday_hat_2'], name: 'כובעים קלאסיים ליום הולדת' },
            { wants: ['red_cape', 'angel_wings'], offers: ['birthday_balloons', 'heart_balloons'], name: 'גלימות לבלונים' },
            { wants: ['rainbow_trail', 'galaxy_trail'], offers: ['laser_glasses', 'golden_boots'], name: 'שובלים אגדים לפריטים נדירים' },
            { wants: ['shadow_cloak', 'dragon_wings', 'crown_royal'], offers: ['mega_halo'], name: 'אוסף פריטים נדירים לאגדי' }
          ]
        }
      ];
      let activeNpcDialog = null; // {npcId, text, timer}

      // Quest state per NPC (supports multiple quests per NPC)
      // questMap: npcId -> Array<QuestState>
      const questMap = new Map();
      function ensureQuestsForNpc(npc) {
        if (!npc.quests || !npc.quests.length) return [];
        if (!questMap.has(npc.id)) {
          const list = npc.quests.map(q => ({
            state: 'offer',
            progress: 0,
            required: q.required,
            reward: q.reward,
            rewardItem: q.rewardItem || null,
            type: q.type,
            title: getQuestTitle(q.type, q.required),
            cooldown: 0
          }));
          questMap.set(npc.id, list);
        }
        return questMap.get(npc.id);
      }
      
      function getQuestTitle(type, required) {
        switch(type) {
          case 'collect_coins': return `אסוף ${required} מטבעות`;
          case 'collect_gifts': return `אסוף ${required} מתנות`;
          case 'visit_houses': return `בקר ב-${required} בתים`;
          case 'wear_items': return `לבש ${required} פריטים`;
          case 'trade_items': return `בצע ${required} החלפות`;
          case 'drive_distance': return `נסע ${required} מטרים ברכב`;
          case 'collect_coins_vehicle': return `אסוף ${required} מטבעות ברכב`;
          case 'collect_birthday_items': return `אסוף ${required} פריטי יום הולדת`;
          case 'wear_birthday_outfit': return `לבש תלבושת יום הולדת`;
          case 'earn_coins': return `צבור ${required} מטבעות`;
          case 'complete_trades': return `השלם ${required} החלפות`;
          case 'collect_rare_items': return `אסוף ${required} פריטים נדירים`;
          case 'collect_legendary_items': return `אסוף ${required} פריטים אגדיים`;
          case 'collect_birthday_gifts': return `אסוף ${required} מתנות יום הולדת`;
          default: return 'משימה';
        }
      }
      function updateQuestPanel() {
        const panel = document.getElementById('questPanel');
        let html = '';
        for (const [npcId, list] of questMap.entries()) {
          for (const q of list) {
            if (q.state === 'active') {
              html += `<div class=\"q-title\">משימה: ${q.title}</div>`;
              // Format progress based on quest type
              let progressText = `${q.progress}/${q.required}`;
              if (q.type === 'drive_distance') {
                progressText = `${Math.round(q.progress)}/${q.required} מטרים`;
              } else if (q.type === 'earn_coins') {
                progressText = `${Math.min(coins, q.required)}/${q.required} מטבעות`;
              } else if (q.type === 'complete_trades') {
                progressText = `${q.progress}/${q.required} החלפות`;
              }
              html += `<div class=\"q-line\">התקדמות: ${progressText}</div>`;
            } else if (q.state === 'completed') {
              html += `<div class=\"q-title\">משימה הושלמה!</div>`;
              let rewardText = `🪙 ${q.reward}`;
              if (q.rewardItem) {
                const item = itemCatalog.find(i => i.id === q.rewardItem);
                if (item) {
                  rewardText += ` + ${item.name}`;
                }
              }
              html += `<div class=\"q-line\">חזור לקבלת פרס: ${rewardText}</div>`;
            } else if (q.state === 'cooldown') {
              html += `<div class=\"q-title\">מחדש משימה בעוד</div>`;
              html += `<div class=\"q-line\">${formatTime(Math.ceil(q.cooldown))}</div>`;
            }
          }
        }
        panel.innerHTML = html;
      }
      function formatTime(sec){
        const m = Math.floor(sec/60).toString().padStart(2,'0');
        const s = Math.floor(sec%60).toString().padStart(2,'0');
        return `${m}:${s}`;
      }

      function tryInteract() {
        // Check if player can interact with vehicle first
        if (playerVehicle && !inVehicle) {
          const vehicleDist = Math.hypot(vehicleX - player.x, vehicleY - player.y);
          if (vehicleDist < 60) {
            enterVehicle();
            return;
          }
        } else if (inVehicle) {
          exitVehicle();
          return;
        }
        
        // Find nearest NPC within range
        const range = 80;
        let nearest = null, nd = Infinity;
        for (const npc of npcs) {
          const d = Math.hypot(npc.x - player.x, npc.y - player.y);
          if (d < range && d < nd) { nearest = npc; nd = d; }
        }
        if (!nearest) return;
        if (nearest.kind === 'shop') {
          // Open shop and set title to shop name
          const titleEl = document.getElementById('shopTitle');
          if (titleEl) titleEl.textContent = `🛒 ${nearest.name}`;
              // Mary says her line
              const dialogText = 'קנה אצלי פריטים';
              activeNpcDialog = { npcId: nearest.id, text: dialogText, timer: 2.5 };
              speechManager.speak(dialogText, nearest.id);
          renderShop();
          shopModal.classList.add('open');
        } else {
          // Resident: Handle quests first, then trades
          handleResidentInteraction(nearest);
        }
      }
      
      function handleResidentInteraction(npc) {
        console.log('handleResidentInteraction called for NPC:', npc.id);
        console.log('Current quick mission status:', {
          hasQuickMission: !!currentQuickMission,
          quickMissionNPC: quickMissionNPC?.id,
          targetNPC: npc.id
        });
        
        // Check for quick mission completion first
        if (currentQuickMission && quickMissionNPC && quickMissionNPC.id === npc.id) {
          const completed = completeQuickMission(npc);
          if (completed !== false) {
            return; // Only return if mission was actually completed
          }
        }
        
        // Initialize quests for this NPC if not already done
        const quests = ensureQuestsForNpc(npc);
        
        // Check if any quest is completed and ready for reward
        let completedQuest = null;
        for (const quest of quests) {
          if (quest.state === 'completed') {
            completedQuest = quest;
            break;
          }
        }
        
        if (completedQuest) {
          // Give reward for completed quest
          giveQuestReward(npc, completedQuest);
          return;
        }
        
        // Check if any quest can be offered
        let availableQuest = null;
        for (const quest of quests) {
          if (quest.state === 'offer' && quest.cooldown <= 0) {
            availableQuest = quest;
            break;
          }
        }
        
        if (availableQuest) {
          // Offer new quest
          offerQuest(npc, availableQuest);
          return;
        }
        
        // Default: open trade menu or general interaction
        if (npc.trades && npc.trades.length > 0) {
          const tradeText = 'מה תרצה להחליף?';
          activeNpcDialog = { npcId: npc.id, text: tradeText, timer: 3 };
          openTradeMenu(npc);
        } else {
          const generalText = 'שלום! איך אתה?';
          activeNpcDialog = { npcId: npc.id, text: generalText, timer: 2 };
        }
      }
      
      function offerQuest(npc, quest) {
        const questText = `משימה: ${quest.title}. אתה מקבל?`;
        activeNpcDialog = { npcId: npc.id, text: questText, timer: 4 };
        
        // Accept the quest
        quest.state = 'active';
        quest.progress = 0;
        
        showPickupText(`קיבלת משימה: ${quest.title}`, innerWidth/2, innerHeight/3);
        updateQuestPanel();
        
        // Check if quest can be completed immediately (for earn_coins)
        if (quest.type === 'earn_coins') {
          onEarnCoins();
        }
        
        // Play quest sound
        if (audioManager && audioManager.initialized) {
          audioManager.createBeep(600, 0.2, 'triangle');
          setTimeout(() => audioManager.createBeep(800, 0.2, 'triangle'), 200);
        }
      }
      
      function giveQuestReward(npc, quest) {
        const npcName = npc.name;
        let rewardText = `כל הכבוד! קיבלת: 💰${quest.reward} מטבעות`;
        
        // Give coins
        coins += quest.reward;
        coinCountEl.textContent = coins.toString();
        onEarnCoins(); // Check earn coins quests
        
        // Give item reward if available
        if (quest.rewardItem) {
          const rewardItem = itemCatalog.find(item => item.id === quest.rewardItem);
          if (rewardItem && !ownedItems.has(quest.rewardItem)) {
            ownedItems.add(quest.rewardItem);
            rewardText += ` + ${rewardItem.name}`;
            renderInventory();
          }
        }
        
        // Reset quest with cooldown
        console.log(`Quest ${quest.type} completed, entering cooldown for 30 seconds`);
        quest.state = 'cooldown';
        quest.progress = 0;
        quest.cooldown = 30; // 30 seconds cooldown
        
        const thankText = `תודה! חזור אלי בעוד 30 שניות למשימה חדשה!`;
        activeNpcDialog = { npcId: npc.id, text: thankText, timer: 3 };
        speechManager.speak(thankText, npc.id);
        showPickupText(rewardText, innerWidth/2, innerHeight/3);
        updateQuestPanel();
        
        // Play reward sound
        if (audioManager && audioManager.initialized) {
          audioManager.createBeep(800, 0.15, 'square');
          setTimeout(() => audioManager.createBeep(1000, 0.15, 'square'), 150);
          setTimeout(() => audioManager.createBeep(1200, 0.2, 'square'), 300);
        }
      }

      function drawNpcs(camX, camY) {
        const t = performance.now() * 0.002;
        for (const npc of npcs) {
          const sx = npc.x - camX;
          const sy = npc.y - camY;
          // Draw stand/building for shop, person for resident
          if (npc.kind === 'shop') {
            // Shopkeeper Mary (behind stall)
            ctx.save();
            ctx.translate(sx, sy - 6);
            // body params
            const bodyLen = 50; const hipY = 12;
            // dress
            ctx.fillStyle = '#ff7675';
            ctx.beginPath(); ctx.moveTo(-10, -6); ctx.lineTo(-18, 28); ctx.lineTo(18, 28); ctx.lineTo(10, -6); ctx.closePath(); ctx.fill();
            // hair long (brown)
            const headY = -bodyLen/2 - 6;
            ctx.fillStyle = '#6b3e2e';
            ctx.beginPath(); ctx.ellipse(0, headY + 3, 12, 12, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-6, headY + 4); ctx.quadraticCurveTo(-12, headY + 18, -6, headY + 34); ctx.quadraticCurveTo(-2, headY + 22, -6, headY + 4); ctx.fill();
            ctx.beginPath(); ctx.moveTo(6, headY + 4); ctx.quadraticCurveTo(12, headY + 18, 6, headY + 34); ctx.quadraticCurveTo(2, headY + 22, 6, headY + 4); ctx.fill();
            // head
            ctx.fillStyle = '#ffd5b4'; ctx.beginPath(); ctx.arc(0, headY, 9, 0, Math.PI*2); ctx.fill();
            // fringe
            ctx.fillStyle = '#6b3e2e'; ctx.beginPath(); ctx.arc(0, headY - 2, 9, Math.PI, Math.PI*2); ctx.fill();
            ctx.restore();

            // Stall (in front)
            ctx.save();
            ctx.translate(sx, sy);
            ctx.fillStyle = '#8e44ad';
            roundRect(ctx, -28, -24, 56, 36, 6, '#2d1b4e', '#3e2568', 2);
            // awning stripes
            for (let i=0;i<6;i++) {
              ctx.fillStyle = i%2? '#ff9ff3' : '#feca57';
              ctx.fillRect(-26 + i*9, -24, 8, 10);
            }
            // sign
            ctx.fillStyle = '#fff';
            ctx.font = '12px Segoe UI';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('חנות', 0, 2);
            ctx.restore();
          } else {
            // Person (bigger, more human-like)
            ctx.save();
            ctx.translate(sx, sy);

            // Clothing preset per resident
            const isNoa = npc.id === 'resident_noa';
            const isDani = npc.id === 'resident_dani';
            const isSandra = npc.id === 'resident_sandra';
            const isAlex = npc.id === 'resident_alex';
            const isBen = npc.id === 'resident_ben';
            
            // Walk animation for residents
            const walkSway = npc.kind === 'resident' ? Math.sin(npc.walkStep) * 0.3 : 0;

            // parameters
            const bodyLen = 56;
            const armLen = 28;
            const legLen = 34;
            const torsoWidth = 8;

            // shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(0, 16, 18, 8, 0, 0, Math.PI*2);
            ctx.fill();

            // torso - realistic body shape
            const skinColor = isAlex ? '#f4c2a1' : isBen ? '#e8b896' : '#ffd5b4';
            ctx.fillStyle = skinColor;
            
            // Main torso (oval shape)
            ctx.beginPath();
            ctx.ellipse(0, (-bodyLen/2 + 12) / 2, torsoWidth/2 + 2, (12 + bodyLen/2) / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Torso outline
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // Shoulders (wider part at top) - more detailed like main player
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(0, -bodyLen/2 + 6, torsoWidth/2 + 6, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Left shoulder muscle definition
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(-12, -bodyLen/2 + 8, 5, 7, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Right shoulder muscle definition
            ctx.beginPath();
            ctx.ellipse(12, -bodyLen/2 + 8, 5, 7, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Shoulder shadows for depth
            ctx.fillStyle = 'rgba(212, 165, 116, 0.3)';
            ctx.beginPath();
            ctx.ellipse(-8, -bodyLen/2 + 10, 3, 4, -0.2, 0, Math.PI * 2);
            ctx.ellipse(8, -bodyLen/2 + 10, 3, 4, 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Shoulder outline
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(0, -bodyLen/2 + 6, torsoWidth/2 + 6, 8, 0, 0, Math.PI * 2);
            ctx.ellipse(-12, -bodyLen/2 + 8, 5, 7, -0.3, 0, Math.PI * 2);
            ctx.ellipse(12, -bodyLen/2 + 8, 5, 7, 0.3, 0, Math.PI * 2);
            ctx.stroke();
            
            // Neck
            const neckTop = -bodyLen/2 - 4;
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(0, (neckTop + (-bodyLen/2 + 6)) / 2, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1;
            ctx.stroke();

            // clothing (before arms so arms are above clothes)
            if (isDani) {
              // Shirt - extended to cover shoulders
              roundRect(ctx, -18, -20, 36, 30, 8, '#2e86de', 'rgba(0,0,0,0.2)', 1.5);
              // Short sleeves
              ctx.fillStyle = '#2e86de';
              ctx.beginPath();
              ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
              ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
              ctx.fill();
              // Sleeve outlines
              ctx.strokeStyle = 'rgba(0,0,0,0.2)';
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
              ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
              ctx.stroke();
              // Pants - higher waist
              const danPantsStartY = 12 - 8;
              ctx.fillStyle = '#2d3436';
              ctx.fillRect(-10, danPantsStartY, 8, 26);
              ctx.fillRect(2, danPantsStartY, 8, 26);
              // Belt
              ctx.fillStyle = '#1a1a1a';
              ctx.fillRect(-10, danPantsStartY, 20, 2);
              // Shoes
              ctx.fillStyle = '#636e72';
              const danShoeY = danPantsStartY + 26;
              ctx.fillRect(-11, danShoeY, 10, 3);
              ctx.fillRect(1, danShoeY, 10, 3);
            } else if (isNoa || isSandra) {
              // Dress variant
              ctx.fillStyle = isSandra ? '#9b59b6' : '#e84393';
              ctx.beginPath();
              ctx.moveTo(-10, -8);
              ctx.lineTo(-18, 30);
              ctx.lineTo(18, 30);
              ctx.lineTo(10, -8);
              ctx.closePath();
              ctx.fill();
              // Waist ribbon
              ctx.fillStyle = isSandra ? '#d7bde2' : '#ffd1dc';
              ctx.fillRect(-10, 4, 20, 3);
              // Shoes
              ctx.fillStyle = isSandra ? '#8e44ad' : '#6c5ce7';
              ctx.fillRect(-12, 30, 9, 3);
              ctx.fillRect(3, 30, 9, 3);
            } else if (isAlex) {
              // Alex - Mechanic/Car enthusiast style
              // Work shirt - extended to cover shoulders
              roundRect(ctx, -18, -20, 36, 30, 8, '#e67e22', 'rgba(0,0,0,0.2)', 1.5);
              // Short sleeves
              ctx.fillStyle = '#e67e22';
              ctx.beginPath();
              ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
              ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
              ctx.fill();
              // Pocket detail
              ctx.fillStyle = '#d35400';
              ctx.fillRect(-8, -2, 6, 4);
              // Jeans - higher waist
              const alexPantsStartY = 12 - 8;
              ctx.fillStyle = '#34495e';
              ctx.fillRect(-10, alexPantsStartY, 8, 26);
              ctx.fillRect(2, alexPantsStartY, 8, 26);
              // Belt
              ctx.fillStyle = '#2c3e50';
              ctx.fillRect(-10, alexPantsStartY, 20, 2);
              // Work boots
              ctx.fillStyle = '#8b4513';
              const alexShoeY = alexPantsStartY + 26;
              ctx.fillRect(-11, alexShoeY, 10, 4);
              ctx.fillRect(1, alexShoeY, 10, 4);
            } else if (isBen) {
              // Ben - Business/Trader style
              // Business shirt - extended to cover shoulders
              roundRect(ctx, -18, -20, 36, 30, 8, '#ffffff', 'rgba(0,0,0,0.1)', 1.5);
              // Short sleeves
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
              ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
              ctx.fill();
              // Tie
              ctx.fillStyle = '#e74c3c';
              ctx.beginPath();
              ctx.moveTo(-1, -8);
              ctx.lineTo(-3, 12);
              ctx.lineTo(3, 12);
              ctx.lineTo(1, -8);
              ctx.closePath();
              ctx.fill();
              // Dress pants - higher waist
              const benPantsStartY = 12 - 8;
              ctx.fillStyle = '#2c3e50';
              ctx.fillRect(-10, benPantsStartY, 8, 26);
              ctx.fillRect(2, benPantsStartY, 8, 26);
              // Belt
              ctx.fillStyle = '#1a1a1a';
              ctx.fillRect(-10, benPantsStartY, 20, 2);
              // Dress shoes
              ctx.fillStyle = '#000000';
              const benShoeY = benPantsStartY + 26;
              ctx.fillRect(-11, benShoeY, 10, 3);
              ctx.fillRect(1, benShoeY, 10, 3);
            }

            // arms (slight pose) - realistic with hands, starting from sleeves
            ctx.strokeStyle = skinColor;
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            const shoulderY = -bodyLen/2 + 8;
            const leftShoulderX = -12;
            const rightShoulderX = 12;
            
            // left arm - starting from sleeve edge
            ctx.beginPath();
            const leftArmStartX = leftShoulderX - 3;
            const leftArmStartY = shoulderY + 6;
            ctx.moveTo(leftArmStartX, leftArmStartY);
            const leftArmEndX = leftArmStartX - Math.cos(0.6) * (armLen - 8);
            const leftArmEndY = leftArmStartY + Math.sin(0.6) * (armLen - 8);
            ctx.lineTo(leftArmEndX, leftArmEndY);
            ctx.stroke();
            
            // left elbow joint
            ctx.fillStyle = 'rgba(212, 165, 116, 0.5)';
            ctx.beginPath();
            const leftElbowX = leftArmStartX - Math.cos(0.6) * (armLen - 8) * 0.6;
            const leftElbowY = leftArmStartY + Math.sin(0.6) * (armLen - 8) * 0.6;
            ctx.arc(leftElbowX, leftElbowY, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // left hand
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.arc(leftArmEndX, leftArmEndY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // right arm - starting from sleeve edge
            ctx.strokeStyle = skinColor;
            ctx.lineWidth = 5;
            ctx.beginPath();
            const rightArmStartX = rightShoulderX + 3;
            const rightArmStartY = shoulderY + 6;
            ctx.moveTo(rightArmStartX, rightArmStartY);
            const rightArmEndX = rightArmStartX + Math.cos(0.6) * (armLen - 8);
            const rightArmEndY = rightArmStartY + Math.sin(0.6) * (armLen - 8);
            ctx.lineTo(rightArmEndX, rightArmEndY);
            ctx.stroke();
            
            // right elbow joint
            ctx.fillStyle = 'rgba(212, 165, 116, 0.5)';
            ctx.beginPath();
            const rightElbowX = rightArmStartX + Math.cos(0.6) * (armLen - 8) * 0.6;
            const rightElbowY = rightArmStartY + Math.sin(0.6) * (armLen - 8) * 0.6;
            ctx.arc(rightElbowX, rightElbowY, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // right hand
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.arc(rightArmEndX, rightArmEndY, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1;
            ctx.stroke();

            // legs (straight with feet) - realistic
            ctx.strokeStyle = skinColor;
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            const hipY = 12;
            
            // left leg - from hip (with walk animation)
            const leftFootLift = npc.kind === 'resident' ? walkSway * 4 : 0;
            ctx.beginPath();
            ctx.moveTo(-4, hipY);
            ctx.lineTo(-6, hipY + legLen + leftFootLift);
            ctx.stroke();
            
            // left knee (small joint)
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(-5, hipY + legLen/2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // left foot - detailed
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(-6, hipY + legLen + 2 + leftFootLift, 7, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // right leg - from hip (with walk animation)
            const rightFootLift = npc.kind === 'resident' ? -walkSway * 4 : 0;
            ctx.strokeStyle = skinColor;
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(4, hipY);
            ctx.lineTo(6, hipY + legLen + rightFootLift);
            ctx.stroke();
            
            // right knee (small joint)
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(5, hipY + legLen/2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // right foot - detailed
            ctx.fillStyle = skinColor;
            ctx.beginPath();
            ctx.ellipse(6, hipY + legLen + 2 + rightFootLift, 7, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1;
            ctx.stroke();

            // head
            const headY = -bodyLen/2 - 10;
            // back hair for Dani (short cap back)
            if (isDani) {
              ctx.save();
              ctx.fillStyle = '#3b3b3b';
              ctx.beginPath();
              ctx.arc(0, headY - 2, 10, Math.PI, Math.PI*2);
              ctx.fill();
              ctx.restore();
            }
            // long hair for Noa/Sandra
            if (isNoa || isSandra) {
              ctx.save();
              ctx.fillStyle = isSandra ? '#2c3e50' : '#5d3a1a';
              // back hair
              ctx.beginPath();
              ctx.ellipse(0, headY + 4, 12, 14, 0, 0, Math.PI*2);
              ctx.fill();
              // left strand
              ctx.beginPath();
              ctx.moveTo(-6, headY + 6);
              ctx.quadraticCurveTo(-12, headY + 22, -6, headY + 38);
              ctx.quadraticCurveTo(-2, headY + 26, -6, headY + 6);
              ctx.fill();
              // right strand
              ctx.beginPath();
              ctx.moveTo(6, headY + 6);
              ctx.quadraticCurveTo(12, headY + 22, 6, headY + 38);
              ctx.quadraticCurveTo(2, headY + 26, 6, headY + 6);
              ctx.fill();
              // bangs
              ctx.beginPath();
              ctx.arc(0, headY - 2, 10, Math.PI, Math.PI*2);
              ctx.fill();
              ctx.restore();
            }
            // Alex's hair - Short curly blonde hair
            if (isAlex) {
              ctx.save();
              ctx.fillStyle = '#daa520'; // golden blonde
              // back hair
              ctx.beginPath();
              ctx.ellipse(0, headY + 2, 11, 8, 0, 0, Math.PI*2);
              ctx.fill();
              // curly front
              ctx.beginPath();
              ctx.arc(-4, headY - 3, 4, 0, Math.PI*2);
              ctx.arc(4, headY - 3, 4, 0, Math.PI*2);
              ctx.arc(0, headY - 5, 5, 0, Math.PI*2);
              ctx.fill();
              ctx.restore();
            }
            // Ben's hair - Professional slicked back dark hair
            if (isBen) {
              ctx.save();
              ctx.fillStyle = '#2c3e50'; // dark professional
              // back hair
              ctx.beginPath();
              ctx.ellipse(0, headY + 1, 10, 9, 0, 0, Math.PI*2);
              ctx.fill();
              // slicked front
              ctx.beginPath();
              ctx.ellipse(0, headY - 4, 9, 6, 0, 0, Math.PI);
              ctx.fill();
              // side part
              ctx.strokeStyle = '#34495e';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(-2, headY - 6);
              ctx.lineTo(-2, headY - 2);
              ctx.stroke();
              ctx.restore();
            }
            // Head (skin color) - moved after hair for proper layering
            ctx.fillStyle = skinColor; // use the same skin color as body
            ctx.beginPath();
            ctx.arc(0, headY, 9, 0, Math.PI*2);
            ctx.fill();
            
            // Enhanced facial features for residents
            // eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-3, headY - 2, 1.5, 0, Math.PI*2);
            ctx.arc(3, headY - 2, 1.5, 0, Math.PI*2);
            ctx.fill();
            
            // pupils
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(-3, headY - 2, 1, 0, Math.PI*2);
            ctx.arc(3, headY - 2, 1, 0, Math.PI*2);
            ctx.fill();
            
            // eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-2.5, headY - 2.5, 0.3, 0, Math.PI*2);
            ctx.arc(3.5, headY - 2.5, 0.3, 0, Math.PI*2);
            ctx.fill();
            
            // nose
            ctx.strokeStyle = '#d4a574';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, headY - 1);
            ctx.lineTo(-0.5, headY + 0.5);
            ctx.moveTo(0, headY - 1);
            ctx.lineTo(0.5, headY + 0.5);
            ctx.stroke();
            
            // mouth (small smile)
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, headY + 1, 2.5, 0.3, Math.PI - 0.3);
            ctx.stroke();
            // front hair/fringe (on top) for Dani
            if (isDani) {
              ctx.save();
              ctx.fillStyle = '#3b3b3b';
              ctx.beginPath();
              ctx.arc(0, headY - 4, 9, Math.PI, Math.PI*2);
              ctx.fill();
              ctx.restore();
            }
            // (eyes already drawn above - removing duplicate)

            ctx.restore();
          }

          // Name label (adjusted down for bigger sprite)
          drawNpcName(npc.name, sx, sy + 36);
          
          // Quest indicators
          if (npc.kind === 'resident') {
            const quests = questMap.get(npc.id) || [];
            let hasCompletedQuest = false;
            let hasAvailableQuest = false;
            
            for (const quest of quests) {
              if (quest.state === 'completed') {
                hasCompletedQuest = true;
                break;
              } else if (quest.state === 'offer' && quest.cooldown <= 0) {
                hasAvailableQuest = true;
              }
            }
            
            // Draw quest indicators
            if (hasCompletedQuest) {
              // Golden exclamation mark for completed quest
              ctx.font = 'bold 20px Arial';
              ctx.fillStyle = '#ffd700';
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 2;
              ctx.textAlign = 'center';
              ctx.strokeText('!', sx, sy - 60);
              ctx.fillText('!', sx, sy - 60);
            } else if (hasAvailableQuest) {
              // White question mark for available quest
              ctx.font = 'bold 18px Arial';
              ctx.fillStyle = '#ffffff';
              ctx.strokeStyle = '#000';
              ctx.lineWidth = 2;
              ctx.textAlign = 'center';
              ctx.strokeText('?', sx, sy - 60);
              ctx.fillText('?', sx, sy - 60);
            }
          }
          
          // Quick mission indicator - above quest indicators
          if (currentQuickMission && quickMissionNPC && quickMissionNPC.id === npc.id) {
            ctx.save();
            
            // Pulsing arrow animation
            const pulseTime = performance.now() * 0.005;
            const pulse = Math.sin(pulseTime) * 0.3 + 0.7;
            ctx.globalAlpha = pulse;
            
            // Arrow background circle
            ctx.fillStyle = '#ff6b35';
            ctx.beginPath();
            ctx.arc(sx, sy - 90, 18 * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Arrow pointing down
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(sx, sy - 98);
            ctx.lineTo(sx - 6, sy - 90);
            ctx.lineTo(sx - 3, sy - 90);
            ctx.lineTo(sx - 3, sy - 82);
            ctx.lineTo(sx + 3, sy - 82);
            ctx.lineTo(sx + 3, sy - 90);
            ctx.lineTo(sx + 6, sy - 90);
            ctx.closePath();
            ctx.fill();
            
            // Mission type icon above arrow
            const missionIcons = {
              visit: '👥',
              delivery: '📦',
              help: '🤝',
              chat: '💬'
            };
            const icon = missionIcons[currentQuickMission.type] || '⚡';
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(icon, sx, sy - 105);
            
            ctx.restore();
          }

          // Talk hint when close (slightly higher)
          const d = Math.hypot(npc.x - player.x, npc.y - player.y);
          if (d < 90) drawHint('E — לדבר', sx, sy - 52);

          // Active dialog bubble
          if (activeNpcDialog && activeNpcDialog.npcId === npc.id && activeNpcDialog.timer > 0) {
            drawSpeechBubble(activeNpcDialog.text, sx, sy - 50);
          }
        }
      }

      function drawNpcName(name, sx, sy) {
        ctx.save();
        ctx.font = '13px Segoe UI';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        const w = Math.max(32, ctx.measureText(name).width + 12);
        roundRect(ctx, sx - w/2, sy, w, 18, 8, 'rgba(0,0,0,0.45)', 'rgba(255,255,255,0.12)', 1);
        ctx.fillStyle = '#fff';
        ctx.fillText(name, sx, sy + 2);
        ctx.restore();
      }
      function drawHint(text, sx, sy) {
        ctx.save();
        ctx.font = '12px Segoe UI';
        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        roundRect(ctx, sx - 40, sy - 18, 80, 18, 8, 'rgba(0,0,0,0.6)', 'rgba(255,255,255,0.15)', 1);
        ctx.fillStyle = '#ffd700';
        ctx.fillText(text, sx, sy - 4);
        ctx.restore();
      }
      function drawSpeechBubble(text, sx, sy) {
        ctx.save();
        ctx.font = '14px Segoe UI';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        const maxWidth = 220;
        const lines = wrapText(ctx, text, maxWidth - 16);
        const w = Math.max(40, Math.min(maxWidth, Math.max(...lines.map(l=>ctx.measureText(l).width)) + 16));
        const h = lines.length * 18 + 12;
        roundRect(ctx, sx - w/2, sy - h, w, h, 10, 'rgba(255,255,255,0.95)', 'rgba(0,0,0,0.2)', 1.5);
        let y = sy - h + 6;
        ctx.fillStyle = '#222';
        for (const line of lines) { ctx.fillText(line, sx, y); y += 18; }
        ctx.restore();
      }

      function drawPlaza(camX, camY){
        const cx = plaza.x - camX;
        const cy = plaza.y - camY;
        // round colored carpet
        const grd = ctx.createRadialGradient(cx, cy, 20, cx, cy, plaza.radius);
        grd.addColorStop(0,'rgba(186,85,211,0.35)');
        grd.addColorStop(1,'rgba(186,85,211,0.0)');
        ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(cx, cy, plaza.radius, 0, Math.PI*2); ctx.fill();

        // central fountain
        ctx.save();
        ctx.translate(cx, cy);
        // base stone
        ctx.fillStyle = '#576574';
        ctx.beginPath(); ctx.arc(0, 0, 90, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#778ca3';
        ctx.beginPath(); ctx.arc(0, 0, 70, 0, Math.PI*2); ctx.fill();
        // water
        const waterG = ctx.createLinearGradient(-60,-20,60,40);
        waterG.addColorStop(0,'#74b9ff'); waterG.addColorStop(1,'#00a8ff');
        ctx.fillStyle = waterG; ctx.beginPath(); ctx.arc(0, 0, 52, 0, Math.PI*2); ctx.fill();
        // water shine
        ctx.fillStyle='rgba(255,255,255,0.35)'; ctx.beginPath(); ctx.ellipse(-12,-10,22,10,0,0,Math.PI*2); ctx.fill();
        ctx.restore();

        // benches
        drawBench(cx-180, cy+100);
        drawBench(cx+180, cy+110);

        // balloons poles
        drawBalloons(cx-210, cy-40);
        drawBalloons(cx+210, cy-30);
      }
      function drawBench(x,y){
        ctx.save(); ctx.translate(x,y);
        ctx.fillStyle = '#a0522d'; ctx.fillRect(-40,0,80,10);
        ctx.fillRect(-40,-14,80,10); ctx.fillRect(-40,-28,80,10);
        ctx.fillStyle = '#2d3436'; ctx.fillRect(-36,10,8,18); ctx.fillRect(28,10,8,18);
        ctx.restore();
      }
      function drawBalloons(x,y){
        ctx.save(); ctx.translate(x,y);
        ctx.strokeStyle = '#2d3436'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-40); ctx.stroke();
        const cols=['#e74c3c','#f1c40f','#2ecc71','#3498db'];
        for(let i=0;i<4;i++){
          ctx.fillStyle = cols[i]; ctx.beginPath(); ctx.arc(-12+i*8, -48-(i%2)*6, 6, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
      }
      function drawConfetti(camX,camY){
        for(const p of confetti){
          const sx = p.x - camX; const sy = p.y - camY;
          ctx.save(); ctx.translate(sx,sy); ctx.rotate(p.rot);
          ctx.fillStyle = p.col; ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
          ctx.restore();
        }
      }

      function drawCollectibles(camX, camY) {
        for (const g of collectibles) {
          if (g.picked) continue;
          const sx = g.x - camX;
          const sy = g.y - camY;
          // gift box
          ctx.save();
          ctx.translate(sx, sy);
          const t = performance.now() * 0.002;
          const bob = Math.sin(t + sx*0.01 + sy*0.01) * 3;
          ctx.translate(0, bob);
          // box
          ctx.fillStyle = '#c0392b';
          ctx.strokeStyle = '#922b21';
          ctx.lineWidth = 2;
          roundRect(ctx, -14, -14, 28, 28, 6, ctx.fillStyle, ctx.strokeStyle, 2);
          // ribbon
          ctx.fillStyle = '#f1c40f';
          ctx.fillRect(-3, -14, 6, 28);
          ctx.fillRect(-14, -3, 28, 6);
          ctx.restore();
        }
      }

      function drawCoins(camX, camY) {
        const t = performance.now() * 0.004;
        for (const c of coinsOnMap) {
          const sx = c.x - camX;
          const sy = c.y - camY;
          ctx.save();
          ctx.translate(sx, sy);
          const bob = Math.sin(t + sx*0.02 + sy*0.02) * 2;
          ctx.translate(0, bob);
          // glow
          ctx.shadowColor = 'rgba(255,215,0,0.7)';
          ctx.shadowBlur = 12;
          // coin base
          const r = 10;
          const grad = ctx.createRadialGradient(0, 0, 2, 0, 0, r);
          grad.addColorStop(0, '#fff3b0');
          grad.addColorStop(1, '#ffbf00');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.fill();
          // coin edge
          ctx.strokeStyle = '#b8860b';
          ctx.lineWidth = 2;
          ctx.stroke();
          // star sparkle
          ctx.shadowBlur = 0;
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          const a = t * 2;
          ctx.moveTo(Math.cos(a) * 0, -r + 3);
          ctx.lineTo(0, r - 3);
          ctx.moveTo(-r + 3, 0);
          ctx.lineTo(r - 3, 0);
          ctx.stroke();
          ctx.restore();
        }
      }

      function drawPlayer(px, py) {
        ctx.save();
        ctx.translate(px, py);

        // body parameters
        const bodyLen = 44;
        const armLen = 34;
        const legLen = 38;
        const torsoWidth = 10;

        // shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.ellipse(0, 18, 20, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // rotate to facing
        ctx.rotate(player.angle);

        // Get current dance pose or use default walk cycle
        const dancePose = getDancePose();
        const s = Math.sin(player.step);
        const swing = 0.8 * Math.min(1, Math.hypot(player.vx, player.vy) / (MAX_SPEED * 0.6));
        
        // Dance-specific modifications
        let armOffsetLeft = 0, armOffsetRight = 0;
        let legOffsetLeft = 0, legOffsetRight = 0;
        let bodyTilt = 0;
        let headBob = 0;
        
        if (isDancing) {
          const danceTime = (performance.now() - danceStartTime) / 1000;
          
          switch (dancePose) {
            case 'up':
              armOffsetLeft = -Math.PI/4;
              armOffsetRight = -Math.PI/4;
              headBob = -8;
              break;
            case 'side':
              armOffsetLeft = Math.PI/2;
              armOffsetRight = -Math.PI/2;
              bodyTilt = Math.sin(danceTime * 4) * 0.2;
              break;
            case 'down':
              armOffsetLeft = Math.PI/3;
              armOffsetRight = Math.PI/3;
              legOffsetLeft = 8;
              legOffsetRight = 8;
              break;
            case 'twist':
              bodyTilt = Math.sin(danceTime * 6) * 0.3;
              armOffsetLeft = Math.sin(danceTime * 5) * Math.PI/3;
              armOffsetRight = -Math.sin(danceTime * 5) * Math.PI/3;
              break;
            case 'point_up':
              armOffsetLeft = -Math.PI/2;
              armOffsetRight = Math.PI/4;
              headBob = -5;
              break;
            case 'point_down':
              armOffsetLeft = Math.PI/2;
              armOffsetRight = Math.PI/2;
              break;
            case 'spin':
              ctx.rotate(Math.sin(danceTime * 8) * 0.5);
              armOffsetLeft = Math.PI/4;
              armOffsetRight = -Math.PI/4;
              break;
            case 'lean':
              bodyTilt = Math.PI/8;
              armOffsetLeft = -Math.PI/6;
              armOffsetRight = Math.PI/3;
              break;
            case 'groove':
              bodyTilt = Math.sin(danceTime * 4) * 0.15;
              armOffsetLeft = Math.sin(danceTime * 3) * Math.PI/6;
              armOffsetRight = -Math.sin(danceTime * 3) * Math.PI/6;
              break;
            case 'freeze':
              // Breakdance freeze - dramatic pose
              armOffsetLeft = -Math.PI/2;
              armOffsetRight = Math.PI;
              legOffsetLeft = -10;
              bodyTilt = Math.PI/6;
              break;
            case 'windmill':
              ctx.rotate(danceTime * 10 % (Math.PI * 2));
              armOffsetLeft = Math.PI;
              armOffsetRight = Math.PI;
              break;
            case 'headspin':
              ctx.rotate(-danceTime * 15 % (Math.PI * 2));
              headBob = -15;
              break;
            case 'robot':
            case 'lock1':
            case 'lock2':
              // Robot-like sharp movements
              armOffsetLeft = Math.floor(danceTime * 2) % 2 === 0 ? Math.PI/2 : -Math.PI/4;
              armOffsetRight = Math.floor(danceTime * 2) % 2 === 0 ? -Math.PI/4 : Math.PI/2;
              break;
            case 'wave1':
            case 'wave2':
            case 'wave3':
            case 'wave4':
            case 'wave5':
            case 'wave6':
            case 'wave7':
            case 'wave8':
              // Wave motion through body
              const wavePhase = (parseInt(dancePose.slice(-1)) - 1) / 8 * Math.PI * 2;
              armOffsetLeft = Math.sin(wavePhase) * Math.PI/3;
              armOffsetRight = Math.sin(wavePhase + Math.PI/4) * Math.PI/3;
              bodyTilt = Math.sin(wavePhase + Math.PI/2) * 0.2;
              break;
            case 'moonwalk':
            case 'slide_back':
            case 'slide_back2':
            case 'slide_back3':
            case 'slide_back4':
              // Moonwalk lean
              bodyTilt = -Math.PI/12;
              legOffsetLeft = Math.sin(danceTime * 4) * 5;
              legOffsetRight = -Math.sin(danceTime * 4) * 5;
              break;
            case 'electric':
            case 'shock1':
            case 'shock2':
            case 'shock3':
            case 'shock4':
            case 'shock5':
            case 'shock6':
            case 'shock7':
            case 'shock8':
            case 'shock9':
            case 'shock10':
              // Electric shock movements
              armOffsetLeft = (Math.random() - 0.5) * Math.PI;
              armOffsetRight = (Math.random() - 0.5) * Math.PI;
              bodyTilt = (Math.random() - 0.5) * 0.3;
              headBob = (Math.random() - 0.5) * 10;
              break;
            case 'bounce':
              headBob = Math.abs(Math.sin(danceTime * 4)) * -10;
              legOffsetLeft = Math.abs(Math.sin(danceTime * 4)) * 8;
              legOffsetRight = Math.abs(Math.sin(danceTime * 4)) * 8;
              break;
            case 'swing_left':
              bodyTilt = -Math.PI/6;
              armOffsetLeft = Math.PI/2;
              armOffsetRight = -Math.PI/4;
              break;
            case 'swing_right':
              bodyTilt = Math.PI/6;
              armOffsetLeft = -Math.PI/4;
              armOffsetRight = Math.PI/2;
              break;
            case 'ballet':
            case 'arabesque':
              // Ballet pose - one leg back, arms graceful
              armOffsetLeft = -Math.PI/4;
              armOffsetRight = Math.PI/6;
              legOffsetRight = -12;
              bodyTilt = Math.PI/12;
              break;
            case 'pirouette':
              ctx.rotate(danceTime * 6 % (Math.PI * 2));
              armOffsetLeft = -Math.PI/3;
              armOffsetRight = -Math.PI/3;
              break;
            case 'plie':
              // Ballet plie - knees bent, arms rounded
              armOffsetLeft = -Math.PI/6;
              armOffsetRight = Math.PI/6;
              legOffsetLeft = 6;
              legOffsetRight = 6;
              break;
            case 'grand_jete':
              // Ballet jump - one leg forward, one back
              armOffsetLeft = -Math.PI/4;
              armOffsetRight = Math.PI/4;
              legOffsetLeft = -8;
              legOffsetRight = 12;
              headBob = -6;
              break;
            case 'port_de_bras':
              // Ballet arm movements
              armOffsetLeft = Math.sin(danceTime * 2) * Math.PI/4;
              armOffsetRight = Math.cos(danceTime * 2) * Math.PI/4;
              break;
            case 'basic':
            case 'cross':
            case 'turn':
            case 'dip':
              // Salsa moves
              bodyTilt = Math.sin(danceTime * 3) * 0.15;
              armOffsetLeft = Math.cos(danceTime * 2) * Math.PI/6;
              armOffsetRight = Math.sin(danceTime * 2) * Math.PI/6;
              break;
            case 'promenade':
            case 'corte':
            case 'ocho':
            case 'giro':
            case 'gancho':
            case 'close':
              // Tango moves
              bodyTilt = Math.sin(danceTime * 2) * 0.2;
              armOffsetLeft = -Math.PI/8;
              armOffsetRight = Math.PI/4;
              legOffsetLeft = Math.sin(danceTime * 3) * 3;
              break;
            case 'backspin':
              ctx.rotate(danceTime * -12 % (Math.PI * 2));
              armOffsetLeft = Math.PI/2;
              armOffsetRight = Math.PI/2;
              legOffsetLeft = -5;
              legOffsetRight = -5;
              break;
            case 'flare':
              ctx.rotate(danceTime * 8 % (Math.PI * 2));
              armOffsetLeft = Math.PI;
              armOffsetRight = 0;
              bodyTilt = Math.PI/3;
              break;
            case 'toprock':
              armOffsetLeft = Math.sin(danceTime * 4) * Math.PI/3;
              armOffsetRight = -Math.sin(danceTime * 4) * Math.PI/3;
              legOffsetLeft = Math.cos(danceTime * 4) * 5;
              legOffsetRight = -Math.cos(danceTime * 4) * 5;
              break;
            case 'sixstep':
              const stepPhase = (danceTime * 6) % 6;
              armOffsetLeft = Math.sin(stepPhase) * Math.PI/4;
              armOffsetRight = Math.cos(stepPhase) * Math.PI/4;
              legOffsetLeft = Math.sin(stepPhase * 2) * 8;
              legOffsetRight = Math.cos(stepPhase * 2) * 8;
              break;
            case 'isolate':
              // Robot isolation moves
              if (Math.floor(danceTime * 3) % 3 === 0) {
                headBob = -5;
              } else if (Math.floor(danceTime * 3) % 3 === 1) {
                bodyTilt = Math.PI/12;
              } else {
                armOffsetLeft = Math.PI/2;
                armOffsetRight = 0;
              }
              break;
            case 'step':
            case 'cross':
            case 'point':
              // Hip-hop steps
              legOffsetLeft = Math.sin(danceTime * 4) * 6;
              legOffsetRight = -Math.sin(danceTime * 4) * 6;
              armOffsetLeft = Math.cos(danceTime * 3) * Math.PI/6;
              armOffsetRight = -Math.cos(danceTime * 3) * Math.PI/6;
              break;
          }
        }

        // Apply body tilt for dance moves
        if (bodyTilt !== 0) {
          ctx.rotate(bodyTilt);
        }
        
        // legs (with dance modifications) - more realistic
        ctx.strokeStyle = '#ffd5b4'; // skin color for legs
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        const hipX = 0, hipY = 12;
        const footLift = isDancing ? 6 : 4; // more dramatic lifting when dancing
        const leftLift = isDancing ? (footLift * s + legOffsetLeft) : footLift * s;
        const rightLift = isDancing ? (-footLift * s + legOffsetRight) : -footLift * s;

        // left leg - from hip
        ctx.beginPath();
        ctx.moveTo(hipX - 4, hipY);
        ctx.lineTo(hipX - 6, hipY + legLen + leftLift);
        ctx.stroke();
        
        // left knee (small joint)
        ctx.fillStyle = '#d4a574';
        ctx.beginPath();
        ctx.arc(hipX - 5, hipY + legLen/2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // left foot - more detailed with toes
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(hipX - 6, hipY + legLen + leftLift + 2, 7, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Left foot toes (5 toes)
        ctx.fillStyle = '#ffd5b4';
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 0.5;
        for (let t = 0; t < 5; t++) {
          const toeX = hipX - 6 + (t - 2) * 1.5; // Spread toes across foot
          const toeY = hipY + legLen + leftLift + 2 - 3; // Position at front of foot
          const toeSize = t === 1 ? 1.2 : (t === 0 || t === 4 ? 0.8 : 1); // Big toe bigger, pinky smaller
          
          ctx.beginPath();
          ctx.arc(toeX, toeY, toeSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }

        // right leg - from hip
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(hipX + 4, hipY);
        ctx.lineTo(hipX + 6, hipY + legLen + rightLift);
        ctx.stroke();
        
        // right knee (small joint)
        ctx.fillStyle = '#d4a574';
        ctx.beginPath();
        ctx.arc(hipX + 5, hipY + legLen/2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // right foot - more detailed with toes
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(hipX + 6, hipY + legLen + rightLift + 2, 7, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Right foot toes (5 toes)
        ctx.fillStyle = '#ffd5b4';
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 0.5;
        for (let t = 0; t < 5; t++) {
          const toeX = hipX + 6 + (t - 2) * 1.5; // Spread toes across foot
          const toeY = hipY + legLen + rightLift + 2 - 3; // Position at front of foot
          const toeSize = t === 1 ? 1.2 : (t === 0 || t === 4 ? 0.8 : 1); // Big toe bigger, pinky smaller
          
          ctx.beginPath();
          ctx.arc(toeX, toeY, toeSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        }

        // torso - draw as body shape instead of line
        ctx.fillStyle = '#ffd5b4'; // skin color
        
        // Main torso (oval shape)
        ctx.beginPath();
        ctx.ellipse(0, (-bodyLen/2 + hipY) / 2, torsoWidth/2 + 2, (hipY + bodyLen/2) / 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Chest muscle definition
        ctx.fillStyle = 'rgba(212, 165, 116, 0.25)';
        ctx.beginPath();
        ctx.ellipse(-4, -bodyLen/2 + 12, 4, 6, -0.1, 0, Math.PI);
        ctx.ellipse(4, -bodyLen/2 + 12, 4, 6, 0.1, 0, Math.PI);
        ctx.fill();
        
        // Abs definition (subtle lines)
        ctx.strokeStyle = 'rgba(212, 165, 116, 0.4)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Vertical ab line
        ctx.moveTo(0, -bodyLen/2 + 18);
        ctx.lineTo(0, hipY - 5);
        // Horizontal ab lines
        ctx.moveTo(-3, -bodyLen/2 + 22);
        ctx.lineTo(3, -bodyLen/2 + 22);
        ctx.moveTo(-3, -2);
        ctx.lineTo(3, -2);
        ctx.moveTo(-3, 5);
        ctx.lineTo(3, 5);
        ctx.stroke();
        
        // Torso outline
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.ellipse(0, (-bodyLen/2 + hipY) / 2, torsoWidth/2 + 2, (hipY + bodyLen/2) / 2, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Shoulders (wider part at top) - more detailed
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(0, -bodyLen/2 + 6, torsoWidth/2 + 6, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Left shoulder muscle definition
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(-12, -bodyLen/2 + 8, 5, 7, -0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right shoulder muscle definition
        ctx.beginPath();
        ctx.ellipse(12, -bodyLen/2 + 8, 5, 7, 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Shoulder shadows for depth
        ctx.fillStyle = 'rgba(212, 165, 116, 0.3)';
        ctx.beginPath();
        ctx.ellipse(-8, -bodyLen/2 + 10, 3, 4, -0.2, 0, Math.PI * 2);
        ctx.ellipse(8, -bodyLen/2 + 10, 3, 4, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Shoulder outline
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.ellipse(0, -bodyLen/2 + 6, torsoWidth/2 + 6, 8, 0, 0, Math.PI * 2);
        ctx.ellipse(-12, -bodyLen/2 + 8, 5, 7, -0.3, 0, Math.PI * 2);
        ctx.ellipse(12, -bodyLen/2 + 8, 5, 7, 0.3, 0, Math.PI * 2);
        ctx.stroke();

        // clothing (shirt/chest, pants, shoes)
        {
          // Chest/Shirt (check for equipped chest item first) - now wider to cover shoulders
          if (equipped.chest) {
            if (equipped.chest === 'birthday_shirt_1') {
              // Birthday shirt with cake design - extended to cover shoulders
              roundRect(ctx, -18, -20, 36, 30, 8, '#ff6b9d', 'rgba(0,0,0,0.2)', 1.5);
              // Short sleeves
              ctx.fillStyle = '#ff6b9d';
              ctx.beginPath();
              ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
              ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
              ctx.fill();
              // Cake design
              ctx.fillStyle = '#ffd700';
              ctx.fillRect(-4, -8, 8, 6);
              ctx.fillStyle = '#fff';
              ctx.fillRect(-1, -12, 2, 4); // candle
              ctx.fillStyle = '#ff4757';
              ctx.beginPath();
              ctx.arc(0, -12, 1, 0, Math.PI * 2);
              ctx.fill(); // flame
            } else if (equipped.chest === 'birthday_shirt_2') {
              // Birthday shirt with gifts - extended to cover shoulders
              roundRect(ctx, -18, -20, 36, 30, 8, '#4ecdc4', 'rgba(0,0,0,0.2)', 1.5);
              // Short sleeves
              ctx.fillStyle = '#4ecdc4';
              ctx.beginPath();
              ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
              ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
              ctx.fill();
              // Gift boxes
              ctx.fillStyle = '#ffd700';
              ctx.fillRect(-6, -10, 4, 4);
              ctx.fillRect(2, -8, 3, 3);
              ctx.strokeStyle = '#ff4757';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(-6, -8); ctx.lineTo(-2, -8);
              ctx.moveTo(-4, -10); ctx.lineTo(-4, -6);
              ctx.moveTo(2, -6.5); ctx.lineTo(5, -6.5);
              ctx.moveTo(3.5, -8); ctx.lineTo(3.5, -5);
              ctx.stroke();
            } else if (equipped.chest === 'party_shirt') {
              // Colorful party shirt - extended to cover shoulders
              const gradient = ctx.createLinearGradient(-18, -20, 18, 10);
              gradient.addColorStop(0, '#ff6b9d');
              gradient.addColorStop(0.5, '#ffeaa7');
              gradient.addColorStop(1, '#4ecdc4');
              roundRect(ctx, -18, -20, 36, 30, 8, gradient, 'rgba(0,0,0,0.2)', 1.5);
              // Short sleeves
              ctx.fillStyle = '#ffeaa7';
              ctx.beginPath();
              ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
              ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
              ctx.fill();
              // Confetti pattern
              const confettiColors = ['#fff', '#ff4757', '#74b9ff'];
              for (let i = 0; i < 6; i++) {
                ctx.fillStyle = confettiColors[i % confettiColors.length];
                const x = (i % 3 - 1) * 6;
                const y = -10 + Math.floor(i / 3) * 6;
                ctx.fillRect(x, y, 2, 2);
              }
            }
          } else {
            // Default shirt - extended to cover shoulders
            roundRect(ctx, -18, -20, 36, 30, 8, '#4a90e2', 'rgba(0,0,0,0.2)', 1.5);
            // Short sleeves
            ctx.fillStyle = '#4a90e2';
            ctx.beginPath();
            ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
            ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Sleeve outlines
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(-15, -bodyLen/2 + 8, 6, 8, -0.3, 0, Math.PI * 2);
            ctx.ellipse(15, -bodyLen/2 + 8, 6, 8, 0.3, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          // Pants (higher waist to cover properly)
          ctx.fillStyle = '#2d3436';
          const pantsStartY = hipY - 8; // Start pants higher
          ctx.fillRect(-10, pantsStartY, 9, 26); // Make pants longer
          ctx.fillRect(1, pantsStartY, 9, 26);
          
          // Belt (optional detail)
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(-10, pantsStartY, 20, 2);
          // Shoes (adjusted to new pants length)
          ctx.fillStyle = '#636e72';
          const shoeY = pantsStartY + 26; // Position shoes at end of pants
          ctx.fillRect(-11, shoeY, 11, 3);
          ctx.fillRect(0, shoeY, 11, 3);
        }

        // arms (with dance modifications) - starting from shoulders
        ctx.strokeStyle = '#ffd5b4'; // skin color for arms
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        
        const shoulderY = -bodyLen/2 + 8; // shoulder position
        const leftShoulderX = -12; // left shoulder position
        const rightShoulderX = 12; // right shoulder position
        
        // left arm - starting from sleeve edge
        ctx.beginPath();
        const leftArmStartX = leftShoulderX - 3; // start from edge of sleeve
        const leftArmStartY = shoulderY + 6; // slightly lower to connect with sleeve
        ctx.moveTo(leftArmStartX, leftArmStartY);
        const la = isDancing ? (1.2 + armOffsetLeft) : (1.2 + swing * s * 0.3);
        const leftArmEndX = leftArmStartX + Math.cos(la) * (armLen - 8); // shorter to account for sleeve
        const leftArmEndY = leftArmStartY + Math.sin(la) * (armLen - 8);
        ctx.lineTo(leftArmEndX, leftArmEndY);
        ctx.stroke();
        
        // left elbow joint (subtle)
        ctx.fillStyle = 'rgba(212, 165, 116, 0.5)';
        ctx.beginPath();
        const leftElbowX = leftArmStartX + Math.cos(la) * (armLen - 8) * 0.6;
        const leftElbowY = leftArmStartY + Math.sin(la) * (armLen - 8) * 0.6;
        ctx.arc(leftElbowX, leftElbowY, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // left hand with fingers
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.arc(leftArmEndX, leftArmEndY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Left hand fingers (5 fingers)
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        const leftHandAngle = Math.atan2(leftArmEndY - leftArmStartY, leftArmEndX - leftArmStartX);
        for (let f = 0; f < 5; f++) {
          const fingerAngle = leftHandAngle + (f - 2) * 0.3; // Spread fingers
          const fingerLength = 3;
          const fingerStartX = leftArmEndX + Math.cos(leftHandAngle + Math.PI/2) * (f - 2) * 1.5;
          const fingerStartY = leftArmEndY + Math.sin(leftHandAngle + Math.PI/2) * (f - 2) * 1.5;
          const fingerEndX = fingerStartX + Math.cos(fingerAngle) * fingerLength;
          const fingerEndY = fingerStartY + Math.sin(fingerAngle) * fingerLength;
          
          ctx.beginPath();
          ctx.moveTo(fingerStartX, fingerStartY);
          ctx.lineTo(fingerEndX, fingerEndY);
          ctx.stroke();
        }
        
        // right arm - starting from sleeve edge
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 5;
        ctx.beginPath();
        const rightArmStartX = rightShoulderX + 3; // start from edge of sleeve
        const rightArmStartY = shoulderY + 6; // slightly lower to connect with sleeve
        ctx.moveTo(rightArmStartX, rightArmStartY);
        const ra = isDancing ? (1.2 + armOffsetRight) : (1.2 - swing * s * 0.3);
        const rightArmEndX = rightArmStartX + Math.cos(ra) * (armLen - 8); // shorter to account for sleeve
        const rightArmEndY = rightArmStartY + Math.sin(ra) * (armLen - 8);
        ctx.lineTo(rightArmEndX, rightArmEndY);
        ctx.stroke();
        
        // right elbow joint (subtle)
        ctx.fillStyle = 'rgba(212, 165, 116, 0.5)';
        ctx.beginPath();
        const rightElbowX = rightArmStartX + Math.cos(ra) * (armLen - 8) * 0.6;
        const rightElbowY = rightArmStartY + Math.sin(ra) * (armLen - 8) * 0.6;
        ctx.arc(rightElbowX, rightElbowY, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // right hand with fingers
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.arc(rightArmEndX, rightArmEndY, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Right hand fingers (5 fingers)
        ctx.strokeStyle = '#ffd5b4';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        const rightHandAngle = Math.atan2(rightArmEndY - rightArmStartY, rightArmEndX - rightArmStartX);
        for (let f = 0; f < 5; f++) {
          const fingerAngle = rightHandAngle + (f - 2) * 0.3; // Spread fingers
          const fingerLength = 3;
          const fingerStartX = rightArmEndX + Math.cos(rightHandAngle + Math.PI/2) * (f - 2) * 1.5;
          const fingerStartY = rightArmEndY + Math.sin(rightHandAngle + Math.PI/2) * (f - 2) * 1.5;
          const fingerEndX = fingerStartX + Math.cos(fingerAngle) * fingerLength;
          const fingerEndY = fingerStartY + Math.sin(fingerAngle) * fingerLength;
          
          ctx.beginPath();
          ctx.moveTo(fingerStartX, fingerStartY);
          ctx.lineTo(fingerEndX, fingerEndY);
          ctx.stroke();
        }

        // neck (connection between head and body)
        const neckTop = -bodyLen/2 - 6;
        const headY = -bodyLen/2 - 16 + headBob;
        
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(0, (neckTop + headY + 8) / 2, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // head (with dance head bob)
        
        // Main hair covering the head
        ctx.fillStyle = '#4a3424'; // dark brown hair
        ctx.beginPath();
        ctx.ellipse(0, headY - 8, 18, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Side hair (fuller)
        ctx.beginPath();
        ctx.ellipse(-15, headY - 4, 5, 10, -0.2, 0, Math.PI * 2);
        ctx.ellipse(15, headY - 4, 5, 10, 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Hair covering forehead area
        ctx.fillStyle = '#5d4037'; // slightly lighter brown
        ctx.beginPath();
        ctx.moveTo(-14, headY - 16);
        ctx.quadraticCurveTo(-8, headY - 18, 0, headY - 16);
        ctx.quadraticCurveTo(8, headY - 18, 14, headY - 16);
        ctx.quadraticCurveTo(12, headY - 12, 8, headY - 10);
        ctx.quadraticCurveTo(4, headY - 8, 0, headY - 9);
        ctx.quadraticCurveTo(-4, headY - 8, -8, headY - 10);
        ctx.quadraticCurveTo(-12, headY - 12, -14, headY - 16);
        ctx.fill();
        
        // Scattered bangs on forehead (more visible)
        ctx.strokeStyle = '#4a3424';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        // Individual hair strands falling on forehead
        const bangPositions = [-10, -6, -2, 1, 5, 8, 11];
        for(let i = 0; i < bangPositions.length; i++) {
          const x = bangPositions[i];
          const startY = headY - 10;
          const endY = headY - 4 - (i % 2); // vary end points
          
          ctx.beginPath();
          ctx.moveTo(x, startY);
          ctx.quadraticCurveTo(x + (i % 2 === 0 ? -0.5 : 0.5), startY + 2, x + (i % 3 === 0 ? -1 : 1), endY);
          ctx.stroke();
        }
        
        // Additional small hair wisps
        ctx.lineWidth = 2;
        for(let i = 0; i < 4; i++) {
          const x = -8 + i * 5;
          ctx.beginPath();
          ctx.moveTo(x, headY - 9);
          ctx.lineTo(x + (i % 2 === 0 ? -1 : 1), headY - 6);
          ctx.stroke();
        }
        
        // Hair texture lines (more detailed)
        ctx.strokeStyle = 'rgba(58, 40, 28, 0.4)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i = -3; i <= 3; i++) {
          ctx.moveTo(i * 2.5, headY - 14);
          ctx.lineTo(i * 2.5 + (Math.random() - 0.5), headY - 10);
        }
        ctx.stroke();
        
        // head (skin) with human-like face shape
        const skinGradient = ctx.createRadialGradient(-3, headY - 2, 0, 0, headY, 18);
        skinGradient.addColorStop(0, '#ffe4c4'); // lighter skin tone
        skinGradient.addColorStop(1, '#deb887'); // darker skin shadow
        ctx.fillStyle = skinGradient;
        
        // Human face shape (not just a circle)
        ctx.beginPath();
        // Forehead (wider at top)
        ctx.moveTo(-14, headY - 12);
        ctx.quadraticCurveTo(-16, headY - 6, -15, headY);
        // Left cheek to jaw
        ctx.quadraticCurveTo(-14, headY + 6, -8, headY + 10);
        // Chin area (narrower)
        ctx.quadraticCurveTo(-4, headY + 12, 0, headY + 12);
        ctx.quadraticCurveTo(4, headY + 12, 8, headY + 10);
        // Right jaw to cheek
        ctx.quadraticCurveTo(14, headY + 6, 15, headY);
        // Right temple to forehead
        ctx.quadraticCurveTo(16, headY - 6, 14, headY - 12);
        // Forehead curve
        ctx.quadraticCurveTo(8, headY - 16, 0, headY - 16);
        ctx.quadraticCurveTo(-8, headY - 16, -14, headY - 12);
        ctx.closePath();
        ctx.fill();
        
        // Add jawline definition
        ctx.strokeStyle = 'rgba(184, 134, 11, 0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-8, headY + 10);
        ctx.quadraticCurveTo(0, headY + 12, 8, headY + 10);
        ctx.stroke();
        
        // Chin cleft (dimple in chin)
        ctx.strokeStyle = 'rgba(184, 134, 11, 0.3)';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.moveTo(0, headY + 10);
        ctx.lineTo(0, headY + 12);
        ctx.stroke();
        
        // Face shadow on right side
        ctx.fillStyle = 'rgba(184, 134, 11, 0.15)';
        ctx.beginPath();
        ctx.arc(6, headY + 2, 12, Math.PI * 0.3, Math.PI * 1.7);
        ctx.fill();
        
        // Ears on both sides of the head (smaller and closer)
        ctx.fillStyle = '#ffd5b4'; // same skin color as head
        
        // Left ear (smaller)
        ctx.beginPath();
        ctx.ellipse(-14, headY - 1, 2.5, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Left ear outline
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.ellipse(-14, headY - 1, 2.5, 4, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Left ear inner detail (simple)
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.arc(-14.2, headY - 0.5, 1.2, 0.3, Math.PI - 0.3);
        ctx.stroke();
        
        // Right ear (smaller)
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.ellipse(14, headY - 1, 2.5, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Right ear outline
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.ellipse(14, headY - 1, 2.5, 4, 0, 0, Math.PI * 2);
        ctx.stroke();
        
        // Right ear inner detail (simple)
        ctx.strokeStyle = '#d4a574';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.arc(14.2, headY - 0.5, 1.2, 0.3, Math.PI - 0.3);
        ctx.stroke();
        
        // Eyebrows (cool and expressive)
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        // Left eyebrow (angled)
        ctx.moveTo(-9, headY - 8);
        ctx.lineTo(-3, headY - 7);
        // Right eyebrow (angled)
        ctx.moveTo(3, headY - 7);
        ctx.lineTo(9, headY - 8);
        ctx.stroke();
        
        // Eye whites (larger and more detailed)
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.ellipse(-5, headY - 3, 3.5, 2.8, 0, 0, Math.PI * 2);  // left eye white
        ctx.ellipse(5, headY - 3, 3.5, 2.8, 0, 0, Math.PI * 2);   // right eye white
        ctx.fill();
        
        // Calculate eye movement based on player movement
        const eyeMoveX = Math.max(-1, Math.min(1, player.vx / MAX_SPEED)) * 0.8;
        const eyeMoveY = Math.max(-0.5, Math.min(0.5, player.vy / MAX_SPEED)) * 0.5;
        
        // Eye iris (colored) with movement
        ctx.fillStyle = '#4a90e2'; // cool blue eyes
        ctx.beginPath();
        ctx.arc(-5 + eyeMoveX, headY - 3 + eyeMoveY, 2, 0, Math.PI * 2);  // left iris
        ctx.arc(5 + eyeMoveX, headY - 3 + eyeMoveY, 2, 0, Math.PI * 2);   // right iris
        ctx.fill();
        
        // Eye pupils with movement
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-5 + eyeMoveX, headY - 3 + eyeMoveY, 1.2, 0, Math.PI * 2);  // left pupil
        ctx.arc(5 + eyeMoveX, headY - 3 + eyeMoveY, 1.2, 0, Math.PI * 2);   // right pupil
        ctx.fill();
        
        // Eye shine (multiple highlights) with movement
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-4.2 + eyeMoveX, headY - 3.5 + eyeMoveY, 0.6, 0, Math.PI * 2); // left eye main shine
        ctx.arc(-5.5 + eyeMoveX, headY - 2.8 + eyeMoveY, 0.3, 0, Math.PI * 2); // left eye small shine
        ctx.arc(5.8 + eyeMoveX, headY - 3.5 + eyeMoveY, 0.6, 0, Math.PI * 2);  // right eye main shine
        ctx.arc(4.5 + eyeMoveX, headY - 2.8 + eyeMoveY, 0.3, 0, Math.PI * 2);  // right eye small shine
        ctx.fill();
        
        // No eyelashes for masculine look
        
        // nose (subtle and natural)
        ctx.fillStyle = 'rgba(212, 165, 116, 0.2)';
        ctx.beginPath();
        ctx.ellipse(0, headY - 0.5, 1, 1.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Nose bridge highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.beginPath();
        ctx.ellipse(-0.3, headY - 1, 0.4, 1, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // mouth (natural smile)
        ctx.strokeStyle = 'rgba(160, 82, 45, 0.8)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, headY + 4, 3, 0.3, Math.PI - 0.3);
        ctx.stroke();
        
        // Upper lip subtle curve
        ctx.strokeStyle = 'rgba(160, 82, 45, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-2, headY + 3.5);
        ctx.quadraticCurveTo(0, headY + 3, 2, headY + 3.5);
        ctx.stroke();

        // Equipped items drawing
        drawEquipped(ctx, headY);

        // admin halo
        if (adminMode) {
          ctx.save();
          ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
          ctx.shadowBlur = 18;
          const grad = ctx.createLinearGradient(-20, headY - 26, 20, headY - 26);
          grad.addColorStop(0, '#ffef9e');
          grad.addColorStop(0.5, '#ffd700');
          grad.addColorStop(1, '#ffef9e');
          ctx.strokeStyle = grad;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.ellipse(0, headY - 18, 22, 8, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        
        // explorer halo (white)
        if (explorerMode) {
          ctx.save();
          ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
          ctx.shadowBlur = 20;
          const gradWhite = ctx.createLinearGradient(-20, headY - 26, 20, headY - 26);
          gradWhite.addColorStop(0, '#f0f8ff');
          gradWhite.addColorStop(0.5, '#ffffff');
          gradWhite.addColorStop(1, '#f0f8ff');
          ctx.strokeStyle = gradWhite;
          ctx.lineWidth = 5;
          ctx.beginPath();
          ctx.ellipse(0, headY - 18, 22, 8, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        
        // Dance visual effects
        if (isDancing) {
          ctx.save();
          const danceTime = (performance.now() - danceStartTime) / 1000;
          
          switch (currentDance) {
            case 'party':
              // Colorful party lights around player
              const partyColors = ['#ff6b9d', '#4ecdc4', '#ffeaa7', '#a29bfe'];
              for (let i = 0; i < 4; i++) {
                const angle = (danceTime * 2 + i * Math.PI/2) % (Math.PI * 2);
                const x = Math.cos(angle) * 40;
                const y = Math.sin(angle) * 40;
                ctx.fillStyle = partyColors[i] + '80';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
              }
              break;
              
            case 'disco':
              // Disco ball sparkles
              ctx.shadowColor = '#ffffff';
              ctx.shadowBlur = 10;
              for (let i = 0; i < 6; i++) {
                const sparkleAngle = (danceTime * 4 + i * Math.PI/3) % (Math.PI * 2);
                const sparkleX = Math.cos(sparkleAngle) * (30 + Math.sin(danceTime * 6) * 10);
                const sparkleY = Math.sin(sparkleAngle) * (30 + Math.sin(danceTime * 6) * 10);
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
                ctx.fill();
              }
              break;
              
            case 'electric':
              // Electric sparks
              ctx.strokeStyle = '#00ffff';
              ctx.lineWidth = 2;
              ctx.shadowColor = '#00ffff';
              ctx.shadowBlur = 5;
              for (let i = 0; i < 3; i++) {
                const startX = (Math.random() - 0.5) * 30;
                const startY = (Math.random() - 0.5) * 50;
                const endX = startX + (Math.random() - 0.5) * 20;
                const endY = startY + (Math.random() - 0.5) * 20;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
              }
              break;
              
            case 'fire':
              // Fire particles
              ctx.shadowColor = '#ff4757';
              ctx.shadowBlur = 8;
              const fireColors = ['#ff4757', '#ff6348', '#ffa502'];
              for (let i = 0; i < 5; i++) {
                const fireX = (Math.random() - 0.5) * 20;
                const fireY = Math.random() * -30 - 10;
                ctx.fillStyle = fireColors[Math.floor(Math.random() * fireColors.length)];
                ctx.beginPath();
                ctx.arc(fireX, fireY, 2 + Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
              }
              break;
              
            case 'breakdance':
              if (dancePose === 'freeze') {
                // Freeze effect - motion lines
                ctx.strokeStyle = '#ffffff80';
                ctx.lineWidth = 3;
                for (let i = 0; i < 8; i++) {
                  const lineAngle = i * Math.PI/4;
                  const startDist = 25;
                  const endDist = 45;
                  ctx.beginPath();
                  ctx.moveTo(Math.cos(lineAngle) * startDist, Math.sin(lineAngle) * startDist);
                  ctx.lineTo(Math.cos(lineAngle) * endDist, Math.sin(lineAngle) * endDist);
                  ctx.stroke();
                }
              }
              break;
              
            case 'wave':
              // Wave effect trails
              ctx.strokeStyle = '#74b9ff60';
              ctx.lineWidth = 4;
              const waveTrails = 5;
              for (let i = 0; i < waveTrails; i++) {
                const trailPhase = (danceTime * 2 - i * 0.2) % (Math.PI * 2);
                const waveX = Math.sin(trailPhase) * 35;
                const waveY = Math.cos(trailPhase * 1.5) * 25;
                ctx.beginPath();
                ctx.arc(waveX, waveY, 3, 0, Math.PI * 2);
                ctx.stroke();
              }
              break;
          }
          
          ctx.restore();
        }

        ctx.restore();
      }

      function trailColorForEffect(effectId) {
        switch(effectId){
          case 'blue_trail': return {r: 80, g: 160, b: 255};
          case 'fire_trail': return {r: 255, g: 120, b: 40};
          case 'confetti_trail': {
            // Rainbow confetti effect - cycle through colors
            const time = performance.now() * 0.005;
            const colors = [
              {r: 255, g: 107, b: 157}, // pink
              {r: 116, g: 185, b: 255}, // blue  
              {r: 255, g: 234, b: 167}, // yellow
              {r: 85, g: 239, b: 196},  // green
              {r: 253, g: 121, b: 168}  // purple
            ];
            const index = Math.floor(time) % colors.length;
            return colors[index];
          }
          case 'spark_trail': default: return {r: 255, g: 215, b: 0};
        }
      }

      function drawEquipped(ctx, headY) {
        // Hat
        if (equipped.hat) {
          ctx.save();
          ctx.translate(0, headY - 22);
          if (equipped.hat === 'crown_hat') {
            // Simple crown
            ctx.fillStyle = '#ffd700';
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-16, 8);
            ctx.lineTo(-10, -6);
            ctx.lineTo(-4, 8);
            ctx.lineTo(4, -6);
            ctx.lineTo(10, 8);
            ctx.lineTo(16, -6);
            ctx.lineTo(16, 8);
            ctx.lineTo(-16, 8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
          } else if (equipped.hat === 'wizard_hat') {
            // Wizard hat
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.moveTo(-14, 8);
            ctx.lineTo(0, -16);
            ctx.lineTo(14, 8);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#1abc9c';
            ctx.fillRect(-12, 6, 24, 4);
          } else if (equipped.hat === 'top_hat') {
            // Top hat (tall)
            ctx.fillStyle = '#111';
            ctx.fillRect(-12, 2, 24, 4); // brim
            ctx.fillStyle = '#222';
            ctx.fillRect(-8, -12, 16, 14); // body
            ctx.fillStyle = '#8e44ad';
            ctx.fillRect(-8, -2, 16, 2); // band
          } else if (equipped.hat === 'birthday_hat_1') {
            // Birthday hat with cake
            ctx.fillStyle = '#ff6b9d';
            ctx.beginPath();
            ctx.moveTo(-12, 8);
            ctx.lineTo(0, -14);
            ctx.lineTo(12, 8);
            ctx.closePath();
            ctx.fill();
            // Cake decoration
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-3, -2, 6, 4);
            // Candle
            ctx.fillStyle = '#fff';
            ctx.fillRect(-0.5, -8, 1, 6);
            // Flame
            ctx.fillStyle = '#ff4757';
            ctx.beginPath();
            ctx.arc(0, -8, 1.5, 0, Math.PI * 2);
            ctx.fill();
          } else if (equipped.hat === 'birthday_hat_2') {
            // Birthday hat with confetti
            ctx.fillStyle = '#4ecdc4';
            ctx.beginPath();
            ctx.moveTo(-12, 8);
            ctx.lineTo(0, -14);
            ctx.lineTo(12, 8);
            ctx.closePath();
            ctx.fill();
            // Confetti decorations
            const confettiColors = ['#ff7675', '#74b9ff', '#ffeaa7', '#fd79a8'];
            for (let i = 0; i < 8; i++) {
              ctx.fillStyle = confettiColors[i % confettiColors.length];
              const x = (i % 4 - 1.5) * 4;
              const y = -6 + Math.floor(i / 4) * 4;
              ctx.fillRect(x, y, 2, 2);
            }
          } else if (equipped.hat === 'party_hat') {
            // Colorful party hat
            const gradient = ctx.createLinearGradient(-12, 8, 12, -14);
            gradient.addColorStop(0, '#ff6b9d');
            gradient.addColorStop(0.5, '#4ecdc4');
            gradient.addColorStop(1, '#ffeaa7');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(-12, 8);
            ctx.lineTo(0, -14);
            ctx.lineTo(12, 8);
            ctx.closePath();
            ctx.fill();
            // Sparkles
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4, -2, 1, 0, Math.PI * 2);
            ctx.arc(4, -6, 1, 0, Math.PI * 2);
            ctx.arc(0, -10, 1, 0, Math.PI * 2);
            ctx.fill();
          } else if (equipped.hat === 'crown_royal') {
            // Royal crown with diamonds
            const time = performance.now() * 0.003;
            
            // Crown base - more elaborate than simple crown
            ctx.fillStyle = '#ffd700';
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-18, 8);
            ctx.lineTo(-12, -8);
            ctx.lineTo(-6, 8);
            ctx.lineTo(0, -12);
            ctx.lineTo(6, 8);
            ctx.lineTo(12, -8);
            ctx.lineTo(18, 8);
            ctx.lineTo(-18, 8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Crown band (more decorative)
            ctx.fillStyle = '#ffef9e';
            ctx.fillRect(-18, 6, 36, 4);
            
            // Diamonds on crown tips
            const diamondPositions = [-12, 0, 12];
            diamondPositions.forEach((x, i) => {
              ctx.save();
              ctx.translate(x, i === 1 ? -12 : -8);
              
              // Diamond sparkle effect
              const sparkleIntensity = Math.sin(time * 3 + i) * 0.5 + 0.5;
              ctx.shadowColor = '#fff';
              ctx.shadowBlur = 8 * sparkleIntensity;
              
              ctx.fillStyle = '#e8f4fd';
              ctx.beginPath();
              ctx.moveTo(0, -3);
              ctx.lineTo(-2, 0);
              ctx.lineTo(0, 3);
              ctx.lineTo(2, 0);
              ctx.closePath();
              ctx.fill();
              
              // Diamond shine
              ctx.fillStyle = `rgba(255, 255, 255, ${sparkleIntensity})`;
              ctx.beginPath();
              ctx.arc(0, 0, 1, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.restore();
            });
          } else if (equipped.hat === 'mega_halo') {
            // Mega halo - large glowing effect
            const time = performance.now() * 0.002;
            
            ctx.save();
            // Position above head
            ctx.translate(0, -25);
            
            // Outer glow
            const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 35);
            outerGlow.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
            outerGlow.addColorStop(0.7, 'rgba(255, 215, 0, 0.3)');
            outerGlow.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = outerGlow;
            ctx.beginPath();
            ctx.arc(0, 0, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // Main halo ring
            const mainGlow = ctx.createRadialGradient(0, 0, 15, 0, 0, 25);
            mainGlow.addColorStop(0, 'rgba(255, 255, 255, 0)');
            mainGlow.addColorStop(0.8, 'rgba(255, 215, 0, 0.9)');
            mainGlow.addColorStop(1, 'rgba(255, 215, 0, 1)');
            ctx.strokeStyle = mainGlow;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.stroke();
            
            // Floating sparkles around halo
            for (let i = 0; i < 8; i++) {
              const angle = (time + i * 0.785) % (Math.PI * 2);
              const distance = 28 + Math.sin(time * 4 + i) * 4;
              const sparkleX = Math.cos(angle) * distance;
              const sparkleY = Math.sin(angle) * distance;
              
              const sparkleAlpha = (Math.sin(time * 6 + i * 0.5) * 0.5 + 0.5);
              ctx.fillStyle = `rgba(255, 255, 255, ${sparkleAlpha})`;
              ctx.beginPath();
              ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
              ctx.fill();
              
              // Cross sparkle lines
              ctx.strokeStyle = `rgba(255, 215, 0, ${sparkleAlpha * 0.8})`;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(sparkleX - 3, sparkleY);
              ctx.lineTo(sparkleX + 3, sparkleY);
              ctx.moveTo(sparkleX, sparkleY - 3);
              ctx.lineTo(sparkleX, sparkleY + 3);
              ctx.stroke();
            }
            
            ctx.restore();
          }
          ctx.restore();
        }
        // Face (glasses)
        if (equipped.face === 'cool_glasses' || equipped.face === 'red_glasses' || equipped.face === 'laser_glasses') {
          ctx.save();
          
          if (equipped.face === 'laser_glasses') {
            // Laser glasses with red laser beams
            const time = performance.now() * 0.005;
            
            // Glasses frame (futuristic style)
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.rect(-10, headY - 6, 12, 8);
            ctx.rect(2, headY - 6, 12, 8);
            ctx.moveTo(2, headY - 2);
            ctx.lineTo(-10, headY - 2);
            ctx.stroke();
            
            // Red lens tint
            ctx.fillStyle = 'rgba(220, 20, 20, 0.3)';
            ctx.fillRect(-9, headY - 5, 10, 6);
            ctx.fillRect(3, headY - 5, 10, 6);
            
            // Laser beams shooting forward
            const beamIntensity = Math.sin(time * 3) * 0.5 + 0.5;
            const beamLength = 40 + Math.sin(time * 2) * 10;
            
            // Left laser beam
            ctx.strokeStyle = `rgba(255, 0, 0, ${beamIntensity * 0.8})`;
            ctx.lineWidth = 2;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(-4, headY - 2);
            ctx.lineTo(-4 + beamLength, headY - 2);
            ctx.stroke();
            
            // Right laser beam
            ctx.beginPath();
            ctx.moveTo(8, headY - 2);
            ctx.lineTo(8 + beamLength, headY - 2);
            ctx.stroke();
            
            // Laser beam glow effect
            ctx.strokeStyle = `rgba(255, 100, 100, ${beamIntensity * 0.4})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-4, headY - 2);
            ctx.lineTo(-4 + beamLength * 0.8, headY - 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(8, headY - 2);
            ctx.lineTo(8 + beamLength * 0.8, headY - 2);
            ctx.stroke();
            
            // Laser dots at the end
            ctx.shadowBlur = 12;
            ctx.fillStyle = `rgba(255, 0, 0, ${beamIntensity})`;
            ctx.beginPath();
            ctx.arc(-4 + beamLength, headY - 2, 2, 0, Math.PI * 2);
            ctx.arc(8 + beamLength, headY - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            
          } else {
            // Regular glasses
            ctx.strokeStyle = (equipped.face === 'red_glasses') ? '#c0392b' : '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.rect(-10, headY - 6, 12, 8);
            ctx.rect(2, headY - 6, 12, 8);
            ctx.moveTo(2, headY - 2);
            ctx.lineTo(-10, headY - 2);
            ctx.stroke();
          }
          
          ctx.restore();
        }
        // Back (cape/wings/balloons)
        if (equipped.back === 'red_cape' || equipped.back === 'angel_wings' || equipped.back === 'birthday_balloons' || equipped.back === 'heart_balloons' || equipped.back === 'dragon_wings' || equipped.back === 'shadow_cloak') {
          ctx.save();
          if (equipped.back === 'red_cape') {
            ctx.fillStyle = 'rgba(231, 76, 60, 0.9)';
            ctx.beginPath();
            ctx.moveTo(-4, -10);
            ctx.quadraticCurveTo(-22, 20, -8, 36);
            ctx.quadraticCurveTo(0, 22, 0, 10);
            ctx.closePath();
            ctx.fill();
          } else if (equipped.back === 'angel_wings') {
            // Angel wings - matching profile style
            ctx.save();
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
            ctx.shadowBlur = 12;
            
            // Gentle wing flapping animation
            const time = performance.now() * 0.002;
            const wingFlap = Math.sin(time * 1.5) * 1.5;
            
            // Draw wings spread out from back
            ctx.fillStyle = '#ffffff';
            ctx.fillText('🦅', -18 + wingFlap, -8); // Left wing
            ctx.fillText('🦅', 18 - wingFlap, -8);  // Right wing
            
            // Add subtle sparkle effect
            ctx.font = '12px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.globalAlpha = 0.5 + Math.sin(time * 3) * 0.3;
            for (let i = 0; i < 3; i++) {
              const sparkleX = Math.cos(time * 2 + i * 2) * 20;
              const sparkleY = -5 + Math.sin(time * 2.5 + i * 1.5) * 8;
              ctx.fillText('✨', sparkleX, sparkleY);
            }
            
            ctx.restore();
          } else if (equipped.back === 'dragon_wings') {
            // Dragon wings with fire effects - matching profile style
            ctx.save();
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
            ctx.shadowBlur = 15;
            
            // Wing flapping animation
            const time = performance.now() * 0.003;
            const wingFlap = Math.sin(time * 2) * 2;
            
            ctx.fillStyle = '#8b0000';
            ctx.fillText('🐉', -22 + wingFlap, -5); // Left wing
            ctx.fillText('🐉', 22 - wingFlap, -5);  // Right wing
            
            // Fire particles around dragon wings
            ctx.font = '12px Arial';
            ctx.fillStyle = '#ff4500';
            for (let i = 0; i < 4; i++) {
              const fireX = -25 + i * 15 + Math.sin(time * 4 + i) * 3;
              const fireY = 2 + Math.cos(time * 3 + i) * 2;
              ctx.globalAlpha = 0.7 + Math.sin(time * 5 + i) * 0.3;
              ctx.fillText('🔥', fireX, fireY);
            }
            ctx.restore();
          } else if (equipped.back === 'shadow_cloak') {
            // Shadow cloak with dark effects - matching profile style
            ctx.save();
            ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
            ctx.shadowBlur = 20;
            
            const time = performance.now() * 0.002;
            ctx.globalAlpha = 0.7 + Math.sin(time * 3) * 0.2;
            ctx.fillStyle = '#1a1a1a';
            ctx.fillText('🧥', 0, 8);
            
            // Shadow particles
            ctx.font = '16px Arial';
            ctx.fillStyle = '#333';
            for (let i = 0; i < 6; i++) {
              const shadowX = Math.cos(time * 2 + i * 1.05) * 25;
              const shadowY = 5 + Math.sin(time * 1.5 + i * 0.8) * 8;
              ctx.globalAlpha = 0.3 + Math.sin(time * 4 + i) * 0.2;
              ctx.fillText('•', shadowX, shadowY);
            }
            ctx.restore();
          } else if (equipped.back === 'birthday_balloons') {
            // Birthday balloons
            const balloonColors = ['#ff6b9d', '#4ecdc4', '#ffeaa7', '#fd79a8', '#74b9ff'];
            const time = performance.now() * 0.003;
            for (let i = 0; i < 5; i++) {
              const x = (i - 2) * 8;
              const y = -25 + Math.sin(time + i * 0.5) * 3;
              ctx.fillStyle = balloonColors[i];
              // Balloon
              ctx.beginPath();
              ctx.ellipse(x, y, 6, 8, 0, 0, Math.PI * 2);
              ctx.fill();
              // String
              ctx.strokeStyle = '#333';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(x, y + 8);
              ctx.lineTo(x, 10);
              ctx.stroke();
            }
          } else if (equipped.back === 'heart_balloons') {
            // Heart balloons
            const time = performance.now() * 0.003;
            for (let i = 0; i < 3; i++) {
              const x = (i - 1) * 10;
              const y = -25 + Math.sin(time + i * 0.7) * 4;
              ctx.fillStyle = ['#ff6b9d', '#fd79a8', '#ff4757'][i];
              // Heart shape
              ctx.beginPath();
              ctx.moveTo(x, y + 2);
              ctx.bezierCurveTo(x - 4, y - 2, x - 8, y + 2, x, y + 8);
              ctx.bezierCurveTo(x + 8, y + 2, x + 4, y - 2, x, y + 2);
              ctx.fill();
              // String
              ctx.strokeStyle = '#333';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(x, y + 8);
              ctx.lineTo(x, 10);
              ctx.stroke();
            }
          }
          ctx.restore();
        }
        // Feet (boots) - simple positioning
        if (equipped.feet === 'blue_boots' || equipped.feet === 'green_boots' || equipped.feet === 'golden_boots') {
          ctx.save();
          
          if (equipped.feet === 'golden_boots') {
            // Golden boots with sparkle effects
            const time = performance.now() * 0.003;
            
            // Boot glow effect
            ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#ffd700';
            
            ctx.beginPath();
            ctx.ellipse(-6, 50, 8, 5, 0, 0, Math.PI*2);
            ctx.ellipse(6, 50, 8, 5, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Sparkle effects around golden boots
            ctx.font = '8px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 4;
            for (let i = 0; i < 4; i++) {
              const sparkleX = Math.cos(time * 4 + i * 1.5) * 12 + (i < 2 ? -6 : 6);
              const sparkleY = 50 + Math.sin(time * 3 + i) * 3;
              ctx.globalAlpha = 0.6 + Math.sin(time * 5 + i) * 0.4;
              ctx.fillText('✨', sparkleX, sparkleY);
            }
          } else {
            // Regular colored boots
            ctx.fillStyle = (equipped.feet === 'green_boots') ? '#2ecc71' : '#3498db';
            ctx.beginPath();
            ctx.ellipse(-6, 50, 8, 5, 0, 0, Math.PI*2);
            ctx.ellipse(6, 50, 8, 5, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Boot outline for better definition
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(-6, 50, 8, 5, 0, 0, Math.PI*2);
            ctx.ellipse(6, 50, 8, 5, 0, 0, Math.PI*2);
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      function drawName(px, py) {
        const label = player.name || '';
        if (!label) return;
        const paddingX = 8;
        const paddingY = 4;
        const by = py + 28; // below player
        ctx.save();
        ctx.font = '14px "Segoe UI", Tahoma, Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        const textWidth = ctx.measureText(label).width;
        const w = Math.max(36, textWidth + paddingX * 2);
        const h = 18 + paddingY * 2;
        const bx = px - w / 2;
        // background pill
        roundRect(ctx, bx, by, w, h, 10, 'rgba(0,0,0,0.45)', 'rgba(255,255,255,0.12)', 1.5);
        // text
        ctx.fillStyle = '#ffffff';
        ctx.fillText(label, px, by + paddingY + 2);
        ctx.restore();
      }

      function drawChat(px, py) {
        const focused = document.activeElement === chatInput;
        const typingText = focused ? chatInput.value : '';
        let text = typingText;
        let isTyping = focused && typingText.length > 0;

        if (!isTyping && messageTimer > 0 && lastMessage) {
          text = lastMessage;
        }
        if (!text) return;

        // wrap and measure - increased width for longer text
        const maxWidth = Math.min(480, innerWidth * 0.8);
        const lines = wrapText(ctx, text, maxWidth - 24, '16px "Segoe UI", Tahoma, Arial');
        const textWidth = Math.max(...lines.map(l => ctx.measureText(l).width), 16);
        const paddingX = 16;
        const paddingY = 12;
        const w = Math.max(60, Math.min(maxWidth, textWidth + paddingX * 2));
        const h = lines.length * 20 + paddingY * 2;

        const headOffsetY = -60;
        const bx = px - w / 2;
        const by = py + headOffsetY - h;

        let fillStyle = 'rgba(255,255,255,0.95)';
        let strokeStyle = 'rgba(0,0,0,0.2)';
        let useGoldStyle = false;
        
        // Gold style for typing in admin mode OR displaying sent admin message
        if ((adminMode && isTyping) || (!isTyping && messageWasAdmin && messageTimer > 0)) {
          useGoldStyle = true;
          const grad = ctx.createLinearGradient(bx, by, bx + w, by + h);
          grad.addColorStop(0, '#fff6bf');
          grad.addColorStop(1, '#ffd700');
          fillStyle = grad;
          strokeStyle = 'rgba(120,80,0,0.6)';
        }

        ctx.save();
        ctx.shadowColor = useGoldStyle ? 'rgba(255,215,0,0.6)' : 'rgba(0,0,0,0.2)';
        ctx.shadowBlur = useGoldStyle ? 18 : 8;
        roundRect(ctx, bx, by, w, h, 12, fillStyle, strokeStyle, 2);

        // tail
        const tailX = px;
        const tailY = py - 26;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(tailX - 10, by + h - 6);
        ctx.lineTo(tailX + 10, by + h - 6);
        ctx.closePath();
        ctx.fillStyle = fillStyle;
        ctx.fill();
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 2;
        ctx.stroke();

        // text
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#222';
        ctx.font = '16px "Segoe UI", Tahoma, Arial';
        ctx.textBaseline = 'top';
        ctx.textAlign = 'center';
        let ty = by + paddingY;
        for (const line of lines) {
          ctx.fillText(line, px, ty);
          ty += 20;
        }
        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r, fill, stroke, lineWidth=1) {
        const r2 = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + r2, y);
        ctx.arcTo(x + w, y, x + w, y + h, r2);
        ctx.arcTo(x + w, y + h, x, y + h, r2);
        ctx.arcTo(x, y + h, x, y, r2);
        ctx.arcTo(x, y, x + w, y, r2);
        if (fill) { ctx.fillStyle = fill; ctx.fill(); }
        if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lineWidth; ctx.stroke(); }
      }

      function wrapText(ctx, text, maxWidth, font) {
        ctx.save();
        if (font) ctx.font = font;
        const words = text.split(/\s+/);
        const lines = [];
        let line = '';
        for (let i = 0; i < words.length; i++) {
          const test = line ? line + ' ' + words[i] : words[i];
          const width = ctx.measureText(test).width;
          if (width > maxWidth && line) {
            lines.push(line);
            line = words[i];
          } else {
            line = test;
          }
        }
        if (line) lines.push(line);
        ctx.restore();
        return lines;
      }
      
      // Additional drawing functions for enhanced effects
      function drawPlaza(camX, camY) {
        const plazaScreenX = plaza.x - camX;
        const plazaScreenY = plaza.y - camY;
        
        // Skip if plaza is too far off screen
        if (plazaScreenX < -plaza.radius - 100 || plazaScreenX > innerWidth / zoomLevel + plaza.radius + 100 || 
            plazaScreenY < -plaza.radius - 100 || plazaScreenY > innerHeight / zoomLevel + plaza.radius + 100) return;
        
        ctx.save();
        
        // Central colorful plaza circle with gradient
        const time = performance.now() * 0.001;
        const gradient = ctx.createRadialGradient(plazaScreenX, plazaScreenY, 0, plazaScreenX, plazaScreenY, plaza.radius);
        gradient.addColorStop(0, '#ff6b9d60');
        gradient.addColorStop(0.3, '#4ecdc460');
        gradient.addColorStop(0.6, '#45b7d160');
        gradient.addColorStop(1, '#96ceb400');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(plazaScreenX, plazaScreenY, plaza.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Animated light rings
        if (plaza.lightRings) {
          for (const ring of plaza.lightRings) {
            const intensity = (Math.sin(time * ring.speed + ring.radius * 0.01) * 0.5 + 0.5) * 0.4;
            ctx.strokeStyle = ring.color + Math.floor(intensity * 255).toString(16).padStart(2, '0');
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.arc(plazaScreenX, plazaScreenY, ring.radius + Math.sin(time * ring.speed) * 10, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.setLineDash([]);
        }
        
        ctx.restore();
      }
      
      function drawConfetti(camX, camY) {
        ctx.save();
        for (const p of confetti) {
          const sx = p.x - camX;
          const sy = p.y - camY;
          
          // Skip if too far from screen
          if (sx < -20 || sx > innerWidth / zoomLevel + 20 || sy < -20 || sy > innerHeight / zoomLevel + 20) continue;
          
          ctx.save();
          ctx.translate(sx, sy);
          ctx.rotate(p.rot);
          
          // Enhanced confetti with glow effect if glowing
          if (p.glowing) {
            const glowIntensity = Math.sin(p.twinkle) * 0.5 + 0.5;
            ctx.shadowColor = p.col;
            ctx.shadowBlur = 8 * glowIntensity;
          }
          
          ctx.fillStyle = p.col;
          ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
          ctx.restore();
        }
        ctx.restore();
      }
      
      function drawCollectibles(camX, camY) {
        const time = performance.now() * 0.003;
        for (const gift of collectibles) {
          if (gift.picked) continue;
          
          const sx = gift.x - camX;
          const sy = gift.y - camY;
          
          // Skip if too far from screen
          if (sx < -50 || sx > innerWidth / zoomLevel + 50 || sy < -50 || sy > innerHeight / zoomLevel + 50) continue;
          
          ctx.save();
          ctx.translate(sx, sy + Math.sin(time + gift.x * 0.01) * 3); // Floating animation
          
          // Glowing gift box
          const glowSize = 25 + Math.sin(time * 2 + gift.x * 0.02) * 5;
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
          gradient.addColorStop(0, '#ffd70080');
          gradient.addColorStop(0.7, '#ffd70040');
          gradient.addColorStop(1, '#ffd70000');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
          ctx.fill();
          
          // Gift box
          ctx.fillStyle = '#ff6b6b';
          ctx.fillRect(-12, -12, 24, 24);
          
          // Ribbon
          ctx.fillStyle = '#ffd700';
          ctx.fillRect(-2, -12, 4, 24);
          ctx.fillRect(-12, -2, 24, 4);
          
          // Bow
          ctx.beginPath();
          ctx.moveTo(-8, -12);
          ctx.quadraticCurveTo(-12, -16, -6, -16);
          ctx.quadraticCurveTo(0, -12, 6, -16);
          ctx.quadraticCurveTo(12, -16, 8, -12);
          ctx.quadraticCurveTo(4, -8, 0, -12);
          ctx.quadraticCurveTo(-4, -8, -8, -12);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
      }
      
      function drawCoins(camX, camY) {
        const time = performance.now() * 0.002;
        for (const coin of coinsOnMap) {
          const sx = coin.x - camX;
          const sy = coin.y - camY;
          
          // Skip if too far from screen  
          if (sx < -30 || sx > innerWidth / zoomLevel + 30 || sy < -30 || sy > innerHeight / zoomLevel + 30) continue;
          
          ctx.save();
          ctx.translate(sx, sy + Math.sin(time * 3 + coin.x * 0.05) * 2);
          
          // Coin glow
          const glowSize = 15 + Math.sin(time * 4 + coin.x * 0.03) * 3;
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
          gradient.addColorStop(0, '#ffd70060');
          gradient.addColorStop(1, '#ffd70000');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
          ctx.fill();
          
          // Coin
          ctx.fillStyle = '#ffd700';
          ctx.strokeStyle = '#b8860b';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Coin symbol
          ctx.fillStyle = '#b8860b';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('💰', 0, 0);
          
          ctx.restore();
        }
      }
      
      function rand2d(ix, iy, salt = 0) {
        return fract(Math.sin((ix + salt) * 17.13 + (iy + salt) * 241.39) * 27431.2);
      }
      
      // Draw vehicle function
      function drawVehicle(vx, vy, angle) {
        if (!playerVehicle) return;
        
        ctx.save();
        ctx.translate(vx, vy);
        ctx.rotate(angle);
        
        const time = performance.now() * 0.001;
        
        if (playerVehicle === 'basic_car') {
          // Basic car - simple rectangle
          ctx.fillStyle = '#4a90e2';
          ctx.fillRect(-20, -12, 40, 24);
          
          // Car details
          ctx.fillStyle = '#87ceeb';
          ctx.fillRect(-15, -8, 12, 6); // front window
          ctx.fillRect(-15, 2, 12, 6);  // back window
          ctx.fillRect(3, -8, 12, 16);  // side windows
          
          // Wheels
          ctx.fillStyle = '#333';
          ctx.beginPath();
          ctx.arc(-12, -14, 4, 0, Math.PI * 2);
          ctx.arc(-12, 14, 4, 0, Math.PI * 2);
          ctx.arc(12, -14, 4, 0, Math.PI * 2);
          ctx.arc(12, 14, 4, 0, Math.PI * 2);
          ctx.fill();
          
        } else if (playerVehicle === 'sports_car') {
          // Sports car - sleeker design
          const gradient = ctx.createLinearGradient(-20, -12, 20, 12);
          gradient.addColorStop(0, '#e74c3c');
          gradient.addColorStop(1, '#c0392b');
          ctx.fillStyle = gradient;
          
          // Car body - more aerodynamic shape
          ctx.beginPath();
          ctx.moveTo(-20, -8);
          ctx.lineTo(-18, -12);
          ctx.lineTo(18, -12);
          ctx.lineTo(20, -8);
          ctx.lineTo(20, 8);
          ctx.lineTo(18, 12);
          ctx.lineTo(-18, 12);
          ctx.lineTo(-20, 8);
          ctx.closePath();
          ctx.fill();
          
          // Flames effect
          ctx.strokeStyle = '#f39c12';
          ctx.lineWidth = 2;
          for (let i = 0; i < 3; i++) {
            const flameY = -6 + i * 6;
            ctx.beginPath();
            ctx.moveTo(20, flameY);
            ctx.lineTo(25 + Math.sin(time * 5 + i) * 3, flameY + Math.cos(time * 4 + i) * 2);
            ctx.stroke();
          }
          
          // Windows
          ctx.fillStyle = '#2c3e50';
          ctx.fillRect(-12, -6, 10, 4);
          ctx.fillRect(-12, 2, 10, 4);
          ctx.fillRect(2, -6, 14, 12);
          
          // Wheels with rims
          ctx.fillStyle = '#2c3e50';
          ctx.beginPath();
          ctx.arc(-10, -14, 5, 0, Math.PI * 2);
          ctx.arc(-10, 14, 5, 0, Math.PI * 2);
          ctx.arc(10, -14, 5, 0, Math.PI * 2);
          ctx.arc(10, 14, 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Wheel centers
          ctx.fillStyle = '#95a5a6';
          ctx.beginPath();
          ctx.arc(-10, -14, 2, 0, Math.PI * 2);
          ctx.arc(-10, 14, 2, 0, Math.PI * 2);
          ctx.arc(10, -14, 2, 0, Math.PI * 2);
          ctx.arc(10, 14, 2, 0, Math.PI * 2);
          ctx.fill();
          
        } else if (playerVehicle === 'luxury_car') {
          // Luxury car - elegant design with effects
          const luxGradient = ctx.createLinearGradient(-22, -14, 22, 14);
          luxGradient.addColorStop(0, '#2c3e50');
          luxGradient.addColorStop(0.5, '#34495e');
          luxGradient.addColorStop(1, '#2c3e50');
          ctx.fillStyle = luxGradient;
          
          // Luxury car body
          ctx.fillRect(-22, -14, 44, 28);
          
          // Gold trim
          ctx.strokeStyle = '#f1c40f';
          ctx.lineWidth = 2;
          ctx.strokeRect(-22, -14, 44, 28);
          
          // Tinted windows
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(-16, -10, 14, 6);
          ctx.fillRect(-16, 4, 14, 6);
          ctx.fillRect(2, -10, 16, 20);
          
          // Luxury wheels
          ctx.fillStyle = '#2c3e50';
          ctx.beginPath();
          ctx.arc(-14, -16, 6, 0, Math.PI * 2);
          ctx.arc(-14, 16, 6, 0, Math.PI * 2);
          ctx.arc(14, -16, 6, 0, Math.PI * 2);
          ctx.arc(14, 16, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // Golden rims
          ctx.strokeStyle = '#f1c40f';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(-14, -16, 6, 0, Math.PI * 2);
          ctx.arc(-14, 16, 6, 0, Math.PI * 2);
          ctx.arc(14, -16, 6, 0, Math.PI * 2);
          ctx.arc(14, 16, 6, 0, Math.PI * 2);
          ctx.stroke();
          
          // Sparkle effects around luxury car
          ctx.fillStyle = '#f39c12';
          for (let i = 0; i < 8; i++) {
            const sparkleAngle = (i / 8) * Math.PI * 2 + time * 2;
            const sparkleRadius = 35 + Math.sin(time * 3 + i) * 5;
            const sx = Math.cos(sparkleAngle) * sparkleRadius;
            const sy = Math.sin(sparkleAngle) * sparkleRadius;
            ctx.beginPath();
            ctx.arc(sx, sy, 1, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Vehicle interaction indicator
        if (!inVehicle) {
          const pulse = 0.8 + Math.sin(time * 4) * 0.2;
          ctx.strokeStyle = 'rgba(52, 152, 219, 0.8)';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.arc(0, 0, 30 * pulse, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        ctx.restore();
      }
      
      // Draw player in vehicle
      function drawPlayerInVehicle(px, py, angle) {
        // First draw the vehicle
        drawVehicle(px, py, angle);
        
        // Then draw the player inside (simplified)
        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(angle);
        
        // Player head visible through window
        ctx.fillStyle = '#ffd5b4';
        ctx.beginPath();
        ctx.arc(-5, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Player hair
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.arc(-5, -3, 9, Math.PI, Math.PI * 2);
        ctx.fill();
        
        // Player eyes
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(-7, -2, 1, 0, Math.PI * 2);
        ctx.arc(-3, -2, 1, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Initialize XP system
      initializePlayerLevel();
      
      // Game loop with XP system integration
      let lastTime = performance.now();
      function gameLoop(currentTime) {
        const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
        lastTime = currentTime;
        
        // Update XP system
        updateXPSystem(deltaTime);
        
        requestAnimationFrame(gameLoop);
      }
      
      // Start the game loop
      requestAnimationFrame(gameLoop);
      
    })();
    
    // === ONLINE MULTIPLAYER FUNCTIONALITY ===
    // Socket.io connection and multiplayer features
    
    let socket = null;
    let onlinePlayers = new Map();
    let isOnline = false;
    let lastMovementUpdate = 0;
    let onlineChatMessages = [];
    
    // Initialize online connection
    function initializeOnline() {
      try {
        socket = io();
        setupSocketListeners();
        console.log('🌍 מתחבר למשחק אונליין...');
      } catch (error) {
        console.log('❌ לא ניתן להתחבר למשחק אונליין:', error);
        updateConnectionStatus(false, 'אופליין');
      }
    }
    
    function setupSocketListeners() {
      // Connection established
      socket.on('connect', () => {
        console.log('✅ התחברת למשחק אונליין!');
        isOnline = true;
        updateConnectionStatus(true, 'מחובר');
        
        // Join the game
        socket.emit('playerJoin', {
          name: player.name,
          x: player.x,
          y: player.y,
          angle: player.angle,
          coins: coins,
          adminMode: adminMode,
          explorerMode: explorerMode,
          equipped: equipped,
          ownedItems: Array.from(ownedItems)
        });
        
        showPickupText('🌍 התחברת למשחק אונליין!', innerWidth/2, 100);
      });
      
      // Connection lost
      socket.on('disconnect', () => {
        console.log('❌ החיבור לשרת נפסק');
        isOnline = false;
        updateConnectionStatus(false, 'מנותק');
        onlinePlayers.clear();
        showPickupText('❌ החיבור לשרת נפסק', innerWidth/2, 100);
      });
      
      // Receive game state
      socket.on('gameState', (gameState) => {
        console.log('📥 התקבל מצב משחק:', gameState);
        
        // Update online players
        onlinePlayers.clear();
        gameState.players.forEach(playerData => {
          onlinePlayers.set(playerData.id, playerData);
        });
        
        // Update online count
        updateOnlineCount(gameState.players.length + 1); // +1 for local player
        
        // Update chat messages
        onlineChatMessages = gameState.chats || [];
        
        // Sync coins and gifts (replace local ones with server ones)
        // Note: This is a simplified sync - in production you'd want more sophisticated merging
        syncGameItems(gameState);
      });
      
      // New player joined
      socket.on('playerJoined', (playerData) => {
        console.log('👋 שחקן חדש הצטרף:', playerData.name);
        onlinePlayers.set(playerData.id, playerData);
        updateOnlineCount(onlinePlayers.size + 1);
        showPickupText(`👋 ${playerData.name} הצטרף למשחק`, innerWidth/2, innerHeight - 100);
      });
      
      // Player left
      socket.on('playerLeft', (playerId) => {
        const player = onlinePlayers.get(playerId);
        if (player) {
          console.log('👋 שחקן עזב:', player.name);
          showPickupText(`👋 ${player.name} עזב את המשחק`, innerWidth/2, innerHeight - 100);
        }
        onlinePlayers.delete(playerId);
        updateOnlineCount(onlinePlayers.size + 1);
      });
      
      // Player moved
      socket.on('playerMoved', (moveData) => {
        const player = onlinePlayers.get(moveData.id);
        if (player) {
          player.x = moveData.x;
          player.y = moveData.y;
          player.angle = moveData.angle;
        }
      });
      
      // Chat message received
      socket.on('chatMessage', (messageData) => {
        onlineChatMessages.push(messageData);
        if (onlineChatMessages.length > 100) {
          onlineChatMessages.shift();
        }
        
        // Show chat message as floating text
        const playerData = onlinePlayers.get(messageData.playerId);
        if (playerData) {
          const camX = player.x - innerWidth / 2;
          const camY = player.y - innerHeight / 2;
          const screenX = playerData.x - camX;
          const screenY = playerData.y - camY - 40;
          
          if (screenX > 0 && screenX < innerWidth && screenY > 0 && screenY < innerHeight) {
            showPickupText(`💬 ${messageData.playerName}: ${messageData.message}`, screenX, screenY);
          }
        }
        
        console.log(`💬 ${messageData.playerName}: ${messageData.message}`);
      });
      
      // Item collection events
      socket.on('coinCollected', (data) => {
        // Remove coin from local display
        const coinIndex = coinsOnMap.findIndex(c => c.id === data.coinId);
        if (coinIndex !== -1) {
          coinsOnMap.splice(coinIndex, 1);
        }
        
        // Show collection message
        const playerData = onlinePlayers.get(data.playerId);
        if (playerData) {
          showPickupText(`💰 ${playerData.name} אסף מטבע!`, innerWidth/2, 200);
        }
      });
      
      socket.on('newCoin', (coin) => {
        coinsOnMap.push(coin);
      });
      
      socket.on('giftCollected', (data) => {
        // Remove gift from local display
        const giftIndex = collectibles.findIndex(g => g.id === data.giftId);
        if (giftIndex !== -1) {
          collectibles.splice(giftIndex, 1);
        }
        
        // Show collection message
        const playerData = onlinePlayers.get(data.playerId);
        if (playerData) {
          showPickupText(`🎁 ${playerData.name} אסף מתנה!`, innerWidth/2, 230);
        }
      });
      
      socket.on('newGift', (gift) => {
        collectibles.push({
          id: gift.id,
          x: gift.x,
          y: gift.y,
          itemId: gift.itemId,
          picked: false
        });
      });
      
      // Global messages (explorer feature)
      socket.on('globalMessage', (data) => {
        showPickupText(`🌍 ${data.senderName}: ${data.message}`, innerWidth/2, 50);
      });
      
      // Heartbeat
      socket.on('heartbeat', (timestamp) => {
        // Keep connection alive
      });
    }
    
    // Update connection status display
    function updateConnectionStatus(connected, statusText) {
      const statusEl = document.getElementById('connectionStatus');
      const statusTextEl = document.getElementById('statusText');
      
      if (connected) {
        statusEl.classList.remove('disconnected');
        statusTextEl.innerHTML = '🟢 ' + statusText;
      } else {
        statusEl.classList.add('disconnected');
        statusTextEl.innerHTML = '🔴 ' + statusText;
      }
    }
    
    // Update online player count
    function updateOnlineCount(count) {
      document.getElementById('onlineCount').textContent = count;
    }
    
    // Send movement updates to server
    function sendMovementUpdate() {
      if (!isOnline || !socket) return;
      
      const now = performance.now();
      if (now - lastMovementUpdate < 50) return; // Throttle to 20 updates per second
      
      socket.emit('playerMove', {
        x: player.x,
        y: player.y,
        angle: player.angle
      });
      
      lastMovementUpdate = now;
    }
    
    // Send chat message online
    function sendOnlineChat(message) {
      if (isOnline && socket && message.trim()) {
        socket.emit('chatMessage', {
          message: message.trim()
        });
      }
    }
    
    // Send item collection to server
    function collectOnlineCoin(coin) {
      if (isOnline && socket) {
        socket.emit('collectCoin', coin.id);
      }
    }
    
    function collectOnlineGift(gift) {
      if (isOnline && socket) {
        socket.emit('collectGift', gift.id);
      }
    }
    
    // Sync game items with server
    function syncGameItems(gameState) {
      // Sync coins
      coinsOnMap.length = 0;
      gameState.coins.forEach(coin => {
        coinsOnMap.push({
          id: coin.id,
          x: coin.x,
          y: coin.y
        });
      });
      
      // Sync gifts
      collectibles.length = 0;
      gameState.gifts.forEach(gift => {
        collectibles.push({
          id: gift.id,
          x: gift.x,
          y: gift.y,
          itemId: gift.itemId,
          picked: false
        });
      });
    }
    
    // Draw online players
    function drawOnlinePlayers(camX, camY) {
      if (!isOnline) return;
      
      for (const [playerId, playerData] of onlinePlayers.entries()) {
        const sx = playerData.x - camX;
        const sy = playerData.y - camY;
        
        // Only draw if player is visible on screen
        if (sx > -100 && sx < innerWidth + 100 && sy > -100 && sy < innerHeight + 100) {
          ctx.save();
          ctx.translate(sx, sy);
          ctx.rotate(playerData.angle);
          
          // Draw player (simplified version)
          // Body
          ctx.fillStyle = '#ffd5b4';
          ctx.beginPath();
          ctx.arc(0, -5, 12, 0, Math.PI * 2);
          ctx.fill();
          
          // Head
          ctx.beginPath();
          ctx.arc(0, -25, 8, 0, Math.PI * 2);
          ctx.fill();
          
          // Admin/Explorer halo
          if (playerData.adminMode) {
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, -25, 15, 0, Math.PI * 2);
            ctx.stroke();
          } else if (playerData.explorerMode) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, -25, 15, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          // Player name
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(0,0,0,0.8)';
          ctx.shadowBlur = 4;
          ctx.fillText(playerData.name, 0, -45);
          
          ctx.restore();
        }
      }
    }
    
    // Override original functions to include online functionality
    const originalSendChat = sendChat;
    sendChat = function() {
      const text = chatInput.value.trim();
      if (text) {
        // Send to online players
        sendOnlineChat(text);
        
        // Keep original local functionality
        lastMessage = text;
        messageTimer = MESSAGE_SHOW_TIME;
        messageWasAdmin = adminMode;
        chatInput.value = '';
      }
      chatInput.blur();
    };
    
    // Override coin collection
    const originalCoinCollection = function() {
      // This will be integrated into the main coin collection code
    };
    
    // Modify the main update function to send movement updates
    const originalUpdate = update;
    function updateWithOnline(dt) {
      originalUpdate(dt);
      
      // Send movement updates if player moved
      const speed = Math.hypot(player.vx, player.vy);
      if (speed > 1 && isOnline) {
        sendMovementUpdate();
      }
    }
    
    // Modify the main draw function to include online players
    const originalDraw = draw;
    function drawWithOnline() {
      originalDraw();
      
      // Draw online players
      const camX = player.x - innerWidth / 2;
      const camY = player.y - innerHeight / 2;
      drawOnlinePlayers(camX, camY);
    }
    
    // Replace the main functions
    update = updateWithOnline;
    draw = drawWithOnline;
    
    // Initialize online connection on page load
    window.addEventListener('load', () => {
      // Wait a bit for the game to initialize
      setTimeout(() => {
        initializeOnline();
      }, 1000);
    });
    
    // Handle page unload
    window.addEventListener('beforeunload', () => {
      if (socket) {
        socket.disconnect();
      }
    });
    
  </script>
</body>
</html>
